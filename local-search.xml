<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>unicorn原理浅析</title>
    <link href="/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="unicorn是什么？"><a href="#unicorn是什么？" class="headerlink" title="unicorn是什么？"></a>unicorn是什么？</h1><p><strong>Unicorn</strong> 是一个基于 QEMU 的轻量级 CPU 仿真框架，用于模拟多种架构（如 ARM、x86、MIPS 等）的指令执行和状态变化。其本质是通过 <strong>动态二进制翻译</strong> (Dynamic Binary Translation) 将目标架构的指令翻译为宿主架构可执行代码，并在宿主机运行。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul><li><strong>多架构支持</strong>：支持 ARM、x86、MIPS 等主流架构及模式（如 ARM&#x2F;Thumb）。</li><li><strong>指令仿真</strong>：精准模拟 CPU 指令行为（如跳转、寄存器操作、内存访问等）。</li><li><strong>内存与寄存器仿真</strong>：用户可自定义虚拟内存布局及操作寄存器。</li><li><strong>钩子机制</strong>：支持拦截指令、内存访问等，便于监控和调试。</li></ul><h3 id="本质特点"><a href="#本质特点" class="headerlink" title="本质特点"></a><strong>本质特点</strong></h3><ul><li><strong>动态翻译</strong>：基于 QEMU 的 TCG 技术，直接在宿主机运行目标指令，高效快捷。</li><li><strong>模块化</strong>：仅关注 CPU 指令仿真，易用、灵活，适合安全研究、逆向工程和嵌入式开发。</li></ul><h1 id="ARM64的体系架构"><a href="#ARM64的体系架构" class="headerlink" title="ARM64的体系架构"></a>ARM64的体系架构</h1><p>见上篇文章：ARM64架构</p><h1 id="unicorn怎么运行起来的？"><a href="#unicorn怎么运行起来的？" class="headerlink" title="unicorn怎么运行起来的？"></a>unicorn怎么运行起来的？</h1><p>CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）</p><p>Unicorn要模拟的是CPU的运行。所以也就（只）是，把代码放到对应的地址上，Unicorn开始运行，去对应地址：<strong>读取指令</strong>，（解析并）<strong>执行指令</strong>，而解析和运行该指令的结果，往往是，本身就是，写入计算后的结果到对应的寄存器或内存而已。</p><p>而在指令执行期间的所需要的其他内容，比如后续会涉及到的函数参数、Stack栈、Heap堆等等，则都是为了：确保Unicorn模拟CPU的结果，和真实的代码执行的结果，要（完全）一致，才有价值，才能真正得到的希望的输出的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">指令<span class="hljs-operator">=</span>instruction <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 代码<span class="hljs-operator">=</span>code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 操作码<span class="hljs-operator">=</span>opcode <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 二进制(数据) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> binary (data)<br></code></pre></td></tr></table></figure><h2 id="怎么模拟出内存等结构的？"><a href="#怎么模拟出内存等结构的？" class="headerlink" title="怎么模拟出内存等结构的？"></a>怎么模拟出内存等结构的？</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p><img src="https://s2.loli.net/2024/12/17/kpMjRTFBOX3Qv2V.png" alt="image-20241217103506135"></p><p>一个常见的内存布局如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>起始地址</strong></th><th><strong>大小</strong></th><th><strong>权限</strong></th></tr></thead><tbody><tr><td>代码段</td><td><code>0x40000</code></td><td>2 MB</td><td>可读可执行（RX）</td></tr><tr><td>数据段</td><td><code>0x42000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆区</td><td><code>0x60000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆栈段</td><td><code>0x7FFF0000</code></td><td>1 MB（向下增长）</td><td>可读可写（RW）</td></tr></tbody></table><p><strong>代码段</strong>：</p><ul><li>通常映射在较低的地址区域，如 <code>0x40000</code>，用来存储程序的指令。</li><li>设置为可读可执行权限（<code>UC_PROT_READ | UC_PROT_EXEC</code>）。</li></ul><p><strong>数据段</strong>：</p><ul><li>紧邻代码段，用来存储全局变量、静态变量等。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>堆区</strong>：</p><ul><li>用于动态分配内存，可以根据程序运行时的需求调整大小。</li><li>通过自定义的内存管理器或直接扩展区域实现。</li></ul><p><strong>堆栈段</strong>：</p><ul><li>通常放在高地址区域（如 <code>0x7FFF0000</code>），并从高地址向低地址增长。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>Unicorn 的内存设置是它自己模拟的，而不是由操作系统直接管理的</strong>。Unicorn 作为一个用户态的 CPU 仿真框架，模拟了目标架构的 CPU 和内存系统。Unicorn 将内存的虚拟地址（如 <code>0x40000</code> 或 <code>0x7FFF0000</code>）完全作为目标架构的地址模拟，与主机的虚拟地址无关。主机操作系统只负责分配 Unicorn 运行本身需要的资源（如 CPU 时间和主机内存），但不会干涉 Unicorn 模拟的内存布局。</p><p>值得注意的是：</p><p>Unicorn 本身并不会主动区分“特殊用途”地址和“普通地址”，但它的执行逻辑可能依赖用户分配的地址。但如果你在 <code>0x0 - 0xFFFF</code> 范围内映射代码或数据，可能会导致以下问题：</p><ol><li><strong>Unicorn 的初始化数据</strong>：某些架构可能会默认初始化特定的寄存器或内存区域到低地址，用户手动操作的地址可能与这些区域冲突。</li><li><strong>调试和兼容性问题</strong>：许多调试工具或调试器（如 GDB）默认会将低地址区域视为不可用的保留空间。如果代码被放置在低地址区域，调试时可能导致断点设置失败或程序崩溃。</li></ol><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>写入内容（代码，数据）到内存中之前，要注意先确认<code>字节序</code>&#x3D;<code>endian</code>是<code>大端</code>还是<code>小端</code></p><p>ARM中，默认是<code>小端</code>&#x3D;<code>UC_MODE_LITTLE_ENDIAN</code></p><p>除非特殊需要，才会设置为<code>大端</code>&#x3D;<code>UC_MODE_BIG_ENDIAN</code></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>(1) 动态二进制翻译（Dynamic Binary Translation）</strong></td><td></td></tr><tr><td><strong>翻译机制</strong></td><td>- 通过 QEMU 的 TCG（Tiny Code Generator）实现动态翻译。- 将目标架构的指令翻译为宿主架构的中间表示（IR, Intermediate Representation）。- 翻译后的代码缓存在 <strong>Translation Block Cache (TLB)</strong> 中。</td></tr><tr><td><strong>执行流程</strong></td><td>1. 解析目标架构指令。2. 使用 TCG 将指令翻译为宿主架构的中间代码（IR）。3. 中间代码再翻译为宿主机的原生机器指令，并直接运行。</td></tr><tr><td><strong>性能特点</strong></td><td>- 比解释型模拟（如 Bochs）快得多。- 动态翻译存在一定开销，但重复执行时利用 TLB 提升效率。</td></tr><tr><td><strong>(2) 指令的分发与仿真</strong></td><td></td></tr><tr><td><strong>指令获取</strong></td><td>- 从当前 <strong>PC（Program Counter）</strong> 所指向的地址读取目标内存中的指令。- 内存管理由 Unicorn 的虚拟内存模型负责，需通过 <strong><code>uc_mem_map</code></strong> 等接口预先映射内存。</td></tr><tr><td><strong>指令解析与翻译</strong></td><td>- 根据架构解码指令，提取操作码和操作数。示例：- <strong>ARM</strong>：解析指令类型（如分支 <code>BL</code>、数据处理 <code>ADD</code>、内存访问 <code>LDR</code>）。- <strong>x86</strong>：解析指令（如 <code>MOV</code>、<code>CALL</code>、<code>JMP</code>）。</td></tr><tr><td><strong>指令执行</strong></td><td>- 将解析的指令翻译为宿主机代码并执行。- 例如模拟内存访问、条件跳转、异常处理等。</td></tr><tr><td><strong>状态更新</strong></td><td>- 根据指令执行结果更新模拟状态（寄存器、内存等）。</td></tr><tr><td><strong>(3) 内存与寄存器仿真</strong></td><td></td></tr><tr><td><strong>内存仿真</strong></td><td>- Unicorn 使用虚拟内存模型模拟目标架构内存。- 用户通过 <strong><code>uc_mem_map</code></strong> 定义虚拟内存布局。- 所有内存访问都经 Unicorn 的内存管理层检查。</td></tr><tr><td><strong>寄存器仿真</strong></td><td>- 不同架构有各自的寄存器模型：    - <strong>x86</strong>：<code>EIP</code>、<code>ESP</code> 等。    - <strong>ARM</strong>：<code>R0-R15</code>、<code>PC</code>、<code>LR</code> 等。- 用户通过 <strong><code>uc_reg_read</code></strong> 和 <strong><code>uc_reg_write</code></strong> 接口操作寄存器。</td></tr><tr><td><strong>(4) 钩子机制（Hooking Mechanism）</strong></td><td></td></tr><tr><td><strong>代码钩子</strong></td><td>- 拦截特定指令或地址范围的执行。</td></tr><tr><td><strong>内存钩子</strong></td><td>- 拦截内存读写访问，用于监控或修改操作。</td></tr><tr><td><strong>异常钩子</strong></td><td>- 捕获未定义指令、未映射内存访问等异常。</td></tr><tr><td><strong>(5) 架构和模式切换</strong></td><td></td></tr><tr><td><strong>支持的架构</strong></td><td><strong>x86、x86_64、ARM、ARM64、MIPS、SPARC、PowerPC</strong></td></tr><tr><td><strong>模式切换</strong></td><td>- <strong>x86</strong>：支持 32 位和 64 位模式切换。- <strong>ARM</strong>：支持 ARM 模式和 Thumb 模式切换（通过 <code>BLX</code> 等指令）。- 用户初始化时通过 <code>Uc(UC_ARCH_ARM, UC_MODE_THUMB)</code> 指定模式，模拟中可根据指令动态切换。</td></tr></tbody></table><h1 id="unicorn使用的基本思想？"><a href="#unicorn使用的基本思想？" class="headerlink" title="unicorn使用的基本思想？"></a>unicorn使用的基本思想？</h1><h2 id="运行前初始化"><a href="#运行前初始化" class="headerlink" title="运行前初始化"></a>运行前初始化</h2><p>主要是对内存布局，比如：堆，栈等一些设置，注意对需要模拟的函数参数<strong>提前写入寄存器</strong>，其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。</p><h2 id="运行中Hook"><a href="#运行中Hook" class="headerlink" title="运行中Hook"></a>运行中Hook</h2><p>开始运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mu.emu_start(ADDRESS, ADDRESS + <span class="hljs-built_in">len</span>(ARM_CODE))<br></code></pre></td></tr></table></figure><ul><li>ADDRESS：最开始映射的代码的最初位置</li><li>ADDRESS + len(ARM_CODE)：映射的代码起始位置，加上对应代码长度后的，结束位置</li></ul><blockquote><p>为了用Unicorn模拟代码运行，调试出我们希望搞懂的函数的逻辑，往往期间需要很多额外的调试内容</p></blockquote><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Unicorn模拟期间，常需要去搞懂底层正在发生的细节，查看对应的寄存器、内存的值等等，此时，就可以用到Unicorn所提供的机制：hook。</p><p>其中比较常用的一些hook是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">- hook代码<br>- hook特定指令<br>- hook内存<br>- hook异常<br>- hook其他<br></code></pre></td></tr></table></figure><p>关于Unicorn支持的hook的全部种类是：</p><p>指令执行类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_INTR`<br>- `UC_HOOK_INSN`<br>- `UC_HOOK_CODE`<br>- `UC_HOOK_BLOCK`<br></code></pre></td></tr></table></figure><p>内存访问类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_PROT`<br>- `UC_HOOK_MEM_WRITE_PROT`<br>- `UC_HOOK_MEM_FETCH_PROT`<br>- `UC_HOOK_MEM_READ`<br>- `UC_HOOK_MEM_WRITE`<br>- `UC_HOOK_MEM_FETCH`<br>- `UC_HOOK_MEM_READ_AFTER`<br></code></pre></td></tr></table></figure><p>异常处理类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_UNMAPPED`<br>- `UC_HOOK_MEM_WRITE_UNMAPPED`<br>- `UC_HOOK_MEM_FETCH_UNMAPPED`<br>- `UC_HOOK_INSN_INVALID`<br></code></pre></td></tr></table></figure><p>其他</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_EDGE_GENERATED`<br>- `UC_HOOK_TCG_OPCODE`<br></code></pre></td></tr></table></figure><p>Hook的设置，在运行中逐指令进行对比，当符合设置的内容时，触发钩子函数进行处理</p><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>引入外部的反汇编器disassembler，比如<code>Capstone</code>，自己去把二进制翻译为对应指令</p><h2 id="运行后获取结果"><a href="#运行后获取结果" class="headerlink" title="运行后获取结果"></a>运行后获取结果</h2><h3 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h3><p>对于Unicorn来说，就是模拟CPU运行，模拟去读取指令和运行指令而已。</p><p>所以，换句话说，如果你的给code代码的地址空间写入了代码后，如果没有额外的跳转等复杂逻辑，则：</p><ul><li><strong>Unicorn会一直运行下去</strong></li></ul><p>如果没有合适的触发时机，去让其停下来，那就变成了死循环，永远不结束了。</p><p>而我们的目标是：模拟代码，尤其是函数的逻辑，希望代码运行完毕，输出结果的。</p><p>所以，此处往往选择一个合适的时机去触发其让Unicorn停下来。</p><p>这个时机，一般都是：<code>ret</code>指令，即，当发现正在运行的指令是<code>ret</code>指令，则就会调用<code>emu_stop</code>去停下来。</p><p><strong>在<code>hook_code</code>中，借助<code>Capstone</code>反编译出当前指令，其中<code>mnemonic</code>就是指令名称，当发现是<code>ret</code>指令时</strong></p><p>注：对于arm64e来说，还有更多的PAC相关ret指令：<code>retaa</code>、<code>retab</code>等，所以此处用<code>re</code>正则去判断指令名称是否匹配，而不是直接判断和<code>ret</code>是否相等。</p><p>就去调用<code>emu_stop()</code>去停止Unicorn的继续运行。</p><p><strong>这里也是借助Hook进行的</strong></p><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><p>通过读取寄存器中的值来获取结果</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://book.crifan.org/books/cpu_emulator_unicorn/website/how_use/background/core_logic/cpu_logic.html">CPU的核心逻辑 · CPU模拟利器：Unicorn</a></p>]]></content>
    
    
    <categories>
      
      <category>Reverse(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>unicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angr原理浅析</title>
    <link href="/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p><strong>约束条件（Constraints）</strong> 是对问题求解空间的限制或规定，它规定了哪些解是允许的，哪些解是不允许的。在数学、计算机科学、逻辑学等领域，约束条件通常用于描述某个问题的限制条件，目的是让我们能够从所有可能的解中筛选出符合特定规则或要求的解。</p><p>在数学中，约束条件通常是一些方程或不等式，定义了一个问题的解集。例如，约束条件 <code>x + y ≤ 10</code> 就表示在求解时，变量 <code>x</code> 和 <code>y</code> 的和不能超过 10。</p><p>在计算机科学，约束条件常常是对程序状态的描述，表示程序在某一时刻满足的条件或限制。例如，假设有一个条件 <code>if (x &lt; 10)</code>，那么在程序的执行过程中，<code>x &lt; 10</code> 就是一个约束条件。</p><h2 id="什么是Z3"><a href="#什么是Z3" class="headerlink" title="什么是Z3"></a>什么是Z3</h2><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p><p>不深入研究的话，这里可以简单理解为：<strong>解方程</strong>，当然他还有很多应用场景比如：</p><ul><li><strong>布尔逻辑</strong>：可以处理布尔表达式，求解SAT（布尔可满足性）问题。</li><li><strong>线性算术</strong>：能够处理整数和实数的线性约束。</li><li><strong>非线性算术</strong>：支持非线性算术运算的求解。</li><li><strong>数组、集合、图结构</strong>：支持复杂的数据结构。</li><li><strong>符号执行</strong>：结合符号执行技术，Z3能对程序的执行路径进行分析和求解。</li><li><strong>程序验证</strong>：通过将程序的行为转化为约束，Z3可以帮助验证程序是否满足特定的安全性或功能性要求。</li><li><strong>自动化定理证明</strong>：Z3可以用来证明数学定理或逻辑公式的有效性。</li></ul><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> Solver, Real, sat<br><br><span class="hljs-comment"># 创建符号变量 x</span><br>x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br><br><span class="hljs-comment"># 创建方程：x^2 - 3x + 2 = 0</span><br>equation = x**<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个求解器</span><br>solver = Solver()<br><br><span class="hljs-comment"># 将方程添加到求解器</span><br>solver.add(equation)<br><br><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">if</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程无解&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/5rTdVqvCSa6zQtP.png" alt="image-20241219153257642" style="zoom:50%;" /></p><p>而不是：x &#x3D; 1和x &#x3D; 2</p><p>这是因为Z3 在求解方程时，默认情况下只返回第一个找到的解。这是因为 Z3 是一个 <strong>满足性求解器</strong>（Satisfiability Solver），它的目标是检查约束是否可满足，并返回其中一个满足约束的解，而不是所有可能的解。</p><p>通过进一步添加约束条件可以得到所有解（即排除已经找到的解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">while</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 排除当前解，继续寻找下一个解</span><br>    solver.add(x != model[x])<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/mJYOACvKk2acpsj.png" alt="image-20241219153642676" style="zoom:50%;" /></p><h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="https://s2.loli.net/2024/12/19/u3ez9CtglaXyJNk.png" alt="220430bodvqhbod4pty8zv"></p><p>符号执行是一种程序分析技术，它通过将程序中的某些变量替换为符号变量（而不是具体值），来模拟程序的执行。符号变量代表任意值，并通过符号计算来追踪程序的执行路径和计算结果。与传统的测试方法不同，它并不是通过具体的输入值来执行程序，而是通过符号表示的输入值来执行程序，并尝试探索程序中所有可能的执行路径。</p><h3 id="符号执行流程"><a href="#符号执行流程" class="headerlink" title="符号执行流程"></a>符号执行流程</h3><p><strong>符号变量</strong>： 在符号执行中，输入变量（例如函数参数、内存内容等）被替换为符号变量（symbolic variables），这些符号变量表示可以取任意值。与传统的实际值（如整数、字符串）不同，符号变量没有固定的值，而是代表一个值的集合或范围。</p><p><strong>路径探索</strong>： 符号执行通过模拟程序的控制流来探索不同的路径。每当程序遇到条件判断（例如 <code>if</code> 语句）时，它会根据符号变量的约束来分裂路径。符号执行引擎会为每条路径维护一组条件约束，表示该路径的执行条件。</p><p><strong>约束收集与求解</strong>： 在执行过程中，每当遇到条件判断时（例如 <code>if</code> 语句），符号执行引擎会根据条件生成约束（例如 <code>x &lt; 10</code> 或 <code>x &gt;= 10</code>）。这些约束随着路径的推进被累积。最后，使用约束求解器（如 Z3）来检查是否存在解，即判断某条路径是否可行。如果求解器找到了满足这些约束的具体输入值，那么符号执行就能沿着这条路径继续模拟执行。</p><h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr?"></a>什么是angr?</h2><p><strong>angr</strong> 是一个基于 Python 的 <strong>二进制分析框架</strong>，专门用于分析二进制程序。它提供了一个强大的工具集，用于执行分析任务，如符号执行（Symbolic Execution）、路径探索（Path Exploration）、漏洞挖掘、逆向工程、静态分析等。</p><h2 id="angr的工作原理？"><a href="#angr的工作原理？" class="headerlink" title="angr的工作原理？"></a>angr的工作原理？</h2><ol><li><strong>加载二进制</strong>：<ul><li>使用 angr 加载目标二进制文件（例如 ELF、PE 格式的可执行文件）。</li></ul></li><li><strong>符号执行与路径探索</strong>：<ul><li>angr 会在二进制程序的某些地方插入符号（symbolic variables），并从程序入口点（例如 <code>main</code> 函数）开始执行。每执行一步，angr 会模拟程序的行为并生成新的约束条件。</li></ul></li><li><strong>生成约束</strong>：<ul><li>在符号执行过程中，程序的条件分支会根据符号变量的取值生成约束（例如：<code>x &lt; 10</code>）。这些约束会被加入到当前路径的状态中。</li></ul></li><li><strong>路径分裂</strong>：<ul><li>当遇到条件分支时，angr 会将程序的执行路径分裂成多个子路径。例如，<code>if (x &lt; 10)</code> 会导致两个路径，一个路径满足 <code>x &lt; 10</code>，另一个路径满足 <code>x &gt;= 10</code>。</li></ul></li><li><strong>求解与回溯</strong>：<ul><li>每条路径都会产生约束，angr 会通过求解器（如 Z3）来判断某条路径是否可行。如果路径不可行，angr 会将其丢弃。如果路径可行，它将继续沿着该路径执行，直到达到目标或出现漏洞。</li></ul></li></ol><p>可以看出同unicorn只能走一个分支相比，angr在运行的过程中，从给定的一个state(程序状态，程序的寄存器值，内存的不同都可以作为程序状态的不同)开始执行，每个state维护着一个约束条件的集合(比如i&lt;10,i!&#x3D;0)，通过收集约束，进行遍历，最终angr理论上可以遍历到程序的所有可能控制流，当angr运行到目标状态时，就可以调用求解器(z3等)对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p><img src="https://s2.loli.net/2024/12/19/pwKVfMPCjUbX95v.jpg" alt="215918bnzmvv6wzoqingwv"></p><p>值得注意的是：同传统的静态符号执行(unicorn引擎)相比，<strong>angr使用的是混合执行技术，合并了静态符号执行，和动态具体执行两种技术</strong></p><p>动态符号执行（concolic execution）维持了两个状态。一种是实际变量的状态，另一种是符号化的状态。实际状态将随机生成值映射到变量中，而符号化状态将变量进行符号化。concolic首先将实际状态运行，并收集实际运行时该路径的变量符号化的约束式，i求解。并将约束式取反，获取另一条路径的约束式并求解。过程不断重复，知道路径被探索完，或者达到用户设置的限制。</p><p>具体的例子可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 路径1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 路径2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      <span class="hljs-comment">// 路径3</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态执行过程"><a href="#动态执行过程" class="headerlink" title="动态执行过程"></a>动态执行过程</h3><ol><li><strong>实际状态</strong>：随机初始化输入，例如 <code>x = 15</code>。</li><li><strong>符号化状态</strong>：将 <code>x</code> 表示为符号变量 <code>X</code>。</li></ol><hr><h4 id="步骤1：运行实际状态并收集约束"><a href="#步骤1：运行实际状态并收集约束" class="headerlink" title="步骤1：运行实际状态并收集约束"></a><strong>步骤1：运行实际状态并收集约束</strong></h4><ol><li><p><strong>实际运行</strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">15</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>1</code>，对应<strong>路径1</strong>。</p></li><li><p><strong>符号化执行</strong>：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt; <span class="hljs-number">10</span>  (路径<span class="hljs-number">1</span>)<br>X &lt; <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>将这些条件存入符号约束集。</p></li></ol><hr><h4 id="步骤2：生成新路径（约束取反）"><a href="#步骤2：生成新路径（约束取反）" class="headerlink" title="步骤2：生成新路径（约束取反）"></a><strong>步骤2：生成新路径（约束取反）</strong></h4><ol><li><p>从约束集中取反条件：</p><p>原路径约束为 <code>X &gt; 10 &amp;&amp; X &lt; 20</code>。</p><p>取反约束为 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>即：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span> || X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择其中一条路径：<code>X &lt;= 10</code>**。</p><p>求解约束 <code>X &lt;= 10</code>，求解器可能返回 <code>X = 5</code>。</p></li></ol><hr><h4 id="步骤3：探索新路径"><a href="#步骤3：探索新路径" class="headerlink" title="步骤3：探索新路径"></a><strong>步骤3：探索新路径</strong></h4><ol><li><p>使用新值 <code>x = 5</code> 实际运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">5</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>) &#123;           // 条件不成立<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>3</code>，对应<strong>路径3</strong>。</p></li><li><p>收集符号化约束：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span>  (路径<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="步骤4：继续探索未覆盖的路径"><a href="#步骤4：继续探索未覆盖的路径" class="headerlink" title="步骤4：继续探索未覆盖的路径"></a><strong>步骤4：继续探索未覆盖的路径</strong></h4><ol><li><p>再次从约束集中取反条件：</p><p>已探索的路径约束为：</p><p>​     路径1：<code>X &gt; 10 &amp;&amp; X &lt; 20</code></p><p>​     路径3：<code>X &lt;= 10</code></p><p>合并取反条件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>) &amp;&amp; !(X &lt;= <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>简化后为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择路径：<code>X &gt;= 20</code>**。</p><p>求解约束 <code>X &gt;= 20</code>，求解器可能返回 <code>X = 25</code>。</p></li><li><p>使用新值 <code>x = 25</code> 实际运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>执行路径为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件不成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>2</code>，对应<strong>路径2</strong>。</p></li></ol><hr><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h4><p>动态符号执行会重复上述过程：</p><ol><li>实际运行一个具体值。</li><li>收集符号化约束。</li><li>取反约束生成新路径。</li><li>继续探索未覆盖的路径。</li></ol><p>直到：</p><ul><li><strong>所有路径都被探索</strong>：程序的逻辑分支全部覆盖。</li><li><strong>达到用户设定的限制</strong>：例如最大路径数量、最大求解时间等。</li></ul><h2 id="angr的不足"><a href="#angr的不足" class="headerlink" title="angr的不足"></a>angr的不足</h2><h3 id="未约束导致路径爆炸"><a href="#未约束导致路径爆炸" class="headerlink" title="未约束导致路径爆炸"></a>未约束导致路径爆炸</h3><p>在符号执行中，如果函数的输入变量或状态没有被有效约束（即没有设定足够的条件），Angr 等工具会把这些变量当作符号值进行推理和执行。而未约束的变量可能会导致两方面的问题：</p><ol><li><strong>不确定的输入</strong>： 如果输入没有约束（例如，函数的参数没有指定具体的值或者范围），那么每次执行到某个条件判断时，就会有多个可能的选择。例如，假设你有一个函数，其中某个参数 <code>x</code> 的值没有明确的限制，那么在 <code>if</code> 语句中对 <code>x</code> 的判断就可能导致多个分支，每个分支都有不同的路径。</li><li><strong>无限循环</strong>： 当未约束的变量影响到循环条件时，符号执行就无法准确预测循环何时结束，因为它并不知道循环的终止条件何时成立。例如，某个循环的退出条件可能是 <code>x == 0</code>，但 <code>x</code> 是一个未约束的符号变量，Angr 并不知道 <code>x</code> 什么时候会变为 0。因此，符号执行引擎就可能会一直在这个循环中进行模拟，导致路径在循环内无限增长。</li></ol><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">void foo(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们给定一个具体的值，例如 <code>x = 10</code>，程序会在 10 次迭代后退出。</li><li>但是如果 <code>x</code> 是一个未约束的符号变量（例如，Angr 看到 <code>x</code> 是一个符号值），它就不能确定 <code>x</code> 会在什么时候达到 0，或者是否有可能永远不为 0。</li></ul><p>在符号执行中，Angr 会尝试探索所有可能的路径。在这种情况下，由于 <code>x</code> 没有约束，符号执行引擎无法推断出 <code>x</code> 何时会变为 0，因此它可能会认为该循环将永远执行下去，导致<strong>路径爆炸</strong>。</p><h4 id="路径爆炸与无限循环的关系"><a href="#路径爆炸与无限循环的关系" class="headerlink" title="路径爆炸与无限循环的关系"></a><strong>路径爆炸与无限循环的关系</strong></h4><p>路径爆炸指的是，随着未约束变量的增加，符号执行的路径数量呈指数级增长，导致无法有效地探索所有路径。无限循环是路径爆炸的一种特殊情况，通常发生在没有足够约束的情况下，符号执行无法判断循环是否终止，从而导致执行路径无法终止。</p><p>例如，当未约束的循环变量 <code>x</code> 不断变化，且影响循环的终止条件时，Angr 可能会不断生成新的路径，每个路径代表不同的 <code>x</code> 值和不同的循环迭代次数，最终导致路径数量迅速膨胀，系统无法有效处理这些路径，从而导致“卡死”。</p><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x = x - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 没有任何约束，Angr 会将其视为符号变量，可能会生成多条路径来探索 <code>x</code> 可能的值。每条路径都会尝试模拟 <code>x</code> 在每次循环中的变化，直到达到退出条件 <code>x &lt;= 0</code>。</p><p>在符号执行的过程中，Angr 会对每次 <code>x = x - 1</code> 做出决策，并生成新的路径。</p><p>如果没有足够的约束（例如，限制 <code>x</code> 的值或设置循环的最大迭代次数），Angr 可能会生成大量的路径来模拟不同的 <code>x</code> 值和循环次数，导致路径数目激增，甚至无法终止。</p><h3 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h3><p>事实上angr是基于符号执行来遍历程序的所有路径，它是否能遍历所有路径其实取决于其约束求解引擎是否强大，这里采用的是z3<br>当它能明确发现这个条件是无法满足的时候就不会走向这个路径，我们可以称之为虚假控制流。<br>但是如果程序本身的逻辑中存在一个条件是非常难以满足的，或者说超出了约束求解引擎的能力，那么则有可能到达不了这个路径，就会被误标记为虚假的控制流，实际中是很少出现的。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[动若脱兔:深入浅出angr--初步理解符号执行以及angr架构 - 0xJDchen - 博客园](https://www.cnblogs.com/0xJDchen/p/9291335.html)<br><br>[利用angr去除混淆的优势，不足与实践 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1484714-1-1.html)<br><br>[angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园](https://www.cnblogs.com/level5uiharu/p/16925991.html)<br><br>[angr - CTF Wiki](https://ctf-wiki.org/reverse/tools/simulate-execution/angr/)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识JVM</title>
    <link href="/2024/12/19/%E5%88%9D%E8%AF%86JVM/"/>
    <url>/2024/12/19/%E5%88%9D%E8%AF%86JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。java语言跨平台的秘密</p><h1 id="Java如何被JVM所运行？"><a href="#Java如何被JVM所运行？" class="headerlink" title="Java如何被JVM所运行？"></a>Java如何被JVM所运行？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">Java 源文件 --&gt; 编译器 --&gt; .<span class="hljs-keyword">class</span>字节码文件--&gt; 类加载器--&gt;JVM<br></code></pre></td></tr></table></figure><h2 id="1-什么是-class字节码文件？"><a href="#1-什么是-class字节码文件？" class="headerlink" title="1.什么是.class字节码文件？"></a>1.什么是.class字节码文件？</h2><p>在 Java 中，JVM 可以理解的代码叫作字节码，也就是 .class 文件，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，并且保留了解释型语言可移植的特点，而通过即时编译器（JIT）又有编译型语言执行效率高的特点。所以 Java 程序运行时比较高效，同时 Java 通过字节码文件和虚拟机之间的关系，实现了平台无关性，一次编译，各平台都可运行。</p><p><a href="https://www.cnblogs.com/code-duck/p/13568004.html#%E4%BA%8C-class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Class文件结构（详细解读） - codeduck - 博客园</a></p><h3 id="1-1-class文件与java源代码中的class类有什么联系和区别？"><a href="#1-1-class文件与java源代码中的class类有什么联系和区别？" class="headerlink" title="1.1 .class文件与java源代码中的class类有什么联系和区别？"></a>1.1 .class文件与java源代码中的class类有什么联系和区别？</h3><h2 id="2-怎么编译成-class字节码文件？"><a href="#2-怎么编译成-class字节码文件？" class="headerlink" title="2.怎么编译成.class字节码文件？"></a>2.怎么编译成.class字节码文件？</h2><p><a href="https://blog.csdn.net/weixin_44688973/article/details/125757836">Java文件是怎么编译成Class文件的_java编译成class-CSDN博客</a></p><p>答：编译原理相关，暂时略过</p><h2 id="3-类加载器工作原理"><a href="#3-类加载器工作原理" class="headerlink" title="3.类加载器工作原理"></a>3.类加载器工作原理</h2><h3 id="3-1-什么是双亲委派机制"><a href="#3-1-什么是双亲委派机制" class="headerlink" title="3.1 什么是双亲委派机制"></a>3.1 什么是双亲委派机制</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。（类加载器之间的父子关系不是以继承的关系实现，而是使用组合关系来复用父加载器的代码）</p><p><img src="https://s2.loli.net/2024/10/04/Klyv9UDehVc4uNT.webp" alt="双亲委派机制"></p><p>如果类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层级的类加载器都是如此，因此所有请求最终都会被传到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。因此，加载过程可以看成自底向上检查类是否已经加载，然后自顶向下加载类。整个过程就是一个递归的过程</p><p>整个过程：</p><ol><li><strong>自定义类加载器</strong>收到类加载请求，首先检查缓存是否已经加载该类。</li><li>如果未找到，则将请求<strong>委派给父类加载器</strong>，父类加载器首先会检查自己是否已经加载过该类（调用 <code>findLoadedClass()</code>）。如果找到，则返回该类，类加载过程结束。如果找不到，则继续将请求委派给其父类加载器</li><li>逐层向上，直到最顶层的<strong>启动类加载器（Bootstrap ClassLoader）</strong>。</li><li><strong>启动类加载器</strong>检查核心类库，能加载则返回，若不能加载则返回 <code>null</code>，传递控制权回给下层加载器。它的<strong>子类加载器</strong>将获得加载类的机会，并且尝试自己去加载该类。加载成功，则类加载过程结束。如果它也无法加载，则返回 <code>null</code>，传递控制权回给下层加载器</li><li>各层加载器依次返回，若父加载器未加载到类，则最底层的<strong>自定义类加载器</strong>通过 <code>findClass()</code> 方法尝试自己加载该类。</li><li>成功加载后，类会被缓存，加载过程结束。如果所有加载器都未能加载，抛出 <code>ClassNotFoundException</code>。</li></ol><p><img src="https://s2.loli.net/2024/10/04/C1XeMY9PkpbfL5F.png" alt="双亲委派"></p><p>双亲委派模型的优点：</p><ol><li><p>使用双亲委派模型来组织类加载器之间的关系，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没必要再加载一次。</p></li><li><p>解决各个类加载器的基础类的统一问题，越基础的类由越上层的加载器进行加载。避免Java核心API中的类被随意替换，规避风险，防止核心API库被随意篡改。</p></li></ol><blockquote><p>例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。</p></blockquote><h1 id="JVM的组成与运行原理？"><a href="#JVM的组成与运行原理？" class="headerlink" title="JVM的组成与运行原理？"></a>JVM的组成与运行原理？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.<span class="hljs-keyword">class</span>字节码文件 --&gt; JVM --&gt; 机器码<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/15/zQjNwtq1Ef2UKv3.png" alt="1"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="本地方法栈和程序计数器"><a href="#本地方法栈和程序计数器" class="headerlink" title="本地方法栈和程序计数器"></a>本地方法栈和程序计数器</h3><p>native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（method area）</strong>只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="虚拟机栈和虚拟机堆"><a href="#虚拟机栈和虚拟机堆" class="headerlink" title="虚拟机栈和虚拟机堆"></a>虚拟机栈和虚拟机堆</h3><blockquote><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p></blockquote><h4 id="虚拟机栈的生命周期"><a href="#虚拟机栈的生命周期" class="headerlink" title="虚拟机栈的生命周期"></a>虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="虚拟机堆的概念"><a href="#虚拟机堆的概念" class="headerlink" title="虚拟机堆的概念"></a>虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MetaspaceSize：初始化元空间大小，控制发生<span class="hljs-built_in">GC</span><br>MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<br></code></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行 main 方法</li><li>这个 main 中的第一条语句为 Student student &#x3D; new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行 sayName()</li></ol><p><a href="https://blog.csdn.net/csdnliuxin123524/article/details/81303711">JVM原理最全、清晰、通俗讲解，五天40小时吐血整理_jvm原理讲解教程最全清晰通俗讲解-CSDN博客</a></p><p>jvm虚拟机位于操作系统的堆中，并且，程序员写好的类加载到虚拟机执行的过程是：当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader，</p><p><strong>java虚拟机的生命周期</strong>：声明周期起点是当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。</p><p><strong>java虚拟机与main方法的关系</strong>：main函数就是一个java应用的入口，main函数被执行时，java虚拟机就启动了。启动了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机。</p><p>java的虚拟机种有两种线程，一种叫叫守护线程，一种叫非守护线程（也叫普通线程），main函数就是个非守护线程，虚拟机的gc就是一个守护线程。java的虚拟机中，只要有任何非守护线程还没有结束，java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以jvm没办法退出</p><p>虚拟机的gc（垃圾回收机制）就是一个典型的守护线程。</p><p><img src="https://s2.loli.net/2024/12/16/Vc3OL6JyM5qvz8T.png" alt="fdb281da8c98cc1240281d4520bc947f"></p><h2 id="1-JVM如何将-class字节码文件转化为对应机器的机器码"><a href="#1-JVM如何将-class字节码文件转化为对应机器的机器码" class="headerlink" title="1.JVM如何将.class字节码文件转化为对应机器的机器码"></a>1.JVM如何将.class字节码文件转化为对应机器的机器码</h2><p><a href="https://javaguide.cn/java/jvm/jvm-intro.html">大白话带你认识 JVM | JavaGuide</a></p><p><img src="https://s2.loli.net/2024/12/15/2SNXkfbxFtVypJ7.webp" alt="c602f57ea9297f50bbc265f1821d6263"></p><p><a href="https://www.doc200.com/java-interview/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9FJVM%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9F.html">8. 什么是Java字节码？JVM如何将字节码转换为机器代码？ | 胖虎Docs</a></p><p>JVM将字节码转换为机器代码的过程主要依赖于其执行引擎。执行引擎负责解释和执行字节码，并将其转换为底层的机器代码，以便在物理硬件上执行。这个过程分为两个主要部分：解释执行和即时编译（JIT）。</p><h4 id="1-解释执行"><a href="#1-解释执行" class="headerlink" title="1. 解释执行"></a>1. 解释执行</h4><p>解释器是JVM的一个组件，它逐行解释字节码，并将其转换为对应的机器码指令，然后在处理器上执行。</p><p>工作原理</p><ul><li>JVM启动时，解释器开始工作，读取字节码指令，并解释成相应的机器码指令。</li><li>每条字节码指令都通过解释器进行解释，然后立即执行。这种方式简单直接，但对于频繁执行的代码（如循环体）效率较低。</li></ul><p>优点</p><ul><li>启动快，解释器立即可以开始执行字节码。</li><li>对于短期任务，解释器可以快速响应。</li></ul><p>缺点</p><ul><li>对于重复执行的代码，解释效率较低，因为每次循环都要重新解释相同的字节码。</li></ul><h4 id="2-即时编译"><a href="#2-即时编译" class="headerlink" title="2. 即时编译"></a>2. 即时编译</h4><p>为了提升程序的运行效率，JVM引入了JIT编译器。JIT编译器在程序运行时将热点代码（频繁执行的代码）编译为本地机器码，并将其缓存起来，以避免重复解释相同的字节码。</p><p>工作原理</p><ul><li>JVM在解释执行字节码的过程中，识别出哪些方法或代码块被频繁执行，称为“热点代码”。</li><li>JIT编译器将这些热点代码一次性编译为平台相关的机器码，存储在内存中。</li><li>当热点代码再次被执行时，JVM直接使用编译后的机器码，而不是通过解释器逐行解释，从而大幅提升执行效率。</li></ul><p>优点</p><ul><li>提升性能：JIT编译后的代码直接以机器码形式执行，性能接近于本地编译的程序。</li><li>逐渐优化：JIT编译器可以随着程序的运行，动态调整和优化编译策略。</li></ul><p>缺点</p><ul><li>编译开销：JIT编译会占用一些系统资源，在程序启动的初期可能导致响应变慢。</li><li>内存占用：编译后的机器码需要在内存中保存。</li></ul><h3 id="JVM的执行模式"><a href="#JVM的执行模式" class="headerlink" title="JVM的执行模式"></a>JVM的执行模式</h3><p>JVM在实际运行过程中，可能会采用解释执行和JIT编译的混合模式。在程序刚启动时，JVM可能更多依赖解释器，而当程序运行时间较长、热点代码较多时，JIT编译器将逐步接管更多的工作，从而提升整体运行效率。</p><h3 id="1-1-什么是Just-In-Time-JIT-编译器？"><a href="#1-1-什么是Just-In-Time-JIT-编译器？" class="headerlink" title="1.1 什么是Just-In-Time (JIT) 编译器？"></a>1.1 什么是Just-In-Time (JIT) 编译器？</h3><p><a href="https://blog.csdn.net/Genmer/article/details/119355224">关于Java的JIT(即时编译器)知识整理_java jit-CSDN博客</a></p><p>解释执行：解释执行是采用匹配执行解释器（解释器是个黑盒，通常也有编译器的组成部分）内部已经编译好的机器码，不是生成新的机器码（也有说法是逐条翻译成机器码？）。 - 由于逐条翻译，程序启动快，但是执行效率不高。</p><p>编译执行：运行期间，通过将字节码编译成对应的新的机器码（会将其缓存起来，通过参数-XX:ReservedCodeCacheSize），然后执行。 - 需要先编译出新的机器指令，所以程序启动较慢，但是执行效率高（因为执行的是机器指令）。</p><p>后来因为解释执行必然比执行编译好的机器指令的执行效率低，所以引入JIT（即时编译器）。在执行时，JIT会把翻译过的机器码保存起来，已备下次使用，因此从理论上来说，采用JIT技术能够在执行效率上，接近曾经纯编译技术。</p><p><strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行</strong>；当程序运行后，随着时间的推移，<strong>编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率</strong>。解释执行可以节约内存，而编译执行可以提升效率。</p><p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践 - 美团技术团队</a></p><p><img src="https://s2.loli.net/2024/12/16/ztKTYcNZlQoOGVg.png" alt="ba83857ecf9f344e4972fd551c4973d653952"></p><p><a href="https://javabetter.cn/jvm/jit.html">10 张手绘图 8000 字深入理解 JIT（即时编译器） | 二哥的Java进阶之路</a></p><p><a href="https://www.cnblogs.com/dzhou/p/9549839.html">什么是JIT，写的很好 - ddzh2020 - 博客园</a></p><h2 id="2-GC垃圾回收算法"><a href="#2-GC垃圾回收算法" class="headerlink" title="2.GC垃圾回收算法"></a>2.GC垃圾回收算法</h2><p>暂时略过</p><p><a href="https://blog.csdn.net/Pireley/article/details/134315943">Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器_java的内存模型以及gc算法-CSDN博客</a></p><h1 id="JVM如何与操作系统交互？"><a href="#JVM如何与操作系统交互？" class="headerlink" title="JVM如何与操作系统交互？"></a>JVM如何与操作系统交互？</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI?"></a>1.什么是JNI?</h2><p>JNI（Java Native Interface，Java本地接口）是 Java 提供的一种接口，允许 Java 程序调用本地（Native）代码或被本地代码调用。所谓本地代码通常是用 C 或 C++ 等语言编写的，并直接与底层硬件或操作系统交互。</p><h2 id="2-JNI工作原理？"><a href="#2-JNI工作原理？" class="headerlink" title="2.JNI工作原理？"></a>2.JNI工作原理？</h2><img src="https://s2.loli.net/2024/12/19/RfgdDQ4ilBIpA8O.jpg" alt="4403ab758e8ee449292962c2ec050ba6" style="zoom:50%;" /><h3 id="Java-调用-Native-代码"><a href="#Java-调用-Native-代码" class="headerlink" title="Java 调用 Native 代码"></a><strong>Java 调用 Native 代码</strong></h3><h4 id="为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？"><a href="#为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？" class="headerlink" title="为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？"></a>为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？</h4><p>这也就是JNI层的表现形式，中间的<strong>JNI层其实也是C++代码，它的作用就是桥梁，在这个C++代码中我们可以调用Java层代码也可以调用Native层的C++代码(天然可以，都是C++)<strong>。由于这里特殊的C++代码，可以把俩种混调用(Java和C++)，所以</strong>JNI有它自己的类型</strong>。例如：</p><ul><li><code>int</code> → <code>jint</code></li><li><code>boolean</code> → <code>jboolean</code></li></ul><p><img src="https://s2.loli.net/2024/12/19/ZSuBchRUQf8GF4O.jpg" alt="3fbc8cdc00c9070bffc0f094ae7792e3"></p><h4 id="本地实现函数的命名规则"><a href="#本地实现函数的命名规则" class="headerlink" title="本地实现函数的命名规则"></a>本地实现函数的命名规则</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 前缀“Java_”。</span><br><span class="hljs-deletion">- 类的全名。</span><br><span class="hljs-deletion">- 下划线分隔符“_”。</span><br><span class="hljs-deletion">- 方法名字。</span><br><span class="hljs-deletion">- 有方法重载的情况时，还会有两个下划线（“__”），后面跟着参数描述符。</span><br></code></pre></td></tr></table></figure><p>假设 Java 类 <code>com.example.MyClass</code> 中有如下的本地方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>对应的本地方法 C 实现会是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_com_example_MyClass_doSomething(JNIEnv </span>*, <span class="hljs-keyword">jobject);</span><br></code></pre></td></tr></table></figure><p>这样，通过 JNI 约定的命名规则，虚拟机可以根据 Java 方法的名称和参数生成与之匹配的本地方法名称，从而成功调用 C&#x2F;C++ 实现的本地方法。</p><h4 id="类加载器与本地库的关系"><a href="#类加载器与本地库的关系" class="headerlink" title="类加载器与本地库的关系"></a><strong>类加载器与本地库的关系</strong></h4><h5 id="1-本地库绑定到类加载器"><a href="#1-本地库绑定到类加载器" class="headerlink" title="(1) 本地库绑定到类加载器"></a><strong>(1) 本地库绑定到类加载器</strong></h5><ul><li>当一个类调用 <code>System.loadLibrary</code> 或 <code>System.load</code> 加载本地库时，该本地库会被绑定到加载该类的类加载器。</li><li>JVM 会确保一个本地库在同一个类加载器中只加载一次。</li><li>如果两个不同的类加载器加载同一个本地库，会导致冲突或错误。</li></ul><h5 id="2-本地方法的作用域"><a href="#2-本地方法的作用域" class="headerlink" title="(2) 本地方法的作用域"></a><strong>(2) 本地方法的作用域</strong></h5><ul><li>本地库中的方法仅在加载该库的类加载器和其加载的类中可用。</li><li>如果不同类加载器的类需要共享同一个本地库，则需要注意：<ul><li>本地库必须显式加载一次，并由共享的类加载器负责。</li><li>否则可能引发 <code>UnsatisfiedLinkError</code>。</li></ul></li></ul><p><strong>(3) 自定义类加载器的影响</strong></p><p>如果使用自定义类加载器加载一个类，并在该类中调用本地方法：</p><ul><li>自定义类加载器的作用域会限制本地库的使用。</li><li>需要确保本地库文件在正确的路径中，或者显式调用 <code>System.load</code> 指定绝对路径。</li></ul><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><h5 id="类加载器与本地库的关联"><a href="#类加载器与本地库的关联" class="headerlink" title="类加载器与本地库的关联"></a>类加载器与本地库的关联</h5><p>类加载器在加载 Java 类的字节码（<code>.class</code> 文件）如果发现：</p><ul><li><p><strong>显式关联：</strong> 使用 <code>System.loadLibrary()</code> 或 <code>System.load()</code> 函数显式加载本地库。</p><p>例如，如果 Java 类 <code>MyClass</code> 需要调用一个本地方法 <code>nativeMethod()</code>，则在 <code>static</code> 块或类初始化过程中，可能会显式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;mylibrary&quot;</span>);  <span class="hljs-comment">// 显式加载名为 &quot;mylibrary&quot; 的本地库</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>System.loadLibrary(&quot;mylibrary&quot;)</code> 会将名为 <code>&quot;mylibrary&quot;</code> 的本地库与 <code>MyClass</code> 关联。这时，类加载器就会知道需要加载哪个本地库。</p></li><li><p><strong>隐式关联：</strong> 本地库的加载通常在第一次调用本地方法时自动发生。此时，JVM 会在类加载器关联的路径中搜索本地库，并加载适当的本地库。</p><p>例如，当第一次调用 <code>nativeMethod()</code> 时，JVM 会查找并加载该方法对应的本地库。类加载器会使用它的 <code>nativeLibrary</code> 搜索路径来找到相应的本地库。</p></li></ul><h5 id="类加载器如何与本地库关联"><a href="#类加载器如何与本地库关联" class="headerlink" title="类加载器如何与本地库关联"></a>类加载器如何与本地库关联</h5><p>加载器会维护一个本地库搜索路径，来查找它关联的本地库。这个路径通常是在启动 Java 程序时通过环境变量、Java 参数或类加载器配置进行设置的。类加载器的本地库搜索路径包括：</p><p><strong>系统路径：</strong> 默认情况下，JVM 会在操作系统的标准路径（如 <code>PATH</code> 环境变量中的路径，Windows 上的 <code>.dll</code> 文件路径，Unix&#x2F;Linux 上的 <code>.so</code> 文件路径）中查找本地库。</p><p><strong>指定路径：</strong> 当调用 <code>System.loadLibrary()</code> 时，本地库路径可能会通过 JVM 参数传递（例如 <code>-Djava.library.path</code>）。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">java -Djava.<span class="hljs-keyword">library</span>.path=/path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">library</span> MyClass<br></code></pre></td></tr></table></figure><p>在这个例子中，JVM 会使用 <code>-Djava.library.path</code> 参数指定的路径来搜索本地库。</p><p><strong>类加载器路径：</strong> 每个类加载器（比如 <code>AppClassLoader</code> 或自定义的类加载器）也可能有自己独立的路径来加载本地库。这个路径由类加载器的实现决定。</p><h5 id="本地库加载的时机"><a href="#本地库加载的时机" class="headerlink" title="本地库加载的时机"></a>本地库加载的时机</h5><p>本地库的加载通常发生在第一次调用本地方法时，即在 <strong>链接本地方法时</strong>。这个过程分为几个步骤：</p><ol><li><strong>类加载：</strong> 当 JVM 加载包含本地方法的类时，它会检查该类是否包含 <code>native</code> 方法。如果包含，JVM 就会在后续的调用中解析这个本地方法。</li><li><strong>本地方法调用：</strong> 当 Java 代码首次调用 <code>native</code> 方法时，JVM 会尝试加载与该方法相关联的本地库。</li><li><strong>本地库加载：</strong> JVM 会根据类加载器的配置，搜索本地库。如果找到相应的本地库，JVM 就会将本地方法与本地库中的实现绑定，并建立关联。</li><li><strong>链接成功：</strong> 一旦本地方法被链接，JVM 会创建内部的数据结构（如函数指针或本地方法的映射表），使得后续的调用可以直接跳转到本地库中的对应函数。</li></ol><h3 id="Native-代码调用-Java"><a href="#Native-代码调用-Java" class="headerlink" title="Native 代码调用 Java"></a><strong>Native 代码调用 Java</strong></h3><h4 id="JNIEnv接口指针"><a href="#JNIEnv接口指针" class="headerlink" title="JNIEnv接口指针"></a>JNIEnv接口指针</h4><p>本地代码通过JNIEnv接口指针里暴露的方法来使用虚拟机的功能。</p><p>JNIEnv是一个指向本地线程数据的接口指针，这个指针里面包含了一个指向函数表的指针。每一个接口函数在这表中都有一个 预定义的偏移位置。JNIEnv很像一个C++虚函数表或者Microsoft COM接口。</p><p><img src="https://s2.loli.net/2024/12/19/ZtgFubyJGQTnYMv.png" alt="jnienv"></p><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>像int、char等这样的基本数据类型，在本地代码和JVM之间进行复制传递，而对象是引用传递的。每一个引用都包含一个指向JVM 中相应的对象的指针，但本地代码不能直接使用这个指针，必须通过引用来间接使用。<br>比起传递直接指针来说，传递引用可以让VM更灵活地管理对象。</p><h5 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h5><p>JNI可以为本地代码创建两种对象引用：局部引用和全局引用。局部引用的有效期是本地方法的调用期间，调用完成后，局部引用 会被JVM自动铲除。而全局引用，除非显示释放它，否则将一直存在。<br>JVM中的对象作为参数传递给本地方法时，用的是局部引用。大部分的JNI函数返回局部引用。JNI允许程序员从局部引用创建一个 全局引用。接受对象作为参数的JNI函数既支持全局引用也支持局部引用。本地方法执行完毕后，向JVM返回结果时，它可能向JVM 返回局部引用，也可能返回全局引用。<br>局部引用只在创建它的线程内部有效。本地代码不能跨线程传递和使用局部引用。<br>JNI中的NULL引用指向JVM中的null对象。对一个全局引用或者局部引用来说，只要它的值不是NULL，它就不会指向一个null对象。</p><h5 id="局部引用的实现"><a href="#局部引用的实现" class="headerlink" title="局部引用的实现"></a>局部引用的实现</h5><p>一个对象从JVM传递给本地方法时，就把控制权移交了过去，JVM会为每一个对象的传递创建一条记录，一条记录就是一个本地代码 中的引用和JVM中的对象的一个映射。记录中的对象不会被GC回收。所有传递到本地代码中的对象和从JNI函数返回的对象都被自动 地添加到映射表中。当本地方法返回时，VM会删除这些映射，允许GC回收记录中的数据。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用所指向的对象允许JVM回收，当对象被回收以后，弱引用也会被清除。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/Delilah_java/article/details/119778422">一篇JVM详细图解，坚持看完！带你真正搞懂Java虚拟机！_jvm图解-CSDN博客</a></p><p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程_java jni-CSDN博客</a></p><p><a href="https://luori366.github.io/JNI_doc/jni_design_theory.html">JNI的作用与工作原理 | JNI_doc</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android系统启动流程</title>
    <link href="/2024/12/12/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/12/12/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="android整体架构图"><a href="#android整体架构图" class="headerlink" title="android整体架构图"></a>android整体架构图</h1><p><img src="https://s2.loli.net/2024/12/20/NiF83nBS4sItpYR.png" alt="android整体架构"></p><p>可以看出android系统是基于底层linux构建的。也正因如此，android系统启动的起点在linux启动后的用户空间的第一个进程init，进程号为1.当bootloader启动后，启动kernel，kernel启动完后，在用户空间启动init进程。</p><p>倘若再往上走就是linux启动过程，具体可自行百度linux启动流程。</p><ul><li><strong>1.引导加载程序（Bootloader）启动</strong>： 当设备上电或者重启时，首先会由引导加载程序负责启动。引导加载程序通常存储在设备的固件中，它的主要任务是初始化硬件，并加载并启动操作系统内核。引导加载程序会首先运行自身的初始化代码，然后加载操作系统内核到内存中。</li><li><strong>2.内核加载</strong>： 引导加载程序会根据预定义的配置从设备存储中加载操作系统内核。在Android设备中，通常使用的是Linux内核。引导加载程序将内核加载到内存中的指定位置。</li><li><strong>3.内核初始化</strong>： 一旦内核加载到内存中，引导加载程序会将控制权转交给内核。内核开始执行初始化过程，包括对硬件进行初始化、建立虚拟文件系统、创建进程和线程等。</li><li><strong>4.启动 init 进程</strong>： 内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。</li></ul><h1 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h1><p><img src="https://s2.loli.net/2024/10/08/3YcVQto2GbqMzCN.png" alt="Android系统启动流程"></p><p>根据不同的入参，响应init不同阶段、处理不同业务逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> ueventd_main(argc, argv);<br>    &#125;<br>    <span class="hljs-comment">////watchdogd俗称看门狗，用于系统出问题时重启系统</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;watchdogd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> watchdogd_main(argc, argv);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;subcontext&quot;</span>)) &#123;<br>        InitKernelLogging(argv);<br>        <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>        <span class="hljs-keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);<br>    &#125;<br>    <span class="hljs-comment">//如果设置了 REBOOT_BOOTLOADER_ON_PANIC，则安装重启信号处理器，确保在系统崩溃时能够重启进入 bootloader 模式。</span><br>    <span class="hljs-keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>        InstallRebootSignalHandlers();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ol><li>挂载文件系统并创建目录</li><li>初始化日志输出、挂载分区设备</li><li>启用SELinux安全策略</li><li>开始第二阶段前的准备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    ...<br>    <span class="hljs-type">bool</span> is_first_stage = (getenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>) == nullptr);<br>    <span class="hljs-comment">// 在第一阶段，初始化基本的文件系统，并创建和挂载必要的系统目录</span><br>    <span class="hljs-keyword">if</span> (is_first_stage) &#123;<br>        boot_clock::time_point start_time = boot_clock::now();<br>        umask(<span class="hljs-number">0</span>);<br>        clearenv();<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-number">0755</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/socket&quot;</span>, <span class="hljs-number">0755</span>);<br>        mount(<span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_STR(x) __STRING(x)</span><br>        mount(<span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));<br>        chmod(<span class="hljs-string">&quot;/proc/cmdline&quot;</span>, <span class="hljs-number">0440</span>);<br>        <span class="hljs-type">gid_t</span> groups[] = &#123; AID_READPROC &#125;;<br>        setgroups(arraysize(groups), groups);<br>        mount(<span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-string">&quot;/sys&quot;</span>, <span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mount(<span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-string">&quot;/sys/fs/selinux&quot;</span>, <span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mknod(<span class="hljs-string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="hljs-number">0600</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">constexpr</span> <span class="hljs-params">(WORLD_WRITABLE_KMSG)</span> &#123;<br>            mknod(<span class="hljs-string">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class="hljs-number">0622</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        &#125;<br>        <span class="hljs-comment">//创建 /dev/kmsg、/dev/random、/dev/urandom 等设备节点，用于日志和随机数生成。</span><br>        mknod(<span class="hljs-string">&quot;/dev/random&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br>        mknod(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>));<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>        mkdir(<span class="hljs-string">&quot;/mnt/vendor&quot;</span>, <span class="hljs-number">0755</span>);<br>        <span class="hljs-comment">//初始化log系统并打印</span><br>        InitKernelLogging(argv);<br>        ......<br>        <span class="hljs-comment">//初始化Android的安全框架Android Verified Boot</span><br>        SetInitAvbVersionInRecovery();<br>        global_seccomp();<br>        ...<br>        <span class="hljs-comment">// Set up SELinux, loading the SELinux policy.</span><br>        <span class="hljs-comment">//为第二阶段启动加载安全策略(安全策略：一个Linux内核模块和安全架构，旨在提供更细粒度的访问控制)</span><br>        SelinuxSetupKernelLogging();<br>        SelinuxInitialize();<br>        ...<br>        <span class="hljs-comment">//设置第二阶段开关</span><br>        setenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">static</span> constexpr <span class="hljs-type">uint32_t</span> kNanosecondsPerMillisecond = <span class="hljs-number">1e6</span>;<br>        <span class="hljs-type">uint64_t</span> start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;<br><br><span class="hljs-comment">//设置环境变量 INIT_SECOND_STAGE 并重新执行 init 进程，进入第二阶段。</span><br>        setenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>, <span class="hljs-built_in">std</span>::to_string(start_ms).c_str(), <span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span>* path = argv[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span>* args[] = &#123; path, nullptr &#125;;<br>        execv(path, args);<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;) failed&quot;</span>;<br>    &#125;<br>              <br> &#125;<br>   <br></code></pre></td></tr></table></figure><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ol><li>初始化属性系统</li><li>执行SELinux第二阶段并恢复一些文件安全上下文</li><li>新建epoll并初始化子进程终止信号处理函数</li><li>设置其他系统属性并开启属性服务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//初始化属性系统</span><br>   <span class="hljs-comment">//继续初始化日志、属性系统和内核命令行参数，并准备系统启动。</span><br>    InitKernelLogging(argv);<br>    ....<br>    <span class="hljs-comment">//property系统用于管理系统属性</span><br>    process_kernel_dt();<br>    process_kernel_cmdline();<br><br>    export_kernel_boot_props();<br><br>    property_set(<span class="hljs-string">&quot;ro.boottime.init&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>));<br>    property_set(<span class="hljs-string">&quot;ro.boottime.init.selinux&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>));<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* avb_version = getenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br>    <span class="hljs-keyword">if</span> (avb_version) property_set(<span class="hljs-string">&quot;ro.boot.avb_version&quot;</span>, avb_version);<br>    <span class="hljs-comment">// Clean up our environment.</span><br>    unsetenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br><br>    <span class="hljs-comment">//加载 SELinux 策略</span><br>    SelinuxSetupKernelLogging();<br>    SelabelInitialize();<br>    SelinuxRestoreContext();<br>    <span class="hljs-comment">//启动 epoll 等待系统事件(设置 epoll 文件描述符，用于监听系统事件，并启动属性服务和信号处理。)</span><br>    epoll_fd = epoll_create1(EPOLL_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (epoll_fd == <span class="hljs-number">-1</span>) &#123;<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;epoll_create1 failed&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//来初始化信号处理过程</span><br>    sigchld_handler_init();<br><br>    <span class="hljs-keyword">if</span> (!IsRebootCapable()) &#123;<br>    <br>        InstallSigtermHandler();<br>    &#125;<br>    <span class="hljs-comment">//设置其他系统属性并开启属性服务</span><br>    property_load_boot_defaults();<br>    export_oem_lock_status();<br>    start_property_service();<br>    set_usb_controller();<br>    ...<br>    <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>    Action::set_function_map(&amp;function_map);<br><br>   <span class="hljs-comment">// Android 中负责管理子上下文</span><br>    subcontexts = InitializeSubcontexts();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><ol><li>通过init.rc机制，读取配置文件，来启动不同的进程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>    <span class="hljs-comment">//通常负责管理系统中的各种动作或命令, 解析init.rc等文件，建立rc文件的action 、service，启动其他进程</span><br>    <span class="hljs-comment">//ActionManager 和 ServiceList 管理系统中的命令和服务，初始化并触发系统的启动事件和动作。</span><br>    ActionManager&amp; am = ActionManager::GetInstance();<br><span class="hljs-comment">//负责管理系统中所有的服务</span><br>    ServiceList&amp; sm = ServiceList::GetInstance();<br><br>    <span class="hljs-comment">//加载脚本文件命令</span><br>    LoadBootScripts(am, sm);<br><br>    ...<br><br>   <span class="hljs-comment">//进入主循环，使用 epoll_wait 监听系统事件，并执行相应的系统命令和服务操作。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// By default, sleep until something happens.</span><br>        <span class="hljs-type">int</span> epoll_timeout_ms = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;<br>            do_shutdown = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;<br>                shutting_down = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            am.ExecuteOneCommand();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            <span class="hljs-keyword">if</span> (!shutting_down) &#123;<br>                <span class="hljs-keyword">auto</span> next_process_restart_time = RestartProcesses();<br>                <span class="hljs-keyword">if</span> (next_process_restart_time) &#123;<br>                    epoll_timeout_ms = <span class="hljs-built_in">std</span>::chrono::<span class="hljs-built_in">ceil</span>&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(<br>                                           *next_process_restart_time - boot_clock::now())<br>                                           .count();<br>                    <span class="hljs-keyword">if</span> (epoll_timeout_ms &lt; <span class="hljs-number">0</span>) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        epoll_event ev;<br>        <span class="hljs-type">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="hljs-number">1</span>, epoll_timeout_ms));<br>        <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">-1</span>) &#123;<br>            PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;epoll_wait failed&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">1</span>) &#123;<br>            ((<span class="hljs-type">void</span> (*)()) ev.data.ptr)();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="init-rc脚本"><a href="#init-rc脚本" class="headerlink" title="init.rc脚本"></a><code>init.rc</code>脚本</h3><p><img src="https://s2.loli.net/2024/12/20/kTpboDfICxgNz1Q.png" alt="image-20241008120230933"></p><p><strong>service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin –zygote –start-system-server</strong>:</p><ul><li><strong>service zygote</strong>: 定义一个名为zygote的服务</li><li><strong>&#x2F;system&#x2F;bin&#x2F;app_process</strong>：这是启动Zygote进程的可执行文件，64位系统为<code>app_process64</code>。</li><li><strong>-Xzygote</strong>：标志表明这是一个Zygote进程启动的特殊模式。</li><li><strong>&#x2F;system&#x2F;bin</strong>：指定进程的工作目录。</li><li><strong>–zygote</strong>：告诉app_process以Zygote模式启动。</li><li><strong>–start-system-server</strong>：Zygote启动时还要启动System Server进程，这是Android系统中管理关键系统服务的核心进程。</li></ul><p><strong>class main</strong>:</p><ul><li>将Zygote服务归类为main类别。</li><li>Android系统在启动过程中会启动所有“main”类别的服务。</li></ul><p><strong>socket zygote stream 660 root system</strong>:<br>创建了一个名为zygote的UNIX域Socket套接字，用于其他进程与Zygote进程通信。</p><p><strong>onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;android_power&#x2F;request_state”文件的内容设置为“wake”，以唤醒设备。</p><p><strong>onrestart write &#x2F;sys&#x2F;power&#x2F;state on</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;power&#x2F;state”文件的内容设置为 “on”，以打开电源。</p><p><strong>onrestart restart media</strong>：<br>当zygote服务重启时，系统应该重启媒体服务（如音频、视频等），以恢复媒体功能。</p><p><strong>onrestart restart netd</strong>：<br>当zygote服务重启时，系统应该重启网络守护进程（netd），以恢复网络功能。</p><h1 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h1><p>在上一节，可以看到在启动 app_process中，启动zygote了进程，并同时启动了诸如audioserver、cameraserver、media等服务。</p><h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a><code>main</code>方法</h2><p><code>app_process</code>主入口点是<code>main</code>方法，它是整个进程启动流程的起点。</p><p>通过解析rc文件参数，启动ZygoteInit。</p><p><img src="https://s2.loli.net/2024/10/08/md2z6wo5qugXxY8.png" alt="image-20241008194103840"></p><h2 id="AppRuntime类-AndroidRuntime"><a href="#AppRuntime类-AndroidRuntime" class="headerlink" title="AppRuntime类(AndroidRuntime)"></a><code>AppRuntime</code>类(AndroidRuntime)</h2><p><strong>AppRuntime</strong>继承自<strong>AndroidRuntime</strong>(ART)，是Android中的一个关键类，负责管理和启动 Android 应用程序或系统服务的 Java 虚拟机 (JVM)。</p><p><img src="https://s2.loli.net/2024/10/08/htVWoFqQnzSuYyL.png" alt="image-20241008194008645"></p><p><img src="https://s2.loli.net/2024/10/08/3pqmgrcHeWozPQx.png" alt="image-20241008194040488"></p><p><code>app_process</code>的main方法调用了<code>AppRuntime</code>的start方法，也就是<code>AppRuntime</code>的父类<code>AndroidRuntime</code>的start方法</p><p><img src="https://s2.loli.net/2024/10/08/dZTmxI2Yy8kz1tM.png" alt="image-20241008194334607"></p><p>通过JNI调用ZygoteInit.main()</p><p><img src="https://s2.loli.net/2024/10/08/IzisVvtlSMXnOaE.png" alt="image-20241008194356872"></p><h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>在<code>AndroidRuntime</code>的<strong>start</strong>方法，通过JNI调用ZygoteInit.main()，系统第一次进入Java层(ZygoteInit是系统运行的第一个Java类)，当前线程也正式成为Java虚拟机（JVM）的主线程。</p><p><img src="https://s2.loli.net/2024/10/08/RgeblPvEmN8SAQ3.png" alt="image-20241008194450720"></p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241008194506579.png" alt="image-20241008194506579"></p><p><img src="https://s2.loli.net/2024/10/08/JMYWoLXnjBU49V1.png" alt="image-20241008194607975"></p><p><img src="https://s2.loli.net/2024/10/08/pc7S2BMIEv4QqCW.png" alt="image-20241008194639231"></p><p>整体流程图：</p><p><img src="https://s2.loli.net/2024/10/08/WKLGhCXSPNOwpg4.png" alt="753d2faffdc5f60b5e5d98fd108d4421"></p><h1 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a>SystemServer进程</h1><p>Android系统在启动的时候,在启动两个重要的进程，一个是Zygote进程，另一个是由zygote进程fork出来的system_server进程。SystemSever负责启动系统的各项服务，Android系统中Java世界的核心Service都在这里启动。比如：</p><table><thead><tr><th>服务名称</th><th>功能说明</th></tr></thead><tbody><tr><td>Activity Manager Service (AMS)</td><td>管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等</td></tr><tr><td>Package Manager Service (PMS)</td><td>管理应用包的安装、卸载、更新、权限分配等</td></tr><tr><td>System Config Service</td><td>管理系统配置和资源</td></tr><tr><td>Power Manager Service</td><td>管理设备的电源状态和电源策略，如休眠、唤醒等</td></tr><tr><td>Display Manager Service</td><td>管理显示设备，如屏幕亮度、显示模式等</td></tr><tr><td>User Manager Service</td><td>管理用户账户和用户信息</td></tr><tr><td>Battery Service</td><td>监控和管理电池状态和电池使用情况</td></tr><tr><td>Vibrator Service</td><td>控制设备的振动功能</td></tr><tr><td>Sensor Service</td><td>管理设备的传感器，如加速度计、陀螺仪等</td></tr><tr><td>Window Manager Service (WMS)</td><td>管理窗口和显示内容，包括窗口的创建、删除、布局等</td></tr><tr><td>Input Manager Service</td><td>管理输入设备，如触摸屏、键盘等</td></tr><tr><td>Alarm Manager Service</td><td>提供定时任务调度功能</td></tr><tr><td>Connectivity Service</td><td>管理网络连接，如 Wi-Fi、移动数据等</td></tr><tr><td>Network Management Service</td><td>管理网络接口和网络连接</td></tr><tr><td>Telephony Registry</td><td>管理电话和短信服务</td></tr><tr><td>Input Method Manager Service (IMMS)</td><td>管理输入法框架</td></tr><tr><td>Accessibility Manager Service</td><td>管理无障碍服务，为有特殊需要的用户提供辅助功能</td></tr><tr><td>Mount Service</td><td>管理存储设备的挂载和卸载</td></tr><tr><td>Location Manager Service</td><td>管理位置服务，如 GPS 和网络定位</td></tr><tr><td>Search Manager Service</td><td>管理系统搜索功能</td></tr><tr><td>Clipboard Service</td><td>管理剪贴板功能</td></tr><tr><td>DevicePolicy Manager Service</td><td>管理设备的安全策略和企业管理功能</td></tr><tr><td>Status Bar Service</td><td>管理状态栏显示和操作</td></tr><tr><td>Wallpaper Manager Service</td><td>管理壁纸设置和操作</td></tr><tr><td>Media Router Service</td><td>管理媒体设备路由</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/10/08/eztnSVYgbl8LAmj.png" alt="image-20241008200351668"></p><p><img src="https://s2.loli.net/2024/10/08/G39r2btcljHy5mv.png" alt="image-20241008200413406"></p><p>整体流程如下：</p><p><img src="https://s2.loli.net/2024/10/08/Xe7iEBZK5OhstyR.png" alt="0776be314b69defe63cbf793f867f1b9"></p><h1 id="Home进程"><a href="#Home进程" class="headerlink" title="Home进程"></a>Home进程</h1><p>一般情况下，Android原生的软体会包含两个home进程，一个是Settings进程的Fallbackhome，一个是Launcher进程。</p><h2 id="Launcher进程启动"><a href="#Launcher进程启动" class="headerlink" title="Launcher进程启动"></a>Launcher进程启动</h2><p>​    FallbackHome是系统由未解密到解密过程的一个过度界面，只要用户把系统解锁过一次后，FallbackHome收到解锁广播就会退出，而WMS检测到当前Acitivity栈是空的，进而启动真正的Launcher。由于FallbackHome没有界面，所以可能会出现一个问题，home进程切换时会出现空白界面，接下来才是显示Launcher的一个图标界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@packages</span>\apps\Settings\src\com\android\settings\FallbackHome.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    ...<br>    registerReceiver(mReceiver, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(Intent.ACTION_USER_UNLOCKED));<span class="hljs-comment">//注册ACTION_USER_UNLOCKED广播</span><br>    maybeFinish();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">BroadcastReceiver</span> <span class="hljs-variable">mReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastReceiver</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        maybeFinish();<span class="hljs-comment">//接收ACTION_USER_UNLOCKED广播</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybeFinish</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (getSystemService(UserManager.class).isUserUnlocked()) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_MAIN)<br>                .addCategory(Intent.CATEGORY_HOME);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ResolveInfo</span> <span class="hljs-variable">homeInfo</span> <span class="hljs-operator">=</span> getPackageManager().resolveActivity(homeIntent, <span class="hljs-number">0</span>);<span class="hljs-comment">//查询home包名信息，此处一般是返回Launcher的信息</span><br>        <span class="hljs-keyword">if</span> (Objects.equals(getPackageName(), homeInfo.activityInfo.packageName)) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked but no home; let&#x27;s hope someone enables one soon?&quot;</span>);<br>            mHandler.sendEmptyMessageDelayed(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<span class="hljs-comment">//间隔500ms轮询</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked and real home found; let&#x27;s go!&quot;</span>);<br>            getSystemService(PowerManager.class).userActivity(<br>                    SystemClock.uptimeMillis(), <span class="hljs-literal">false</span>);<br>            finish();<span class="hljs-comment">//结束当前Activity，启动Launcher应用</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上一节systemserver中注意到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动ActivityManagerService</span><br>    mActivityManagerService = mSystemServiceManager.startService(<br>            ActivityManagerService.Lifecycle.class).getService();<br>    ...<br>    <span class="hljs-comment">// 启动Launcher</span><br>    mActivityManagerService.systemReady(...)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在AMS中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">systemReady</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable goingCallback, TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 在所有显示器上启动Launcher</span><br>    mAtmInternal.startHomeOnAllDisplays(currentUserId, <span class="hljs-string">&quot;systemReady&quot;</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此行代码最终会调用到<code>RootWindowContainer.java</code>的<code>startHomeOnAllDisplays</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnAllDisplays</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">homeStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getChildCount() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">displayId</span> <span class="hljs-operator">=</span> getChildAt(i).mDisplayId;<br>        <span class="hljs-comment">// 在每一个显示器上启动桌面程序</span><br>        homeStarted |= startHomeOnDisplay(userId, reason, displayId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> homeStarted;<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId)</span> &#123;<br>    <span class="hljs-keyword">return</span> startHomeOnDisplay(userId, reason, displayId, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId, <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 调用startHomeOnTaskDisplayArea</span><br>    <span class="hljs-keyword">return</span> display.reduceOnAllTaskDisplayAreas((taskDisplayArea, result) -&gt;<br>                    result | startHomeOnTaskDisplayArea(userId, reason, taskDisplayArea,<br>                            allowInstrumenting, fromHomeKey),<span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnTaskDisplayArea</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, TaskDisplayArea taskDisplayArea,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> mService.getHomeIntent();<br>    mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,<br>            taskDisplayArea);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>最终通过Intent和startHomeActivity方法启动了桌面程序</p><h2 id="FallbackHome进程启动"><a href="#FallbackHome进程启动" class="headerlink" title="FallbackHome进程启动"></a>FallbackHome进程启动</h2><h3 id="（1）-启动home进程"><a href="#（1）-启动home进程" class="headerlink" title="（1） 启动home进程"></a><strong>（1）</strong> 启动home进程</h3><p>   刚开机时，SystemSever进程会启动WMS服务，如果WMS未检测到Activity栈有任务时，会启动一个默认的home进程，此进程即FallbackHome。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\wm\RootWindowContainer.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startHomeOnEmptyDisplays</span><span class="hljs-params">(String reason)</span> &#123;<br>    forAllTaskDisplayAreas(taskDisplayArea -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (taskDisplayArea.topRunningActivity() == <span class="hljs-literal">null</span>) &#123;<br>            startHomeOnTaskDisplayArea(mCurrentUser, reason, taskDisplayArea,<br>                    <span class="hljs-literal">false</span> <span class="hljs-comment">/* allowInstrumenting */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* fromHomeKey */</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）-ACTION-USER-UNLOCKED广播发送"><a href="#（2）-ACTION-USER-UNLOCKED广播发送" class="headerlink" title="（2） ACTION_USER_UNLOCKED广播发送"></a><strong>（2）</strong> ACTION_USER_UNLOCKED广播发送</h3><p>​    系统解锁时会发送该广播，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\am\UserController.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>        <span class="hljs-comment">// Dispatch unlocked to external apps</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">unlockedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_UNLOCKED);<br>        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>        unlockedIntent.addFlags(<br>                Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);<br>        mInjector.broadcastIntent(unlockedIntent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,<br>                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID,<br>                Binder.getCallingUid(), Binder.getCallingPid(), userId);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上一张完整流程图：</p><p><img src="https://s2.loli.net/2024/10/08/mpCSY3h7r8szdJ2.png" alt="android系统启动流程"></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/anywherego/p/18221943">Android启动过程-万字长文(Android14) - 柳云居士 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/IT_xiao_bai0516/article/details/121566564?spm=1001.2014.3001.5502">源码详解Android 9.0(P) 系统启动流程之SystemServer_android9 systemserver启动-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zhiqinlin/p/18001113#44-init%E8%BF%9B%E7%A8%8B">Android 开机流程介绍 - 林奋斗同学 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Andorid源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外存管理</title>
    <link href="/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在提供计算机持久化的知识框架体系，对于一些细节内容并没有过多介绍。</p></blockquote><h1 id="内存的不足"><a href="#内存的不足" class="headerlink" title="内存的不足"></a>内存的不足</h1><h2 id="内存管理管理方式："><a href="#内存管理管理方式：" class="headerlink" title="内存管理管理方式："></a>内存管理管理方式：</h2><p>在上一篇文章中：<a href="https://wangxiaobai08.github.io/2024/12/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理 - The Peak Tower</a>，提到了内存管理：<strong>所有的应用程序都需要<code>存储</code>和<code>检索</code>信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。</strong></p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>然而，存储容量受<code>虚拟地址空间</code>大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。</p><p>第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。</p><p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。</p><h1 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>通过对内存不足的分析，对于长久存储的信息我们有三个基本需求：</p><ul><li><strong>必须要有可能存储的大量的信息</strong></li><li><strong>信息必须能够在进程终止时保留</strong></li><li><strong>必须能够使多个进程同时访问有关信息</strong></li></ul><p>因此可以引入<strong>持久化存储</strong>，例如硬盘、固态硬盘（SSD）等非易失性存储设备。</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>对于新引入的设备，计算机如何将I&#x2F;O集成进系统中？其中的一般机制是什么？如何让它们变得高效？</p><h1 id="IO接口与设备"><a href="#IO接口与设备" class="headerlink" title="IO接口与设备"></a>IO接口与设备</h1><p>在开始下面的内容前，有必要先简单了解什么是IO接口与设备？</p><p><strong>IO（Input&#x2F;Output）设备</strong>是将数据输入计算机或接收计算机输出的设备。</p><p>鼠标、键盘都属于IO设备，它们所连接到的电脑的接口叫做IO接口（或称为IO控制器）。</p><p>IO接口为了能够充当设备与计算机的桥梁，它需要多个寄存器：</p><ul><li><strong>数据寄存器</strong>：保存设备的输出或计算机的输出。</li><li>**<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8&zhida_source=entity">控制寄存器</a>**：计算机需要控制设备做出操作，要做的操作存在这里。</li><li><strong>状态寄存器</strong>：设备完成操作后，需要告诉计算机当前的状态。</li></ul><p>这些寄存器对于计算机而言都是<strong>IO端口</strong>——数据端口、状态端口、控制端口。一个IO接口可以对应多个设备，每个设备可以有自己的一组数据、控制、状态寄存器，这样计算机就可以通过控制不同组的寄存器，来控制不同的设备。</p><p><img src="https://s2.loli.net/2024/12/21/VK4UMSjxOYlFhpt.png" alt="IO接口"></p><p>计算机通过一条系统总线（包含数据、地址、控制信号线）与IO接口连接，CPU、主存、IO接口都连在上面。cpu可以通过总线直接控制IO接口，也可以让主存与IO接口间传递数据。</p><p><img src="https://s2.loli.net/2024/12/21/K9PfI4X1GlNTADR.png" alt="系统总线"></p><p>CPU有两种方式获得数据：</p><ul><li><strong><a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2&zhida_source=entity">程序查询</a>方式</strong>：CPU会不断询问键盘的状态寄存器输入是否完成，如果检测到了完成，就会把数据寄存器里的数据拿到主存。</li><li><strong>程序中断方式</strong>：CPU不用询问，IO接口根据状态寄存器来选择是否需要向CPU发送一个中断信号，CPU收到信号会过来收取数据。</li></ul><p>程序查询方式会导致cpu只能一直等着键盘输入，不能做其他事；<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=2&q=%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F&zhida_source=entity">程序中断方式</a>可以允许CPU先做其他事，等输入完成后过来取到主存。</p><blockquote><p><strong>中断</strong>是计算机中比较重要的内容，在这里与主体内容关联不大，不多赘述，可自自行百度</p></blockquote><p>注意有一种特殊的IO接口——<strong>DMA接口</strong>，它可以用DMA总线与主存直接相连，只要CPU告诉DMA接口要把数据存在主存中的哪个地址，DMA接口就会根据地址把数据放进主存。</p><img src="https://s2.loli.net/2024/12/21/8VoPR9gelTqMHcu.png" alt="v2-9b1553f891f5172e314eafd35fca0677_1440w" style="zoom:50%;" /><p>对于DMA接口而言，CPU还需要告诉它主存地址，如果有多个DMA接口，CPU依旧会很忙碌。为了进一步解放CPU，<strong>通道</strong>可以接替CPU做一些基础操作。</p><img src="https://s2.loli.net/2024/12/21/PVHza71unBCiIJ8.png" alt="v2-5054d9430842c23df9b840bddb745f23_1440w" style="zoom:50%;" /><p>它就像一个低级CPU，有自己的指令系统——<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E9%80%9A%E9%81%93%E6%8C%87%E4%BB%A4&zhida_source=entity">通道指令</a>，能够执行一些有限的操作。当它接受到CPU发出的<strong>IO指令</strong>后，可以按照要求启动IO设备，或者执行通道指令——就像是CPU的小弟。</p><p>IO指令从逻辑上分为三个字段：</p><ul><li>操作码：可以被用作和其他指令的区分，让CPU知道这是一条IO指令。</li><li>命令码：代表了设备要做的具体操作。</li><li>设备码：可以指定对某个设备进行操作，用作区分设备。</li></ul><p>不同设备的IO指令各不相同，同样是设置鼠标侧键、灯光或是灵敏度，不同的品牌都有不同的IO指令。这也是为什么在插上鼠标键盘显卡之类的部件时，如果你想更好的使用它就需要安装驱动的原因。</p><p>键盘的每一次敲击都在向计算机发出中断信号，一般情况下计算机会暂停手上的工作，先处理键盘的输入数据，之后再回到自己之前的工作。</p><h1 id="I-O集成"><a href="#I-O集成" class="headerlink" title="I&#x2F;O集成"></a>I&#x2F;O集成</h1><p>先来观察计算机体系架构：</p><img src="https://s2.loli.net/2024/12/21/eoLBjYpE2VUkHKA.png" alt="计算机架构" style="zoom:25%;" /><p>CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能I&#x2F;O设备通过常规的I&#x2F;O总线（I&#x2F;O bus）连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p><p>接着续上<em>持久化存储</em>中<strong>计算机如何将I&#x2F;O集成进系统中？</strong>的问题，继续探讨：</p><p>这里要解决的第一个问题便是：</p><h2 id="如何与设备通信"><a href="#如何与设备通信" class="headerlink" title="如何与设备通信?"></a>如何与设备通信?</h2><p><strong>I&#x2F;O指令方式</strong>：通过指令（如 <code>in</code> 和 <code>out</code>）与设备通信，指定寄存器和设备端口，通常为特权指令，仅操作系统可使用，确保安全性。</p><p><strong>内存映射I&#x2F;O</strong>：设备寄存器映射为内存地址，操作系统通过读写这些地址与设备交互，硬件将访问操作转交给设备，而非物理内存。</p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p>每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用?比如：</p><table><thead><tr><th>设备类型</th><th>接口类型</th><th>特殊要求</th></tr></thead><tbody><tr><td>硬盘</td><td>块设备，协议如 SATA、NVMe</td><td>批量传输数据，支持异步操作，命令格式多样</td></tr><tr><td>显示器</td><td>输出设备，通过显卡接口或协议驱动</td><td>实时更新数据，要求特定的视频信号、刷新率等支持</td></tr></tbody></table><p><strong>本质</strong>：不同设备有不同的寄存器布局、通信协议和操作流程，这些具体接口定义了设备的使用方式，需要操作系统进行抽象和标准化以实现通用性。</p><p>这个问题抽象，在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所有设备交互的细节都封装在其中。</p><p><strong>设备驱动程序</strong>（Device Driver）是操作系统的一部分，负责在操作系统与硬件设备之间建立连接，使操作系统能够控制和管理设备，而无需直接处理设备的底层硬件细节。<br><strong>核心功能</strong>：</p><ul><li><strong>抽象化设备接口</strong>：隐藏硬件的具体实现细节，对操作系统提供统一的访问接口。</li><li><strong>管理硬件资源</strong>：与设备通信，完成初始化、数据传输、资源分配等操作。</li><li><strong>兼容性与扩展性</strong>：通过加载不同的驱动程序，操作系统能够支持多种硬件设备，而无需修改自身核心。</li></ul><p>比如：</p><p>假设有一台打印机，用户希望通过电脑将文档打印出来。不同厂商、型号的打印机可能有完全不同的通信协议和功能设置。那么，操作系统如何支持这些打印机呢？这就是设备驱动程序的作用。</p><p><strong>具体过程</strong>：</p><p><strong>设备驱动的作用</strong>：<br>打印机驱动程序是一个中间层，负责将操作系统的打印请求（如 “打印这份 PDF 文档”）翻译成打印机能理解的具体命令。</p><p><strong>实现过程</strong>：</p><p>用户在电脑上点击“打印”，操作系统将打印内容通过<strong>统一的打印接口</strong>（如 Windows 的打印子系统）发送给打印机驱动程序。</p><p>驱动程序会根据打印机的具体型号和协议，生成打印机可以理解的命令，如：</p><ul><li>将文字和图片数据转换为打印机支持的格式（如 PCL、PostScript 等）。</li><li>设置具体的打印参数（分辨率、纸张类型等）。</li></ul><p>驱动程序与打印机通信，发送这些指令并控制打印过程。</p><p><strong>操作系统的通用性</strong>：</p><ul><li>操作系统本身只需要支持一个通用的打印接口。</li><li>针对不同型号的打印机，只需加载相应的驱动程序。</li></ul><img src="https://s2.loli.net/2024/12/21/C8mHAvK1BF2kaTz.png" alt="驱动程序" style="zoom:50%;" /><p>注意：<strong>设备驱动程序必须实现操作系统定义的接口</strong>，以便操作系统能够通过统一的方式与设备交互，而不关心具体设备的实现细节。常见的比如：<strong>读写操作接口</strong>：<br>驱动程序需要实现设备读写的标准接口。例如：</p><ul><li>在 Linux 中，字符设备驱动实现 <code>read()</code> 和 <code>write()</code> 方法。</li><li>在 Windows 中，驱动程序需实现 I&#x2F;O 请求包（IRP）的处理函数，响应 <code>IRP_MJ_READ</code> 和 <code>IRP_MJ_WRITE</code>。</li></ul><p><strong>这里特别关注的是存储设备，比如磁盘驱动器原理和一系列调度算法</strong>，这里不多介绍，自行百度</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>在解决了与设备通信与驱动后，在诸如存储设备（如硬盘、SSD、USB 等），我们不得不面临如何像管理内存那样<strong>组织、存储、管理和检索数据</strong>。就拿磁盘为例：</p><img src="https://s2.loli.net/2024/12/21/zKfeyVMhHrZuRUD.png" alt="磁盘" style="zoom:50%;" /><p>如何对磁盘上的文件进行组织管理？—<strong>文件系统</strong>应运而生：它为存储设备（上的数据提供了一种结构化的方式，使用户和程序能够以文件和目录的形式高效地访问和管理数据。类比内存可以把每个文件都看作一个独立的地址空间</p><table><thead><tr><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>将物理存储抽象为逻辑结构</strong></td><td>- <strong>物理存储的复杂性</strong>：硬盘以扇区（如 512 字节）为单位存储数据，直接操作扇区会很不便。 - <strong>文件系统的抽象</strong>：通过“文件”和“目录”来组织和管理数据，屏蔽底层物理细节。</td></tr><tr><td><strong>数据组织和查找</strong></td><td>- <strong>无文件系统的情况</strong>：数据可能存储在任意位置，难以高效查找。 - <strong>文件系统的作用</strong>：通过目录结构（如树形结构）和路径组织文件，便于管理和检索数据。</td></tr><tr><td><strong>数据持久性</strong></td><td>- 文件系统确保数据在存储设备断电或系统重启后仍然可用，实现数据长期保存。</td></tr><tr><td><strong>支持多用户和并发访问</strong></td><td>- 通过权限管理，确保用户只能访问自己授权的数据。 - 处理多个进程同时访问同一文件的冲突，保证数据一致性。</td></tr><tr><td><strong>提高存储效率</strong></td><td>- 通过优化存储分配（如簇、块）和读取方式（如顺序读写、索引）提升性能。 - 提供删除、压缩等功能回收或节省存储空间。</td></tr></tbody></table><blockquote><p>接下来的问题便是：如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？</p></blockquote><h2 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h2><blockquote><p>第一个方面是文件系统的数据结构（data structure）。换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？</p><p>文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</p></blockquote><h3 id="文件系统的数据结构"><a href="#文件系统的数据结构" class="headerlink" title="文件系统的数据结构"></a>文件系统的数据结构</h3><p>这里以VSFS文件系统为例：</p><p>1.将磁盘分成块（block）。简单的文件系统只使用一种块大小，这里正是这样做的。我们选择常用的4KB。因此，对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。假设我们有一个非常小的磁盘，只有64块：</p><img src="https://s2.loli.net/2024/12/21/ljZu613kvKyEf8p.png" alt="1" style="zoom:50%;" /><blockquote><p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p><ul><li>连续空间存放方式</li><li>非连续空间存放方式</li></ul><p>具体可参考：<a href="https://blog.csdn.net/qq_34827674/article/details/107992414">一口气搞懂「文件系统」，就靠这 25 张图了-CSDN博客</a></p></blockquote><p>2.文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为inode的结构</p><img src="https://s2.loli.net/2024/12/21/zF2t6Nip9x7BdOJ.png" alt="2" style="zoom:50%;" /><blockquote><p>文件的存储，注意：多级索引，为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。</p></blockquote><p>3.还需要某种方法来记录inode或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。</p><p><img src="https://s2.loli.net/2024/12/21/vSmqKkoWOUurcBz.png" alt="image-20241221143107283"></p><blockquote><p>空闲空间管理，自行百度</p></blockquote><p>4.还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。</p><p><img src="https://s2.loli.net/2024/12/21/HnSauTVIk4Le3bM.png" alt="image-20241221143143501"></p><p>因此，在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。</p><p>4.目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</p><p>目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定采用可变大小的名称）。</p><p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p><blockquote><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p></blockquote><img src="https://s2.loli.net/2024/12/21/CKL46SdPnqyW1xJ.png" alt="4" style="zoom:50%;" /><p>这里继续给出多种不同文件系统的差异：</p><table><thead><tr><th><strong>文件系统</strong></th><th><strong>数据存储方式</strong></th><th><strong>元数据管理方式</strong></th><th><strong>碎片管理机制</strong></th><th><strong>访问效率</strong></th><th><strong>数据保护与可靠性</strong></th><th><strong>特性支持</strong></th></tr></thead><tbody><tr><td><strong>FAT32</strong></td><td>使用链表（FAT 表）记录每个文件的块链表，结构简单，扩展性差</td><td>元数据存储在目录项中，简单，文件属性有限</td><td>没有特别的碎片管理，容易碎片化</td><td>随机访问效率差，大文件查找速度慢</td><td>无日志，不支持数据保护，崩溃时易丢失数据</td><td>支持小文件存储，适合嵌入式系统、U盘等小型存储设备</td></tr><tr><td><strong>NTFS</strong></td><td>使用 B+树结构索引文件数据位置，支持稀疏文件，优化存储空间</td><td>使用 MFT（主文件表）存储文件及其属性，支持复杂属性（如 ACL 权限）</td><td>通过延迟分配减少碎片，但仍需定期碎片整理</td><td>随机读写性能较高，适合桌面和企业级应用</td><td>支持元数据日志，能恢复文件系统结构，防止崩溃数据丢失</td><td>支持文件压缩、加密（EFS）、权限控制等，适合 Windows 系统</td></tr><tr><td><strong>ext4</strong></td><td>使用多级索引表（类似树结构）管理数据块，支持高效的文件存储</td><td>使用 inode 表存储文件和属性，支持文件权限、软硬链接等</td><td>通过延迟分配和预分配减少碎片化，效率较高</td><td>支持顺序和随机读写，适合小文件和大文件的访问</td><td>提供日志功能，确保系统崩溃后不丢失文件元数据</td><td>支持硬链接、软链接、日志功能，适用于 Linux 系统</td></tr><tr><td><strong>XFS</strong></td><td>延迟分配技术，优化数据块分配以减少碎片化</td><td>使用索引节点管理元数据，支持并发访问和高性能读写</td><td>延迟分配技术避免碎片化，适合大文件存储</td><td>对大文件和并发访问优化，适合高负载、高性能需求的环境</td><td>支持元数据日志，确保高可靠性，防止数据丢失</td><td>适合处理大文件和高负载，广泛用于高性能服务器环境</td></tr><tr><td><strong>APFS</strong></td><td>基于 CoW（Copy-on-Write）技术，避免直接覆盖数据，优化 SSD 性能</td><td>支持元数据快照，适合 SSD 存储的快速读写</td><td>通过 CoW 技术避免碎片化，适合 SSD</td><td>快速随机读写，优化 SSD 性能</td><td>基于快照和加密功能，能恢复系统状态，防止数据丢失</td><td>支持 SSD 优化、快照、文件加密、文件克隆等，适合 macOS 环境</td></tr><tr><td><strong>ZFS</strong></td><td>使用块指针树结构管理数据块，支持多级镜像和校验</td><td>使用分层的数据结构存储元数据，支持元数据校验</td><td>CoW 技术避免碎片化，支持数据去重和压缩</td><td>高效的数据读取和写入，适合大数据量顺序访问和高并发环境</td><td>提供端到端数据校验，支持自修复功能，适合大规模存储和企业级应用</td><td>支持数据去重、快照、镜像、动态块分配等功能，适合云存储、企业备份等</td></tr></tbody></table><ul><li><strong>数据存储方式</strong>：描述文件系统如何组织和存储数据。文件系统使用不同的数据结构（如链表、B+树、块指针树等）来管理数据。</li><li><strong>元数据管理方式</strong>：解释文件系统如何管理文件的元数据（如文件名、权限、时间戳、文件大小等）。</li><li><strong>碎片管理机制</strong>：描述文件系统如何处理碎片化问题。碎片化会降低文件访问效率，一些文件系统通过延迟分配、预分配或 CoW 技术来减少碎片化。</li><li><strong>访问效率</strong>：比较文件系统在数据访问中的效率，尤其是随机访问和大文件的读写性能。</li><li><strong>数据保护与可靠性</strong>：描述文件系统如何保护数据不受损失，防止系统崩溃或断电导致的数据丢失。大多数现代文件系统支持日志记录和数据校验来提高可靠性。</li><li><strong>特性支持</strong>：列出了每种文件系统所支持的特性，如文件加密、压缩、权限管理、快照、去重等。</li></ul><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><p>可以看到文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。</p><p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p><img src="https://s2.loli.net/2024/12/21/dqhFmucZUt9GaP3.png" alt="VFS" style="zoom:50%;" /><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p><strong>文件系统的挂载（Mounting）</strong> 是将存储设备或分区上的文件系统连接到操作系统的文件层次结构中的一个过程。挂载的目的是使得存储设备上的数据可以被操作系统访问和管理。（指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。）</p><p>Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 inux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p><blockquote><p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p></blockquote><p>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p><blockquote><p>并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p></blockquote><h5 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h5><p>在现代操作系统中，文件系统以树状结构组织数据，这棵树的根节点称为“根目录”（<code>/</code>）。挂载就是将一个存储设备或分区的文件系统（如硬盘、SSD、U盘等）与操作系统的现有文件系统结构中的某个目录连接起来，使得该设备上的文件和目录可以像本地文件一样被访问。</p><h5 id="挂载过程："><a href="#挂载过程：" class="headerlink" title="挂载过程："></a><strong>挂载过程：</strong></h5><ol><li><strong>设备准备</strong>：首先，操作系统会识别并准备好存储设备（如硬盘、SSD、USB设备等）。</li><li><strong>挂载命令</strong>：系统管理员或用户使用挂载命令（在 Linux 中是 <code>mount</code>）指定要挂载的设备和目标目录。</li><li><strong>文件系统关联</strong>：文件系统将设备上的文件系统结构与操作系统文件树中的指定目录进行连接。这使得设备上的文件能够通过目标目录路径访问。</li></ol><p>更具体的过程可以参考：<a href="https://blog.csdn.net/weixin_47763623/article/details/143710029">深入理解Linux文件系统的挂载过程_文件挂载-CSDN博客</a></p><h5 id="挂载点的意义："><a href="#挂载点的意义：" class="headerlink" title="挂载点的意义："></a><strong>挂载点的意义：</strong></h5><p>挂载点是文件系统挂载的具体目录。在挂载完成后，存储设备的文件系统会表现得像是文件树的一部分，可以通过挂载点来访问设备上的数据。挂载点可以是任何空目录，而不仅仅是 <code>/mnt</code> 或 <code>/media</code>。</p><h3 id="文件系统的访问方法"><a href="#文件系统的访问方法" class="headerlink" title="文件系统的访问方法"></a>文件系统的访问方法</h3><h4 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起读取请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>read()</code>）发起文件读取请求。</td></tr><tr><td><strong>2. 操作系统进行文件查找</strong></td><td>操作系统解析文件路径，查找文件的元数据（如 inode 或 MFT），确定文件的存储位置。</td></tr><tr><td><strong>3. 获取物理块地址</strong></td><td>操作系统根据文件的元数据找到文件数据的物理块位置。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统将文件的数据块地址传递给磁盘设备驱动程序，驱动程序负责访问磁盘并读取数据块。</td></tr><tr><td><strong>5. 磁盘控制器读取数据</strong></td><td>磁盘控制器根据操作系统的请求，定位并读取物理磁盘上相应的扇区或块，传输数据到内存。</td></tr><tr><td><strong>6. 数据传输到内存</strong></td><td>磁盘控制器将读取的数据传输到内存缓存中，操作系统将数据保存到内存中，准备将其传递给应用程序。</td></tr><tr><td><strong>7. 文件数据返回给应用程序</strong></td><td>操作系统将数据从内存传输到用户空间，应用程序可以对文件数据进行处理。</td></tr><tr><td><strong>8. 缓存和优化</strong></td><td>操作系统和磁盘控制器可能会使用缓存机制（如页面缓存、硬盘缓存）来优化数据访问速度，减少磁盘访问次数。</td></tr></tbody></table><h4 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a><strong>写入磁盘</strong></h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起写入请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>write()</code>）发起写入请求，指定要写入的数据内容和目标文件。操作系统获取数据并准备写入磁盘。</td></tr><tr><td><strong>2. 操作系统检查文件描述符</strong></td><td>操作系统检查应用程序提供的文件描述符，确保文件已经被打开并且可以写入。如果文件是可写的，系统会继续处理；如果是只读文件，则会报错。</td></tr><tr><td><strong>3. 获取文件的物理存储位置</strong></td><td>操作系统查找文件的元数据（如 inode），确定文件的存储位置（磁盘上的数据块）。如果文件是新创建的，操作系统可能需要为文件分配新的磁盘块。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统通过文件系统向块设备驱动程序发出写入请求，传递数据块的地址以及要写入的数据。设备驱动程序准备与磁盘或 SSD 进行交互，确保数据能正确写入。</td></tr><tr><td><strong>5. 数据写入磁盘控制器</strong></td><td>磁盘控制器收到写入请求后，将数据写入到磁盘的特定物理扇区或块中。如果是硬盘，磁头会移动到正确的位置；如果是 SSD，数据直接写入对应的闪存单元。</td></tr><tr><td><strong>6. 数据确认</strong></td><td>写入操作完成后，磁盘控制器向操作系统确认数据已经成功写入。数据也可能被缓存到内存中，以便未来的读取请求。</td></tr><tr><td><strong>7. 更新文件元数据</strong></td><td>操作系统更新文件的元数据（如 inode），以反映文件的最新状态（例如，更新文件大小、修改时间等）。如果数据被追加到文件末尾，操作系统也会更新文件的尾部地址。</td></tr><tr><td><strong>8. 应用程序收到写入结果</strong></td><td>操作系统返回写入操作的结果（如成功或失败），并可能将写入的数据缓存到内存中，以便在后续操作中提高性能。应用程序可以进行进一步处理或关闭文件。</td></tr><tr><td><strong>9. 缓存和优化</strong></td><td>操作系统可能会将写入的数据保留在内存中的缓存中，减少后续的磁盘写入次数，并在合适的时候将数据刷新到磁盘。磁盘控制器也可能使用其内部缓存进行写入操作优化。</td></tr></tbody></table><blockquote><ol><li>文件必须已经打开并且具有写权限。</li><li>操作系统通过文件描述符来标识文件，并管理文件的元数据和数据存储。</li><li>写入过程可能涉及数据缓存，以提高磁盘写入效率。</li></ol></blockquote><h4 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h4><p>和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</p><p>在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p><p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p><p><img src="https://s2.loli.net/2024/12/21/2nDUmwNpIYa4yHP.png" alt="目录"></p><p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://s2.loli.net/2024/12/21/3JgNmYFdju81Xfo.png" alt="硬链接"></p><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><p><img src="https://s2.loli.net/2024/12/21/tNaVmgeKGuC5xdQ.png" alt="软链接"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符（<strong>File Descriptor</strong>，简称 <strong>FD</strong>）是操作系统层面上用于标识打开的文件的一个整数标识符。在操作系统中，文件描述符存在于用户空间和内核空间之间，通常是在 <strong>操作系统的内核层</strong> 中使用的。</p><h5 id="与文件描述符相关的层次和流程："><a href="#与文件描述符相关的层次和流程：" class="headerlink" title="与文件描述符相关的层次和流程："></a><strong>与文件描述符相关的层次和流程：</strong></h5><ol><li>用户空间<ul><li>在用户空间，应用程序通过标准库（如 <code>libc</code>）发起文件操作。库会通过系统调用（如 <code>open()</code>）请求操作系统打开文件。</li><li>应用程序通过文件描述符来与内核交互，使用它来进行文件读写（例如，使用 <code>read()</code>、<code>write()</code> 等函数）。</li></ul></li><li>内核空间<ul><li>操作系统内核使用文件描述符来标识进程打开的文件，并维护与文件相关的状态信息。这些信息通常存储在 <strong>文件表</strong> 中。</li><li>当进程发起文件操作时，内核根据文件描述符查找文件表中的条目，找到文件的元数据并执行实际的文件I&#x2F;O操作。</li><li>每个进程都有一个与之关联的<strong>文件描述符表</strong>，它存储了该进程打开的所有文件的文件描述符以及与这些文件相关的内核信息。</li></ul></li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/404423676">计算机组成原理笔记-IO接口与设备 - 知乎</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/12565601.html">简直不要太硬了！一文带你彻底理解文件系统 - 程序员cxuan - 博客园</a></p><p><a href="https://www.cnblogs.com/cangqinglang/p/12170828.html">什么是挂载，Linux挂载如何实现详解 - 苍青浪 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="没有内存抽象的年代"><a href="#没有内存抽象的年代" class="headerlink" title="没有内存抽象的年代"></a>没有内存抽象的年代</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>程序直接访问和操作的都是物理内存，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：mov reg,1000</p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>使得操作系统中存在多进程变得完全不可能，因为如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p><h1 id="进行抽象-地址空间"><a href="#进行抽象-地址空间" class="headerlink" title="进行抽象:地址空间"></a>进行抽象:地址空间</h1><h2 id="管理方式：-1"><a href="#管理方式：-1" class="headerlink" title="管理方式："></a>管理方式：</h2><p>操作系统给每个进程划分一个区段，把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。该区域就是操作系统需要对物理内存做一层抽象，也就是「地址空间」，一个进程的地址空间包含了该进程所有相关内存，比如 code &#x2F; stack &#x2F; heap。</p><img src="https://s2.loli.net/2024/12/19/g4KvQb2HiBRXhDZ.png" alt="image-20241219212225816" style="zoom:50%;" /><p><strong>值得注意的是：当程序运行时，heap 和 stack 共用中间 free 的区域</strong></p><p>这里描述的是操作系统提供给运行程序的抽象（abstract）。程序不在物理地址0～16KB的内存中，而是加载在任意的物理地址。当操作系统这样做时，我们说操作系统在虚拟化内存（virtualizing memory），因为运行的程序认为它被加载到特定地址（例如0）的内存中，并且具有非常大的地址空间（例如32位或64位）。现实很不一样。这给该进程应用一种假象：自己独占整个操作系统内存。</p><p>真实的物理内存可能是这样的：</p><img src="https://s2.loli.net/2024/12/19/oAe9GuFCrVI8vw1.png" alt="image-20241219213017762" style="zoom:50%;" /><blockquote><p>虚拟内存三个目标：透明，效率，隔离保护</p></blockquote><p>其中从操作系统从虚拟内存映射到物理内存上时，使用基址寄存器base 和 界限寄存器bounds 可以简单的动态重定位：每个内存地址送到内存之前，都会自动加上基址寄存器的内容。，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">physical address = <span class="hljs-keyword">virtual</span> address + base<br></code></pre></td></tr></table></figure><p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>抽象虽然解决了多进程覆盖的问题，但可以看到：栈和堆之间，有一大块“空闲”空间。如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。</p><h1 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&#x2F;界限"></a>分段：泛化的基址&#x2F;界限</h1><h2 id="管理方式：-2"><a href="#管理方式：-2" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在MMU中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p><img src="https://s2.loli.net/2024/12/19/yRn1ZmDSaQzK5iP.png" alt="image-20241219214240193" style="zoom: 33%;" /><p>在这其中操作系统使用MMU中的硬件结构来支持分段，使用一组多对基址和界限寄存器。表每个界限寄存器记录了一个段的大小进行管理。</p><p><img src="https://s2.loli.net/2024/12/19/Q7NT9DJR8iEVbua.png" alt="image-20241219214616230"></p><p>段式管理的地址变换如下：</p><p><img src="https://s2.loli.net/2024/12/19/s9A1nWe4zUBTdtg.png" alt="image-20241219214644880"></p><p>栈的管理可以使其反向增长即硬件还需要知道段的增长方向（用一位区分，比如1代表自小而大增长，0反之）。</p><p><img src="https://s2.loli.net/2024/12/19/yVCudXBlvZWOjAb.png" alt="image-20241219215036017"></p><p>随着分段机制的不断改进，为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p><p><img src="https://s2.loli.net/2024/12/19/QqbwIY4Rc7Bn6xW.png" alt="image-20241219215126644"></p><p>有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否越界，硬件还需要检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。</p><h2 id="带来的问题：-2"><a href="#带来的问题：-2" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>分段虽然大量节省了栈和堆之间没有使用的区域的内存，但也带来了新的问题：</p><p>1.操作系统在上下文切换时应该做什么？即：各个段寄存器中的内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。</p><p>2.管理物理内存的空闲空间。新的地址空间被创建时，操作系统需要在物理内存中为它的段找到空间。之前，我们假设所有的地址空间大小相同，物理内存可以被认为是一些槽块，进程可以放进去。现在，每个进程都有一些段，每个段的大小也可能不同。</p><p>3.分段使物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong></p><img src="https://s2.loli.net/2024/12/19/95MYxJav2tR3lPC.png" alt="image-20241219215544783" style="zoom:25%;" /><p>这里的空闲内存的管理有许多方法，请自行百度</p><h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><h2 id="管理方式：-3"><a href="#管理方式：-3" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在分段中，随着时间推移将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），分配内存会变得比较困难。这就引出了页式存储：<strong>将空间分割成固定长度的分片</strong>在虚拟内存中，我们称这种思想为分页。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。</p><img src="https://s2.loli.net/2024/12/19/gpzJwLlqhfS6RMF.png" alt="image-20241219220325363" style="zoom:25%;" /><blockquote><p>技术难点：如何通过页来实现虚拟内存，从而避免分段的问题？基本技术是什么？如何让这些技术运行良好，并尽可能减少空间和时间开销？</p></blockquote><p>通过完善的分页方法，操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。例如，我们不会假定堆和栈的增长方向，以及它们如何使用。另一个优点是分页提供的空闲空间管理的简单性。例如，如果操作系统希望将64字节的小地址空间放到8 页的物理地址空间中，它只要找到4个空闲页。也许操作系统保存了一个所有空闲页的空闲列表（free list），只需要从这个列表中拿出4个空闲页。</p><img src="https://s2.loli.net/2024/12/19/FmvwQhTAifotZzu.png" alt="image-20241219220601987" style="zoom:25%;" /><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p><img src="https://s2.loli.net/2024/12/19/xF1zUfctZ65V9YB.png" alt="image-20241219220707385" style="zoom:25%;" /><h3 id="页表带来的问题"><a href="#页表带来的问题" class="headerlink" title="页表带来的问题"></a>页表带来的问题</h3><p>页表带来了一个问题：页表可以变得非常大，因此消耗的内存太多</p><p>由于页表如此之大，我们没有在MMU中利用任何特殊的片上硬件，来存储当前正在运行的进程的页表，而是将每个进程的页表存储在内存中。</p><img src="https://s2.loli.net/2024/12/19/rOUL5Vd8zGEJ3TF.png" alt="image-20241219221140011" style="zoom:25%;" /><p>解决方法有很多比如：</p><ul><li>混合方法：分页和分段</li><li>多级页表</li><li>反向页表</li><li>将页表交换到磁盘</li></ul><p>详细可自行百度</p><h3 id="页式管理地址变换"><a href="#页式管理地址变换" class="headerlink" title="页式管理地址变换"></a>页式管理地址变换</h3><p>在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</p><p>原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</p><p>逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址：</p><img src="https://s2.loli.net/2024/12/19/QVSgG42OWY9UANu.jpg" alt="v2-6fd0dc83a485be4df41e8f26a22d5217_1440w" style="zoom: 50%;" /><h3 id="分页带来的另一个问题："><a href="#分页带来的另一个问题：" class="headerlink" title="分页带来的另一个问题："></a>分页带来的另一个问题：</h3><p>使用分页作为核心机制来实现虚拟内存，可能会带来较高的性能开销。因为要使用分页，就要将内存地址空间切分成大量固定大小的单元（页），并且需要记录这些单元的地址映射信息。因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。因此我们面临如下问题：如何加速地址转换如何才能加速虚拟地址转换，尽量避免额外的内存访问？</p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>添加硬件(具有并行查找能力的高速缓冲存储器——快表)所谓的地址转换旁路缓冲存储器（translation-lookaside buffer，TLB[CG68,C95]），它就是频繁发生的虚拟到物理地址转换的硬件缓存（cache）,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应，主存中的页表也常称为慢表，配有快表的地址变换机对每次内存访问。硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p><p><img src="https://s2.loli.net/2024/12/19/vISmptgqeYFz2Ao.png" alt="727485-20210705142341111-31060538"></p><p>在具有快表的分页机制中，地址的变换过程：</p><ul><li>CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li><li>如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ul><p>注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。</p><h1 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h1><h2 id="如何超越物理内存？【硬盘交互机制】"><a href="#如何超越物理内存？【硬盘交互机制】" class="headerlink" title="如何超越物理内存？【硬盘交互机制】"></a>如何超越物理内存？【硬盘交互机制】</h2><p>交换空间</p><h2 id="如何决定踢出哪个页？"><a href="#如何决定踢出哪个页？" class="headerlink" title="如何决定踢出哪个页？"></a>如何决定踢出哪个页？</h2><p>替换策略</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
