<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>android_linker加载和链接</title>
    <link href="/2024/12/22/android-linker%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <url>/2024/12/22/android-linker%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Liner入口"><a href="#Liner入口" class="headerlink" title="Liner入口"></a>Liner入口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span>&#123;<br>    System.loadLibrary(<span class="hljs-string">&quot;native-lib&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/System.java#1651">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/System.java#1651</a></p><p><img src="https://s2.loli.net/2024/12/22/98lLUWaV6qd5XAn.png" alt="image-20241222112316647"></p><p>Runtime类是：</p><p>参数是：</p><p>这里的getRuntime()只是Runtime的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> currentRuntime;<br> &#125;<br></code></pre></td></tr></table></figure><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java#58">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/java/java/lang/Runtime.java#58</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadLibrary0</span><span class="hljs-params">(ClassLoader loader, String libname)</span> &#123;<br>        <span class="hljs-keyword">if</span> (libname.indexOf((<span class="hljs-type">int</span>)File.separatorChar) != -<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(<br>    <span class="hljs-string">&quot;Directory separator should not appear in library name: &quot;</span> + libname);<br>        &#125;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">libraryName</span> <span class="hljs-operator">=</span> libname;<br>        <span class="hljs-keyword">if</span> (loader != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> loader.findLibrary(libraryName);<br>           <span class="hljs-keyword">if</span> (filename == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// It&#x27;s not necessarily true that the ClassLoader used</span><br>               <span class="hljs-comment">// System.mapLibraryName, but the default setup does, and it&#x27;s</span><br>                <span class="hljs-comment">// misleading to say we didn&#x27;t find &quot;libMyLibrary.so&quot; when we</span><br>             <span class="hljs-comment">// actually searched for &quot;liblibMyLibrary.so.so&quot;.</span><br><span class="hljs-number">1011</span>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(loader + <span class="hljs-string">&quot; couldn&#x27;t find \&quot;&quot;</span> +<br>                                                    System.mapLibraryName(libraryName) + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> nativeLoad(filename, loader);<br>           <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(error);<br>            &#125;<br>           <span class="hljs-keyword">return</span>;<br>        &#125;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">filename</span> <span class="hljs-operator">=</span> System.mapLibraryName(libraryName);<br>        List&lt;String&gt; candidates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">lastError</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">for</span> (String directory : getLibPaths()) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">candidate</span> <span class="hljs-operator">=</span> directory + filename;<br>           candidates.add(candidate);<br><br>           <span class="hljs-keyword">if</span> (IoUtils.canOpenReadOnly(candidate)) &#123;<br>              <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> nativeLoad(candidate, loader);<br>               <span class="hljs-keyword">if</span> (error == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// We successfully loaded the library. Job done.</span><br>                &#125;<br>                lastError = error;<br>            &#125;<br>        &#125;<br>       <span class="hljs-keyword">if</span> (lastError != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(lastError);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsatisfiedLinkError</span>(<span class="hljs-string">&quot;Library &quot;</span> + libraryName + <span class="hljs-string">&quot; not found; tried &quot;</span> + candidates);<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">nativeLoad</span><span class="hljs-params">(String filename, ClassLoader loader)</span>;<br></code></pre></td></tr></table></figure><p><a href="http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/native/Runtime.c">http://androidxref.com/9.0.0_r3/xref/libcore/ojluni/src/main/native/Runtime.c</a></p><p><img src="https://s2.loli.net/2024/12/22/LBp16Sm7YTcROdw.png" alt="image-20241222113855201"></p><p><a href="http://androidxref.com/9.0.0_r3/xref/art/openjdkjvm/OpenjdkJvm.cc#323">http://androidxref.com/9.0.0_r3/xref/art/openjdkjvm/OpenjdkJvm.cc#323</a></p><p><img src="https://s2.loli.net/2024/12/22/PDnfB2tOzc1Whqy.png" alt="image-20241222113823277"></p><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/java_vm_ext.cc#854">http://androidxref.com/9.0.0_r3/xref/art/runtime/java_vm_ext.cc#854</a></p></blockquote><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cc"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JavaVMExt::LoadNativeLibrary</span><span class="hljs-params">(JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  <span class="hljs-type">const</span> std::string&amp; path,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  jobject class_loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                  std::string* error_msg)</span> </span>&#123;<br>  error_msg-&gt;<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-comment">// 检查是否已经加载了该库。如果已经加载，并且类加载器匹配，则直接返回成功。</span><br>  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 为了更好的结果，我们应该规范化路径名（或者直接比较 inode）。如果每个人都使用 System.loadLibrary，这种实现是可以接受的。</span><br>  SharedLibrary* library;<br>  Thread* self = Thread::<span class="hljs-built_in">Current</span>();<br>  &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 将锁定逻辑（以及更多的逻辑）移到 Libraries 中。</span><br>    <span class="hljs-function">MutexLock <span class="hljs-title">mu</span><span class="hljs-params">(self, *Locks::jni_libraries_lock_)</span></span>;<br>    library = libraries_-&gt;<span class="hljs-built_in">Get</span>(path);<br>  &#125;<br>  <span class="hljs-type">void</span>* class_loader_allocator = <span class="hljs-literal">nullptr</span>;<br>  &#123;<br>    <span class="hljs-function">ScopedObjectAccess <span class="hljs-title">soa</span><span class="hljs-params">(env)</span></span>;<br>    <span class="hljs-comment">// 因为传入的类加载器在调用此函数期间是可到达/存活的，所以可以解码它，而无需担心意外标记它为存活状态。</span><br>    ObjPtr&lt;mirror::ClassLoader&gt; loader = soa.<span class="hljs-built_in">Decode</span>&lt;mirror::ClassLoader&gt;(class_loader);<br><br>    ClassLinker* class_linker = Runtime::<span class="hljs-built_in">Current</span>()-&gt;<span class="hljs-built_in">GetClassLinker</span>();<br>    <span class="hljs-keyword">if</span> (class_linker-&gt;<span class="hljs-built_in">IsBootClassLoader</span>(soa, loader.<span class="hljs-built_in">Ptr</span>())) &#123;<br>      loader = <span class="hljs-literal">nullptr</span>;<br>      class_loader = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    class_loader_allocator = class_linker-&gt;<span class="hljs-built_in">GetAllocatorForClassLoader</span>(loader.<span class="hljs-built_in">Ptr</span>());<br>    <span class="hljs-built_in">CHECK</span>(class_loader_allocator != <span class="hljs-literal">nullptr</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (library != <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// 使用分配器指针来比较类加载器是否相同，以避免不必要的弱引用解码。</span><br>    <span class="hljs-keyword">if</span> (library-&gt;<span class="hljs-built_in">GetClassLoaderAllocator</span>() != class_loader_allocator) &#123;<br>      <span class="hljs-comment">// 该库将与类加载器关联。根据 JNI 规范，我们不能将同一个库加载到多个类加载器中。</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// 这种情况并不常见。因此，可以花一些时间生成一个可读的消息。</span><br>      <span class="hljs-keyword">auto</span> call_to_string = [&amp;](jobject obj) -&gt; std::string &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">nullptr</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">// 处理 jweaks。忽略双重本地引用。</span><br>        <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">local_ref</span><span class="hljs-params">(env, env-&gt;NewLocalRef(obj))</span></span>;<br>        <span class="hljs-keyword">if</span> (local_ref != <span class="hljs-literal">nullptr</span>) &#123;<br>          <span class="hljs-function">ScopedLocalRef&lt;jclass&gt; <span class="hljs-title">local_class</span><span class="hljs-params">(env, env-&gt;GetObjectClass(local_ref.get()))</span></span>;<br>          jmethodID to_string = env-&gt;<span class="hljs-built_in">GetMethodID</span>(local_class.<span class="hljs-built_in">get</span>(),<br>                                                 <span class="hljs-string">&quot;toString&quot;</span>,<br>                                                 <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>);<br>          <span class="hljs-built_in">DCHECK</span>(to_string != <span class="hljs-literal">nullptr</span>);<br>          <span class="hljs-function">ScopedLocalRef&lt;jobject&gt; <span class="hljs-title">local_string</span><span class="hljs-params">(env,</span></span><br><span class="hljs-params"><span class="hljs-function">                                               env-&gt;CallObjectMethod(local_ref.get(), to_string))</span></span>;<br>          <span class="hljs-keyword">if</span> (local_string != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-function">ScopedUtfChars <span class="hljs-title">utf</span><span class="hljs-params">(env, <span class="hljs-keyword">reinterpret_cast</span>&lt;jstring&gt;(local_string.get()))</span></span>;<br>            <span class="hljs-keyword">if</span> (utf.<span class="hljs-built_in">c_str</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>              <span class="hljs-keyword">return</span> utf.<span class="hljs-built_in">c_str</span>();<br>            &#125;<br>          &#125;<br>          env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br>          <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(调用 toString 出错)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;<br>      &#125;;<br>      std::string old_class_loader = <span class="hljs-built_in">call_to_string</span>(library-&gt;<span class="hljs-built_in">GetClassLoader</span>());<br>      std::string new_class_loader = <span class="hljs-built_in">call_to_string</span>(class_loader);<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;共享库 \&quot;%s\&quot; 已经被 ClassLoader %p(%s) 加载；无法在 ClassLoader %p(%s) 中再次加载&quot;</span>,<br>          path.<span class="hljs-built_in">c_str</span>(),<br>          library-&gt;<span class="hljs-built_in">GetClassLoader</span>(),<br>          old_class_loader.<span class="hljs-built_in">c_str</span>(),<br>          class_loader,<br>          new_class_loader.<span class="hljs-built_in">c_str</span>());<br>      <span class="hljs-built_in">LOG</span>(WARNING) &lt;&lt; *error_msg;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">VLOG</span>(jni) &lt;&lt; <span class="hljs-string">&quot;[共享库 \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot; 已加载到 ClassLoader &quot;</span> &lt;&lt; class_loader &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    <span class="hljs-keyword">if</span> (!library-&gt;<span class="hljs-built_in">CheckOnLoadResult</span>()) &#123;<br>      <span class="hljs-built_in">StringAppendF</span>(error_msg, <span class="hljs-string">&quot;之前尝试加载 \&quot;%s\&quot; 时 JNI_OnLoad 失败&quot;</span>, path.<span class="hljs-built_in">c_str</span>());<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/22/r9iqlag2IOxf4RG.png" alt="image-20241222121528343"></p><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/system/core/libnativeloader/native_loader.cpp#637">http://androidxref.com/9.0.0_r3/xref/system/core/libnativeloader/native_loader.cpp#637</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/22/yXWOYAcgw7QZkj4.png" alt="image-20241222121435312"></p><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/bionic/libdl/libdl.cpp">http://androidxref.com/9.0.0_r3/xref/bionic/libdl/libdl.cpp</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">int</span> flag)</span> &#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">void</span>* caller_addr = __builtin_return_address(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> __loader_dlopen(filename, flag, caller_addr);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/bionic/linker/dlfcn.cpp#dlopen_ext">http://androidxref.com/9.0.0_r3/xref/bionic/linker/dlfcn.cpp#dlopen_ext</a></p></blockquote><p><img src="https://s2.loli.net/2024/12/22/9dlAX3xyU2JjpGD.png" alt="image-20241222121214603"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* sym = library-&gt;FindSymbol(<span class="hljs-string">&quot;JNI_OnLoad&quot;</span>, nullptr);<br><span class="hljs-keyword">if</span> (sym == nullptr) &#123;<br>  VLOG(jni) &lt;&lt; <span class="hljs-string">&quot;[No JNI_OnLoad found in \&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;]&quot;</span>;<br>  was_successful = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>.....<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/ti/agent.cc#154">http://androidxref.com/9.0.0_r3/xref/art/runtime/ti/agent.cc#154</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">Agent::FindSymbol</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; name)</span> <span class="hljs-type">const</span> &#123;<br>  CHECK(dlopen_handle_ != nullptr) &lt;&lt; <span class="hljs-string">&quot;Cannot find symbols in an unloaded agent library &quot;</span> &lt;&lt; this;<br>  <span class="hljs-keyword">return</span> dlsym(dlopen_handle_, name.c_str());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unicorn原理浅析</title>
    <link href="/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="unicorn是什么？"><a href="#unicorn是什么？" class="headerlink" title="unicorn是什么？"></a>unicorn是什么？</h1><p><strong>Unicorn</strong> 是一个基于 QEMU 的轻量级 CPU 仿真框架，用于模拟多种架构（如 ARM、x86、MIPS 等）的指令执行和状态变化。其本质是通过 <strong>动态二进制翻译</strong> (Dynamic Binary Translation) 将目标架构的指令翻译为宿主架构可执行代码，并在宿主机运行。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul><li><strong>多架构支持</strong>：支持 ARM、x86、MIPS 等主流架构及模式（如 ARM&#x2F;Thumb）。</li><li><strong>指令仿真</strong>：精准模拟 CPU 指令行为（如跳转、寄存器操作、内存访问等）。</li><li><strong>内存与寄存器仿真</strong>：用户可自定义虚拟内存布局及操作寄存器。</li><li><strong>钩子机制</strong>：支持拦截指令、内存访问等，便于监控和调试。</li></ul><h3 id="本质特点"><a href="#本质特点" class="headerlink" title="本质特点"></a><strong>本质特点</strong></h3><ul><li><strong>动态翻译</strong>：基于 QEMU 的 TCG 技术，直接在宿主机运行目标指令，高效快捷。</li><li><strong>模块化</strong>：仅关注 CPU 指令仿真，易用、灵活，适合安全研究、逆向工程和嵌入式开发。</li></ul><h1 id="ARM64的体系架构"><a href="#ARM64的体系架构" class="headerlink" title="ARM64的体系架构"></a>ARM64的体系架构</h1><p>见上篇文章：ARM64架构</p><h1 id="unicorn怎么运行起来的？"><a href="#unicorn怎么运行起来的？" class="headerlink" title="unicorn怎么运行起来的？"></a>unicorn怎么运行起来的？</h1><p>CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）</p><p>Unicorn要模拟的是CPU的运行。所以也就（只）是，把代码放到对应的地址上，Unicorn开始运行，去对应地址：<strong>读取指令</strong>，（解析并）<strong>执行指令</strong>，而解析和运行该指令的结果，往往是，本身就是，写入计算后的结果到对应的寄存器或内存而已。</p><p>而在指令执行期间的所需要的其他内容，比如后续会涉及到的函数参数、Stack栈、Heap堆等等，则都是为了：确保Unicorn模拟CPU的结果，和真实的代码执行的结果，要（完全）一致，才有价值，才能真正得到的希望的输出的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">指令<span class="hljs-operator">=</span>instruction <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 代码<span class="hljs-operator">=</span>code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 操作码<span class="hljs-operator">=</span>opcode <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 二进制(数据) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> binary (data)<br></code></pre></td></tr></table></figure><h2 id="怎么模拟出内存等结构的？"><a href="#怎么模拟出内存等结构的？" class="headerlink" title="怎么模拟出内存等结构的？"></a>怎么模拟出内存等结构的？</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p><img src="https://s2.loli.net/2024/12/17/kpMjRTFBOX3Qv2V.png" alt="image-20241217103506135"></p><p>一个常见的内存布局如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>起始地址</strong></th><th><strong>大小</strong></th><th><strong>权限</strong></th></tr></thead><tbody><tr><td>代码段</td><td><code>0x40000</code></td><td>2 MB</td><td>可读可执行（RX）</td></tr><tr><td>数据段</td><td><code>0x42000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆区</td><td><code>0x60000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆栈段</td><td><code>0x7FFF0000</code></td><td>1 MB（向下增长）</td><td>可读可写（RW）</td></tr></tbody></table><p><strong>代码段</strong>：</p><ul><li>通常映射在较低的地址区域，如 <code>0x40000</code>，用来存储程序的指令。</li><li>设置为可读可执行权限（<code>UC_PROT_READ | UC_PROT_EXEC</code>）。</li></ul><p><strong>数据段</strong>：</p><ul><li>紧邻代码段，用来存储全局变量、静态变量等。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>堆区</strong>：</p><ul><li>用于动态分配内存，可以根据程序运行时的需求调整大小。</li><li>通过自定义的内存管理器或直接扩展区域实现。</li></ul><p><strong>堆栈段</strong>：</p><ul><li>通常放在高地址区域（如 <code>0x7FFF0000</code>），并从高地址向低地址增长。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>Unicorn 的内存设置是它自己模拟的，而不是由操作系统直接管理的</strong>。Unicorn 作为一个用户态的 CPU 仿真框架，模拟了目标架构的 CPU 和内存系统。Unicorn 将内存的虚拟地址（如 <code>0x40000</code> 或 <code>0x7FFF0000</code>）完全作为目标架构的地址模拟，与主机的虚拟地址无关。主机操作系统只负责分配 Unicorn 运行本身需要的资源（如 CPU 时间和主机内存），但不会干涉 Unicorn 模拟的内存布局。</p><p>值得注意的是：</p><p>Unicorn 本身并不会主动区分“特殊用途”地址和“普通地址”，但它的执行逻辑可能依赖用户分配的地址。但如果你在 <code>0x0 - 0xFFFF</code> 范围内映射代码或数据，可能会导致以下问题：</p><ol><li><strong>Unicorn 的初始化数据</strong>：某些架构可能会默认初始化特定的寄存器或内存区域到低地址，用户手动操作的地址可能与这些区域冲突。</li><li><strong>调试和兼容性问题</strong>：许多调试工具或调试器（如 GDB）默认会将低地址区域视为不可用的保留空间。如果代码被放置在低地址区域，调试时可能导致断点设置失败或程序崩溃。</li></ol><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>写入内容（代码，数据）到内存中之前，要注意先确认<code>字节序</code>&#x3D;<code>endian</code>是<code>大端</code>还是<code>小端</code></p><p>ARM中，默认是<code>小端</code>&#x3D;<code>UC_MODE_LITTLE_ENDIAN</code></p><p>除非特殊需要，才会设置为<code>大端</code>&#x3D;<code>UC_MODE_BIG_ENDIAN</code></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>(1) 动态二进制翻译（Dynamic Binary Translation）</strong></td><td></td></tr><tr><td><strong>翻译机制</strong></td><td>- 通过 QEMU 的 TCG（Tiny Code Generator）实现动态翻译。- 将目标架构的指令翻译为宿主架构的中间表示（IR, Intermediate Representation）。- 翻译后的代码缓存在 <strong>Translation Block Cache (TLB)</strong> 中。</td></tr><tr><td><strong>执行流程</strong></td><td>1. 解析目标架构指令。2. 使用 TCG 将指令翻译为宿主架构的中间代码（IR）。3. 中间代码再翻译为宿主机的原生机器指令，并直接运行。</td></tr><tr><td><strong>性能特点</strong></td><td>- 比解释型模拟（如 Bochs）快得多。- 动态翻译存在一定开销，但重复执行时利用 TLB 提升效率。</td></tr><tr><td><strong>(2) 指令的分发与仿真</strong></td><td></td></tr><tr><td><strong>指令获取</strong></td><td>- 从当前 <strong>PC（Program Counter）</strong> 所指向的地址读取目标内存中的指令。- 内存管理由 Unicorn 的虚拟内存模型负责，需通过 <strong><code>uc_mem_map</code></strong> 等接口预先映射内存。</td></tr><tr><td><strong>指令解析与翻译</strong></td><td>- 根据架构解码指令，提取操作码和操作数。示例：- <strong>ARM</strong>：解析指令类型（如分支 <code>BL</code>、数据处理 <code>ADD</code>、内存访问 <code>LDR</code>）。- <strong>x86</strong>：解析指令（如 <code>MOV</code>、<code>CALL</code>、<code>JMP</code>）。</td></tr><tr><td><strong>指令执行</strong></td><td>- 将解析的指令翻译为宿主机代码并执行。- 例如模拟内存访问、条件跳转、异常处理等。</td></tr><tr><td><strong>状态更新</strong></td><td>- 根据指令执行结果更新模拟状态（寄存器、内存等）。</td></tr><tr><td><strong>(3) 内存与寄存器仿真</strong></td><td></td></tr><tr><td><strong>内存仿真</strong></td><td>- Unicorn 使用虚拟内存模型模拟目标架构内存。- 用户通过 <strong><code>uc_mem_map</code></strong> 定义虚拟内存布局。- 所有内存访问都经 Unicorn 的内存管理层检查。</td></tr><tr><td><strong>寄存器仿真</strong></td><td>- 不同架构有各自的寄存器模型：    - <strong>x86</strong>：<code>EIP</code>、<code>ESP</code> 等。    - <strong>ARM</strong>：<code>R0-R15</code>、<code>PC</code>、<code>LR</code> 等。- 用户通过 <strong><code>uc_reg_read</code></strong> 和 <strong><code>uc_reg_write</code></strong> 接口操作寄存器。</td></tr><tr><td><strong>(4) 钩子机制（Hooking Mechanism）</strong></td><td></td></tr><tr><td><strong>代码钩子</strong></td><td>- 拦截特定指令或地址范围的执行。</td></tr><tr><td><strong>内存钩子</strong></td><td>- 拦截内存读写访问，用于监控或修改操作。</td></tr><tr><td><strong>异常钩子</strong></td><td>- 捕获未定义指令、未映射内存访问等异常。</td></tr><tr><td><strong>(5) 架构和模式切换</strong></td><td></td></tr><tr><td><strong>支持的架构</strong></td><td><strong>x86、x86_64、ARM、ARM64、MIPS、SPARC、PowerPC</strong></td></tr><tr><td><strong>模式切换</strong></td><td>- <strong>x86</strong>：支持 32 位和 64 位模式切换。- <strong>ARM</strong>：支持 ARM 模式和 Thumb 模式切换（通过 <code>BLX</code> 等指令）。- 用户初始化时通过 <code>Uc(UC_ARCH_ARM, UC_MODE_THUMB)</code> 指定模式，模拟中可根据指令动态切换。</td></tr></tbody></table><h1 id="unicorn使用的基本思想？"><a href="#unicorn使用的基本思想？" class="headerlink" title="unicorn使用的基本思想？"></a>unicorn使用的基本思想？</h1><h2 id="运行前初始化"><a href="#运行前初始化" class="headerlink" title="运行前初始化"></a>运行前初始化</h2><p>主要是对内存布局，比如：堆，栈等一些设置，注意对需要模拟的函数参数<strong>提前写入寄存器</strong>，其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。</p><h2 id="运行中Hook"><a href="#运行中Hook" class="headerlink" title="运行中Hook"></a>运行中Hook</h2><p>开始运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mu.emu_start(ADDRESS, ADDRESS + <span class="hljs-built_in">len</span>(ARM_CODE))<br></code></pre></td></tr></table></figure><ul><li>ADDRESS：最开始映射的代码的最初位置</li><li>ADDRESS + len(ARM_CODE)：映射的代码起始位置，加上对应代码长度后的，结束位置</li></ul><blockquote><p>为了用Unicorn模拟代码运行，调试出我们希望搞懂的函数的逻辑，往往期间需要很多额外的调试内容</p></blockquote><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Unicorn模拟期间，常需要去搞懂底层正在发生的细节，查看对应的寄存器、内存的值等等，此时，就可以用到Unicorn所提供的机制：hook。</p><p>其中比较常用的一些hook是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">- hook代码<br>- hook特定指令<br>- hook内存<br>- hook异常<br>- hook其他<br></code></pre></td></tr></table></figure><p>关于Unicorn支持的hook的全部种类是：</p><p>指令执行类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_INTR`<br>- `UC_HOOK_INSN`<br>- `UC_HOOK_CODE`<br>- `UC_HOOK_BLOCK`<br></code></pre></td></tr></table></figure><p>内存访问类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_PROT`<br>- `UC_HOOK_MEM_WRITE_PROT`<br>- `UC_HOOK_MEM_FETCH_PROT`<br>- `UC_HOOK_MEM_READ`<br>- `UC_HOOK_MEM_WRITE`<br>- `UC_HOOK_MEM_FETCH`<br>- `UC_HOOK_MEM_READ_AFTER`<br></code></pre></td></tr></table></figure><p>异常处理类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_UNMAPPED`<br>- `UC_HOOK_MEM_WRITE_UNMAPPED`<br>- `UC_HOOK_MEM_FETCH_UNMAPPED`<br>- `UC_HOOK_INSN_INVALID`<br></code></pre></td></tr></table></figure><p>其他</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_EDGE_GENERATED`<br>- `UC_HOOK_TCG_OPCODE`<br></code></pre></td></tr></table></figure><p>Hook的设置，在运行中逐指令进行对比，当符合设置的内容时，触发钩子函数进行处理</p><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>引入外部的反汇编器disassembler，比如<code>Capstone</code>，自己去把二进制翻译为对应指令</p><h2 id="运行后获取结果"><a href="#运行后获取结果" class="headerlink" title="运行后获取结果"></a>运行后获取结果</h2><h3 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h3><p>对于Unicorn来说，就是模拟CPU运行，模拟去读取指令和运行指令而已。</p><p>所以，换句话说，如果你的给code代码的地址空间写入了代码后，如果没有额外的跳转等复杂逻辑，则：</p><ul><li><strong>Unicorn会一直运行下去</strong></li></ul><p>如果没有合适的触发时机，去让其停下来，那就变成了死循环，永远不结束了。</p><p>而我们的目标是：模拟代码，尤其是函数的逻辑，希望代码运行完毕，输出结果的。</p><p>所以，此处往往选择一个合适的时机去触发其让Unicorn停下来。</p><p>这个时机，一般都是：<code>ret</code>指令，即，当发现正在运行的指令是<code>ret</code>指令，则就会调用<code>emu_stop</code>去停下来。</p><p><strong>在<code>hook_code</code>中，借助<code>Capstone</code>反编译出当前指令，其中<code>mnemonic</code>就是指令名称，当发现是<code>ret</code>指令时</strong></p><p>注：对于arm64e来说，还有更多的PAC相关ret指令：<code>retaa</code>、<code>retab</code>等，所以此处用<code>re</code>正则去判断指令名称是否匹配，而不是直接判断和<code>ret</code>是否相等。</p><p>就去调用<code>emu_stop()</code>去停止Unicorn的继续运行。</p><p><strong>这里也是借助Hook进行的</strong></p><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><p>通过读取寄存器中的值来获取结果</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://book.crifan.org/books/cpu_emulator_unicorn/website/how_use/background/core_logic/cpu_logic.html">CPU的核心逻辑 · CPU模拟利器：Unicorn</a></p>]]></content>
    
    
    <categories>
      
      <category>Reverse(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>unicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angr原理浅析</title>
    <link href="/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p><strong>约束条件（Constraints）</strong> 是对问题求解空间的限制或规定，它规定了哪些解是允许的，哪些解是不允许的。在数学、计算机科学、逻辑学等领域，约束条件通常用于描述某个问题的限制条件，目的是让我们能够从所有可能的解中筛选出符合特定规则或要求的解。</p><p>在数学中，约束条件通常是一些方程或不等式，定义了一个问题的解集。例如，约束条件 <code>x + y ≤ 10</code> 就表示在求解时，变量 <code>x</code> 和 <code>y</code> 的和不能超过 10。</p><p>在计算机科学，约束条件常常是对程序状态的描述，表示程序在某一时刻满足的条件或限制。例如，假设有一个条件 <code>if (x &lt; 10)</code>，那么在程序的执行过程中，<code>x &lt; 10</code> 就是一个约束条件。</p><h2 id="什么是Z3"><a href="#什么是Z3" class="headerlink" title="什么是Z3"></a>什么是Z3</h2><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p><p>不深入研究的话，这里可以简单理解为：<strong>解方程</strong>，当然他还有很多应用场景比如：</p><ul><li><strong>布尔逻辑</strong>：可以处理布尔表达式，求解SAT（布尔可满足性）问题。</li><li><strong>线性算术</strong>：能够处理整数和实数的线性约束。</li><li><strong>非线性算术</strong>：支持非线性算术运算的求解。</li><li><strong>数组、集合、图结构</strong>：支持复杂的数据结构。</li><li><strong>符号执行</strong>：结合符号执行技术，Z3能对程序的执行路径进行分析和求解。</li><li><strong>程序验证</strong>：通过将程序的行为转化为约束，Z3可以帮助验证程序是否满足特定的安全性或功能性要求。</li><li><strong>自动化定理证明</strong>：Z3可以用来证明数学定理或逻辑公式的有效性。</li></ul><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> Solver, Real, sat<br><br><span class="hljs-comment"># 创建符号变量 x</span><br>x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br><br><span class="hljs-comment"># 创建方程：x^2 - 3x + 2 = 0</span><br>equation = x**<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个求解器</span><br>solver = Solver()<br><br><span class="hljs-comment"># 将方程添加到求解器</span><br>solver.add(equation)<br><br><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">if</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程无解&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/5rTdVqvCSa6zQtP.png" alt="image-20241219153257642" style="zoom:50%;" /></p><p>而不是：x &#x3D; 1和x &#x3D; 2</p><p>这是因为Z3 在求解方程时，默认情况下只返回第一个找到的解。这是因为 Z3 是一个 <strong>满足性求解器</strong>（Satisfiability Solver），它的目标是检查约束是否可满足，并返回其中一个满足约束的解，而不是所有可能的解。</p><p>通过进一步添加约束条件可以得到所有解（即排除已经找到的解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">while</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 排除当前解，继续寻找下一个解</span><br>    solver.add(x != model[x])<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/mJYOACvKk2acpsj.png" alt="image-20241219153642676" style="zoom:50%;" /></p><h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="https://s2.loli.net/2024/12/19/u3ez9CtglaXyJNk.png" alt="220430bodvqhbod4pty8zv"></p><p>符号执行是一种程序分析技术，它通过将程序中的某些变量替换为符号变量（而不是具体值），来模拟程序的执行。符号变量代表任意值，并通过符号计算来追踪程序的执行路径和计算结果。与传统的测试方法不同，它并不是通过具体的输入值来执行程序，而是通过符号表示的输入值来执行程序，并尝试探索程序中所有可能的执行路径。</p><h3 id="符号执行流程"><a href="#符号执行流程" class="headerlink" title="符号执行流程"></a>符号执行流程</h3><p><strong>符号变量</strong>： 在符号执行中，输入变量（例如函数参数、内存内容等）被替换为符号变量（symbolic variables），这些符号变量表示可以取任意值。与传统的实际值（如整数、字符串）不同，符号变量没有固定的值，而是代表一个值的集合或范围。</p><p><strong>路径探索</strong>： 符号执行通过模拟程序的控制流来探索不同的路径。每当程序遇到条件判断（例如 <code>if</code> 语句）时，它会根据符号变量的约束来分裂路径。符号执行引擎会为每条路径维护一组条件约束，表示该路径的执行条件。</p><p><strong>约束收集与求解</strong>： 在执行过程中，每当遇到条件判断时（例如 <code>if</code> 语句），符号执行引擎会根据条件生成约束（例如 <code>x &lt; 10</code> 或 <code>x &gt;= 10</code>）。这些约束随着路径的推进被累积。最后，使用约束求解器（如 Z3）来检查是否存在解，即判断某条路径是否可行。如果求解器找到了满足这些约束的具体输入值，那么符号执行就能沿着这条路径继续模拟执行。</p><h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr?"></a>什么是angr?</h2><p><strong>angr</strong> 是一个基于 Python 的 <strong>二进制分析框架</strong>，专门用于分析二进制程序。它提供了一个强大的工具集，用于执行分析任务，如符号执行（Symbolic Execution）、路径探索（Path Exploration）、漏洞挖掘、逆向工程、静态分析等。</p><h2 id="angr的工作原理？"><a href="#angr的工作原理？" class="headerlink" title="angr的工作原理？"></a>angr的工作原理？</h2><ol><li><strong>加载二进制</strong>：<ul><li>使用 angr 加载目标二进制文件（例如 ELF、PE 格式的可执行文件）。</li></ul></li><li><strong>符号执行与路径探索</strong>：<ul><li>angr 会在二进制程序的某些地方插入符号（symbolic variables），并从程序入口点（例如 <code>main</code> 函数）开始执行。每执行一步，angr 会模拟程序的行为并生成新的约束条件。</li></ul></li><li><strong>生成约束</strong>：<ul><li>在符号执行过程中，程序的条件分支会根据符号变量的取值生成约束（例如：<code>x &lt; 10</code>）。这些约束会被加入到当前路径的状态中。</li></ul></li><li><strong>路径分裂</strong>：<ul><li>当遇到条件分支时，angr 会将程序的执行路径分裂成多个子路径。例如，<code>if (x &lt; 10)</code> 会导致两个路径，一个路径满足 <code>x &lt; 10</code>，另一个路径满足 <code>x &gt;= 10</code>。</li></ul></li><li><strong>求解与回溯</strong>：<ul><li>每条路径都会产生约束，angr 会通过求解器（如 Z3）来判断某条路径是否可行。如果路径不可行，angr 会将其丢弃。如果路径可行，它将继续沿着该路径执行，直到达到目标或出现漏洞。</li></ul></li></ol><p>可以看出同unicorn只能走一个分支相比，angr在运行的过程中，从给定的一个state(程序状态，程序的寄存器值，内存的不同都可以作为程序状态的不同)开始执行，每个state维护着一个约束条件的集合(比如i&lt;10,i!&#x3D;0)，通过收集约束，进行遍历，最终angr理论上可以遍历到程序的所有可能控制流，当angr运行到目标状态时，就可以调用求解器(z3等)对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p><img src="https://s2.loli.net/2024/12/19/pwKVfMPCjUbX95v.jpg" alt="215918bnzmvv6wzoqingwv"></p><p>值得注意的是：同传统的静态符号执行(unicorn引擎)相比，<strong>angr使用的是混合执行技术，合并了静态符号执行，和动态具体执行两种技术</strong></p><p>动态符号执行（concolic execution）维持了两个状态。一种是实际变量的状态，另一种是符号化的状态。实际状态将随机生成值映射到变量中，而符号化状态将变量进行符号化。concolic首先将实际状态运行，并收集实际运行时该路径的变量符号化的约束式，i求解。并将约束式取反，获取另一条路径的约束式并求解。过程不断重复，知道路径被探索完，或者达到用户设置的限制。</p><p>具体的例子可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 路径1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 路径2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      <span class="hljs-comment">// 路径3</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态执行过程"><a href="#动态执行过程" class="headerlink" title="动态执行过程"></a>动态执行过程</h3><ol><li><strong>实际状态</strong>：随机初始化输入，例如 <code>x = 15</code>。</li><li><strong>符号化状态</strong>：将 <code>x</code> 表示为符号变量 <code>X</code>。</li></ol><hr><h4 id="步骤1：运行实际状态并收集约束"><a href="#步骤1：运行实际状态并收集约束" class="headerlink" title="步骤1：运行实际状态并收集约束"></a><strong>步骤1：运行实际状态并收集约束</strong></h4><ol><li><p><strong>实际运行</strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">15</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>1</code>，对应<strong>路径1</strong>。</p></li><li><p><strong>符号化执行</strong>：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt; <span class="hljs-number">10</span>  (路径<span class="hljs-number">1</span>)<br>X &lt; <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>将这些条件存入符号约束集。</p></li></ol><hr><h4 id="步骤2：生成新路径（约束取反）"><a href="#步骤2：生成新路径（约束取反）" class="headerlink" title="步骤2：生成新路径（约束取反）"></a><strong>步骤2：生成新路径（约束取反）</strong></h4><ol><li><p>从约束集中取反条件：</p><p>原路径约束为 <code>X &gt; 10 &amp;&amp; X &lt; 20</code>。</p><p>取反约束为 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>即：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span> || X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择其中一条路径：<code>X &lt;= 10</code>**。</p><p>求解约束 <code>X &lt;= 10</code>，求解器可能返回 <code>X = 5</code>。</p></li></ol><hr><h4 id="步骤3：探索新路径"><a href="#步骤3：探索新路径" class="headerlink" title="步骤3：探索新路径"></a><strong>步骤3：探索新路径</strong></h4><ol><li><p>使用新值 <code>x = 5</code> 实际运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">5</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>) &#123;           // 条件不成立<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>3</code>，对应<strong>路径3</strong>。</p></li><li><p>收集符号化约束：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span>  (路径<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="步骤4：继续探索未覆盖的路径"><a href="#步骤4：继续探索未覆盖的路径" class="headerlink" title="步骤4：继续探索未覆盖的路径"></a><strong>步骤4：继续探索未覆盖的路径</strong></h4><ol><li><p>再次从约束集中取反条件：</p><p>已探索的路径约束为：</p><p>​     路径1：<code>X &gt; 10 &amp;&amp; X &lt; 20</code></p><p>​     路径3：<code>X &lt;= 10</code></p><p>合并取反条件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>) &amp;&amp; !(X &lt;= <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>简化后为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择路径：<code>X &gt;= 20</code>**。</p><p>求解约束 <code>X &gt;= 20</code>，求解器可能返回 <code>X = 25</code>。</p></li><li><p>使用新值 <code>x = 25</code> 实际运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>执行路径为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件不成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>2</code>，对应<strong>路径2</strong>。</p></li></ol><hr><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h4><p>动态符号执行会重复上述过程：</p><ol><li>实际运行一个具体值。</li><li>收集符号化约束。</li><li>取反约束生成新路径。</li><li>继续探索未覆盖的路径。</li></ol><p>直到：</p><ul><li><strong>所有路径都被探索</strong>：程序的逻辑分支全部覆盖。</li><li><strong>达到用户设定的限制</strong>：例如最大路径数量、最大求解时间等。</li></ul><h2 id="angr的不足"><a href="#angr的不足" class="headerlink" title="angr的不足"></a>angr的不足</h2><h3 id="未约束导致路径爆炸"><a href="#未约束导致路径爆炸" class="headerlink" title="未约束导致路径爆炸"></a>未约束导致路径爆炸</h3><p>在符号执行中，如果函数的输入变量或状态没有被有效约束（即没有设定足够的条件），Angr 等工具会把这些变量当作符号值进行推理和执行。而未约束的变量可能会导致两方面的问题：</p><ol><li><strong>不确定的输入</strong>： 如果输入没有约束（例如，函数的参数没有指定具体的值或者范围），那么每次执行到某个条件判断时，就会有多个可能的选择。例如，假设你有一个函数，其中某个参数 <code>x</code> 的值没有明确的限制，那么在 <code>if</code> 语句中对 <code>x</code> 的判断就可能导致多个分支，每个分支都有不同的路径。</li><li><strong>无限循环</strong>： 当未约束的变量影响到循环条件时，符号执行就无法准确预测循环何时结束，因为它并不知道循环的终止条件何时成立。例如，某个循环的退出条件可能是 <code>x == 0</code>，但 <code>x</code> 是一个未约束的符号变量，Angr 并不知道 <code>x</code> 什么时候会变为 0。因此，符号执行引擎就可能会一直在这个循环中进行模拟，导致路径在循环内无限增长。</li></ol><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">void foo(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们给定一个具体的值，例如 <code>x = 10</code>，程序会在 10 次迭代后退出。</li><li>但是如果 <code>x</code> 是一个未约束的符号变量（例如，Angr 看到 <code>x</code> 是一个符号值），它就不能确定 <code>x</code> 会在什么时候达到 0，或者是否有可能永远不为 0。</li></ul><p>在符号执行中，Angr 会尝试探索所有可能的路径。在这种情况下，由于 <code>x</code> 没有约束，符号执行引擎无法推断出 <code>x</code> 何时会变为 0，因此它可能会认为该循环将永远执行下去，导致<strong>路径爆炸</strong>。</p><h4 id="路径爆炸与无限循环的关系"><a href="#路径爆炸与无限循环的关系" class="headerlink" title="路径爆炸与无限循环的关系"></a><strong>路径爆炸与无限循环的关系</strong></h4><p>路径爆炸指的是，随着未约束变量的增加，符号执行的路径数量呈指数级增长，导致无法有效地探索所有路径。无限循环是路径爆炸的一种特殊情况，通常发生在没有足够约束的情况下，符号执行无法判断循环是否终止，从而导致执行路径无法终止。</p><p>例如，当未约束的循环变量 <code>x</code> 不断变化，且影响循环的终止条件时，Angr 可能会不断生成新的路径，每个路径代表不同的 <code>x</code> 值和不同的循环迭代次数，最终导致路径数量迅速膨胀，系统无法有效处理这些路径，从而导致“卡死”。</p><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x = x - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 没有任何约束，Angr 会将其视为符号变量，可能会生成多条路径来探索 <code>x</code> 可能的值。每条路径都会尝试模拟 <code>x</code> 在每次循环中的变化，直到达到退出条件 <code>x &lt;= 0</code>。</p><p>在符号执行的过程中，Angr 会对每次 <code>x = x - 1</code> 做出决策，并生成新的路径。</p><p>如果没有足够的约束（例如，限制 <code>x</code> 的值或设置循环的最大迭代次数），Angr 可能会生成大量的路径来模拟不同的 <code>x</code> 值和循环次数，导致路径数目激增，甚至无法终止。</p><h3 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h3><p>事实上angr是基于符号执行来遍历程序的所有路径，它是否能遍历所有路径其实取决于其约束求解引擎是否强大，这里采用的是z3<br>当它能明确发现这个条件是无法满足的时候就不会走向这个路径，我们可以称之为虚假控制流。<br>但是如果程序本身的逻辑中存在一个条件是非常难以满足的，或者说超出了约束求解引擎的能力，那么则有可能到达不了这个路径，就会被误标记为虚假的控制流，实际中是很少出现的。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[动若脱兔:深入浅出angr--初步理解符号执行以及angr架构 - 0xJDchen - 博客园](https://www.cnblogs.com/0xJDchen/p/9291335.html)<br><br>[利用angr去除混淆的优势，不足与实践 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1484714-1-1.html)<br><br>[angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园](https://www.cnblogs.com/level5uiharu/p/16925991.html)<br><br>[angr - CTF Wiki](https://ctf-wiki.org/reverse/tools/simulate-execution/angr/)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Reverse(android)</category>
      
      <category>符号/模拟执行</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识JVM</title>
    <link href="/2024/12/19/%E5%88%9D%E8%AF%86JVM/"/>
    <url>/2024/12/19/%E5%88%9D%E8%AF%86JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM?"></a>什么是JVM?</h1><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。java语言跨平台的秘密</p><h1 id="Java如何被JVM所运行？"><a href="#Java如何被JVM所运行？" class="headerlink" title="Java如何被JVM所运行？"></a>Java如何被JVM所运行？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">Java 源文件 --&gt; 编译器 --&gt; .<span class="hljs-keyword">class</span>字节码文件--&gt; 类加载器--&gt;JVM<br></code></pre></td></tr></table></figure><h2 id="1-什么是-class字节码文件？"><a href="#1-什么是-class字节码文件？" class="headerlink" title="1.什么是.class字节码文件？"></a>1.什么是.class字节码文件？</h2><p>在 Java 中，JVM 可以理解的代码叫作字节码，也就是 .class 文件，它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，并且保留了解释型语言可移植的特点，而通过即时编译器（JIT）又有编译型语言执行效率高的特点。所以 Java 程序运行时比较高效，同时 Java 通过字节码文件和虚拟机之间的关系，实现了平台无关性，一次编译，各平台都可运行。</p><p><a href="https://www.cnblogs.com/code-duck/p/13568004.html#%E4%BA%8C-class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Class文件结构（详细解读） - codeduck - 博客园</a></p><h3 id="1-1-class文件与java源代码中的class类有什么联系和区别？"><a href="#1-1-class文件与java源代码中的class类有什么联系和区别？" class="headerlink" title="1.1 .class文件与java源代码中的class类有什么联系和区别？"></a>1.1 .class文件与java源代码中的class类有什么联系和区别？</h3><h2 id="2-怎么编译成-class字节码文件？"><a href="#2-怎么编译成-class字节码文件？" class="headerlink" title="2.怎么编译成.class字节码文件？"></a>2.怎么编译成.class字节码文件？</h2><p><a href="https://blog.csdn.net/weixin_44688973/article/details/125757836">Java文件是怎么编译成Class文件的_java编译成class-CSDN博客</a></p><p>答：编译原理相关，暂时略过</p><h2 id="3-类加载器工作原理"><a href="#3-类加载器工作原理" class="headerlink" title="3.类加载器工作原理"></a>3.类加载器工作原理</h2><h3 id="3-1-什么是双亲委派机制"><a href="#3-1-什么是双亲委派机制" class="headerlink" title="3.1 什么是双亲委派机制"></a>3.1 什么是双亲委派机制</h3><p>双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器。（类加载器之间的父子关系不是以继承的关系实现，而是使用组合关系来复用父加载器的代码）</p><p><img src="https://s2.loli.net/2024/10/04/Klyv9UDehVc4uNT.webp" alt="双亲委派机制"></p><p>如果类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层级的类加载器都是如此，因此所有请求最终都会被传到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。因此，加载过程可以看成自底向上检查类是否已经加载，然后自顶向下加载类。整个过程就是一个递归的过程</p><p>整个过程：</p><ol><li><strong>自定义类加载器</strong>收到类加载请求，首先检查缓存是否已经加载该类。</li><li>如果未找到，则将请求<strong>委派给父类加载器</strong>，父类加载器首先会检查自己是否已经加载过该类（调用 <code>findLoadedClass()</code>）。如果找到，则返回该类，类加载过程结束。如果找不到，则继续将请求委派给其父类加载器</li><li>逐层向上，直到最顶层的<strong>启动类加载器（Bootstrap ClassLoader）</strong>。</li><li><strong>启动类加载器</strong>检查核心类库，能加载则返回，若不能加载则返回 <code>null</code>，传递控制权回给下层加载器。它的<strong>子类加载器</strong>将获得加载类的机会，并且尝试自己去加载该类。加载成功，则类加载过程结束。如果它也无法加载，则返回 <code>null</code>，传递控制权回给下层加载器</li><li>各层加载器依次返回，若父加载器未加载到类，则最底层的<strong>自定义类加载器</strong>通过 <code>findClass()</code> 方法尝试自己加载该类。</li><li>成功加载后，类会被缓存，加载过程结束。如果所有加载器都未能加载，抛出 <code>ClassNotFoundException</code>。</li></ol><p><img src="https://s2.loli.net/2024/10/04/C1XeMY9PkpbfL5F.png" alt="双亲委派"></p><p>双亲委派模型的优点：</p><ol><li><p>使用双亲委派模型来组织类加载器之间的关系，Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p></li><li><p>避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没必要再加载一次。</p></li><li><p>解决各个类加载器的基础类的统一问题，越基础的类由越上层的加载器进行加载。避免Java核心API中的类被随意替换，规避风险，防止核心API库被随意篡改。</p></li></ol><blockquote><p>例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的 Java 类，可以正常编译，但是永远无法被加载运行。</p></blockquote><h1 id="JVM的组成与运行原理？"><a href="#JVM的组成与运行原理？" class="headerlink" title="JVM的组成与运行原理？"></a>JVM的组成与运行原理？</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">.<span class="hljs-keyword">class</span>字节码文件 --&gt; JVM --&gt; 机器码<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/12/15/zQjNwtq1Ef2UKv3.png" alt="1"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="本地方法栈和程序计数器"><a href="#本地方法栈和程序计数器" class="headerlink" title="本地方法栈和程序计数器"></a>本地方法栈和程序计数器</h3><p>native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区（method area）</strong>只是 <strong>JVM 规范</strong>中定义的一个概念，用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="虚拟机栈和虚拟机堆"><a href="#虚拟机栈和虚拟机堆" class="headerlink" title="虚拟机栈和虚拟机堆"></a>虚拟机栈和虚拟机堆</h3><blockquote><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p></blockquote><h4 id="虚拟机栈的生命周期"><a href="#虚拟机栈的生命周期" class="headerlink" title="虚拟机栈的生命周期"></a>虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="虚拟机堆的概念"><a href="#虚拟机堆的概念" class="headerlink" title="虚拟机堆的概念"></a>虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MetaspaceSize：初始化元空间大小，控制发生<span class="hljs-built_in">GC</span><br>MaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。<br></code></pre></td></tr></table></figure><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li>编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li>JVM 找到 App 的主程序入口，执行 main 方法</li><li>这个 main 中的第一条语句为 Student student &#x3D; new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li>执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li>执行 sayName()</li></ol><p><a href="https://blog.csdn.net/csdnliuxin123524/article/details/81303711">JVM原理最全、清晰、通俗讲解，五天40小时吐血整理_jvm原理讲解教程最全清晰通俗讲解-CSDN博客</a></p><p>jvm虚拟机位于操作系统的堆中，并且，程序员写好的类加载到虚拟机执行的过程是：当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader，</p><p><strong>java虚拟机的生命周期</strong>：声明周期起点是当一个java应用main函数启动时虚拟机也同时被启动，而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。</p><p><strong>java虚拟机与main方法的关系</strong>：main函数就是一个java应用的入口，main函数被执行时，java虚拟机就启动了。启动了几个main函数就启动了几个java应用，同时也启动了几个java的虚拟机。</p><p>java的虚拟机种有两种线程，一种叫叫守护线程，一种叫非守护线程（也叫普通线程），main函数就是个非守护线程，虚拟机的gc就是一个守护线程。java的虚拟机中，只要有任何非守护线程还没有结束，java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以jvm没办法退出</p><p>虚拟机的gc（垃圾回收机制）就是一个典型的守护线程。</p><p><img src="https://s2.loli.net/2024/12/16/Vc3OL6JyM5qvz8T.png" alt="fdb281da8c98cc1240281d4520bc947f"></p><h2 id="1-JVM如何将-class字节码文件转化为对应机器的机器码"><a href="#1-JVM如何将-class字节码文件转化为对应机器的机器码" class="headerlink" title="1.JVM如何将.class字节码文件转化为对应机器的机器码"></a>1.JVM如何将.class字节码文件转化为对应机器的机器码</h2><p><a href="https://javaguide.cn/java/jvm/jvm-intro.html">大白话带你认识 JVM | JavaGuide</a></p><p><img src="https://s2.loli.net/2024/12/15/2SNXkfbxFtVypJ7.webp" alt="c602f57ea9297f50bbc265f1821d6263"></p><p><a href="https://www.doc200.com/java-interview/JVM/%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9FJVM%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%EF%BC%9F.html">8. 什么是Java字节码？JVM如何将字节码转换为机器代码？ | 胖虎Docs</a></p><p>JVM将字节码转换为机器代码的过程主要依赖于其执行引擎。执行引擎负责解释和执行字节码，并将其转换为底层的机器代码，以便在物理硬件上执行。这个过程分为两个主要部分：解释执行和即时编译（JIT）。</p><h4 id="1-解释执行"><a href="#1-解释执行" class="headerlink" title="1. 解释执行"></a>1. 解释执行</h4><p>解释器是JVM的一个组件，它逐行解释字节码，并将其转换为对应的机器码指令，然后在处理器上执行。</p><p>工作原理</p><ul><li>JVM启动时，解释器开始工作，读取字节码指令，并解释成相应的机器码指令。</li><li>每条字节码指令都通过解释器进行解释，然后立即执行。这种方式简单直接，但对于频繁执行的代码（如循环体）效率较低。</li></ul><p>优点</p><ul><li>启动快，解释器立即可以开始执行字节码。</li><li>对于短期任务，解释器可以快速响应。</li></ul><p>缺点</p><ul><li>对于重复执行的代码，解释效率较低，因为每次循环都要重新解释相同的字节码。</li></ul><h4 id="2-即时编译"><a href="#2-即时编译" class="headerlink" title="2. 即时编译"></a>2. 即时编译</h4><p>为了提升程序的运行效率，JVM引入了JIT编译器。JIT编译器在程序运行时将热点代码（频繁执行的代码）编译为本地机器码，并将其缓存起来，以避免重复解释相同的字节码。</p><p>工作原理</p><ul><li>JVM在解释执行字节码的过程中，识别出哪些方法或代码块被频繁执行，称为“热点代码”。</li><li>JIT编译器将这些热点代码一次性编译为平台相关的机器码，存储在内存中。</li><li>当热点代码再次被执行时，JVM直接使用编译后的机器码，而不是通过解释器逐行解释，从而大幅提升执行效率。</li></ul><p>优点</p><ul><li>提升性能：JIT编译后的代码直接以机器码形式执行，性能接近于本地编译的程序。</li><li>逐渐优化：JIT编译器可以随着程序的运行，动态调整和优化编译策略。</li></ul><p>缺点</p><ul><li>编译开销：JIT编译会占用一些系统资源，在程序启动的初期可能导致响应变慢。</li><li>内存占用：编译后的机器码需要在内存中保存。</li></ul><h3 id="JVM的执行模式"><a href="#JVM的执行模式" class="headerlink" title="JVM的执行模式"></a>JVM的执行模式</h3><p>JVM在实际运行过程中，可能会采用解释执行和JIT编译的混合模式。在程序刚启动时，JVM可能更多依赖解释器，而当程序运行时间较长、热点代码较多时，JIT编译器将逐步接管更多的工作，从而提升整体运行效率。</p><h3 id="1-1-什么是Just-In-Time-JIT-编译器？"><a href="#1-1-什么是Just-In-Time-JIT-编译器？" class="headerlink" title="1.1 什么是Just-In-Time (JIT) 编译器？"></a>1.1 什么是Just-In-Time (JIT) 编译器？</h3><p><a href="https://blog.csdn.net/Genmer/article/details/119355224">关于Java的JIT(即时编译器)知识整理_java jit-CSDN博客</a></p><p>解释执行：解释执行是采用匹配执行解释器（解释器是个黑盒，通常也有编译器的组成部分）内部已经编译好的机器码，不是生成新的机器码（也有说法是逐条翻译成机器码？）。 - 由于逐条翻译，程序启动快，但是执行效率不高。</p><p>编译执行：运行期间，通过将字节码编译成对应的新的机器码（会将其缓存起来，通过参数-XX:ReservedCodeCacheSize），然后执行。 - 需要先编译出新的机器指令，所以程序启动较慢，但是执行效率高（因为执行的是机器指令）。</p><p>后来因为解释执行必然比执行编译好的机器指令的执行效率低，所以引入JIT（即时编译器）。在执行时，JIT会把翻译过的机器码保存起来，已备下次使用，因此从理论上来说，采用JIT技术能够在执行效率上，接近曾经纯编译技术。</p><p><strong>当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译的时间，立即执行</strong>；当程序运行后，随着时间的推移，<strong>编译器逐渐会返回作用，把越来越多的代码编译成本地代码后，可以获取更高的执行效率</strong>。解释执行可以节约内存，而编译执行可以提升效率。</p><p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html">基本功 | Java即时编译器原理解析及实践 - 美团技术团队</a></p><p><img src="https://s2.loli.net/2024/12/16/ztKTYcNZlQoOGVg.png" alt="ba83857ecf9f344e4972fd551c4973d653952"></p><p><a href="https://javabetter.cn/jvm/jit.html">10 张手绘图 8000 字深入理解 JIT（即时编译器） | 二哥的Java进阶之路</a></p><p><a href="https://www.cnblogs.com/dzhou/p/9549839.html">什么是JIT，写的很好 - ddzh2020 - 博客园</a></p><h2 id="2-GC垃圾回收算法"><a href="#2-GC垃圾回收算法" class="headerlink" title="2.GC垃圾回收算法"></a>2.GC垃圾回收算法</h2><p>暂时略过</p><p><a href="https://blog.csdn.net/Pireley/article/details/134315943">Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器_java的内存模型以及gc算法-CSDN博客</a></p><h1 id="JVM如何与操作系统交互？"><a href="#JVM如何与操作系统交互？" class="headerlink" title="JVM如何与操作系统交互？"></a>JVM如何与操作系统交互？</h1><h2 id="1-什么是JNI"><a href="#1-什么是JNI" class="headerlink" title="1.什么是JNI?"></a>1.什么是JNI?</h2><p>JNI（Java Native Interface，Java本地接口）是 Java 提供的一种接口，允许 Java 程序调用本地（Native）代码或被本地代码调用。所谓本地代码通常是用 C 或 C++ 等语言编写的，并直接与底层硬件或操作系统交互。</p><h2 id="2-JNI工作原理？"><a href="#2-JNI工作原理？" class="headerlink" title="2.JNI工作原理？"></a>2.JNI工作原理？</h2><img src="https://s2.loli.net/2024/12/19/RfgdDQ4ilBIpA8O.jpg" alt="4403ab758e8ee449292962c2ec050ba6" style="zoom:50%;" /><h3 id="Java-调用-Native-代码"><a href="#Java-调用-Native-代码" class="headerlink" title="Java 调用 Native 代码"></a><strong>Java 调用 Native 代码</strong></h3><h4 id="为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？"><a href="#为什么-java文件直接调用最下层的-cpp不就可以了，为什么中间又一层-cpp代码呢？" class="headerlink" title="为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？"></a>为什么.java文件直接调用最下层的.cpp不就可以了，为什么中间又一层.cpp代码呢？</h4><p>这也就是JNI层的表现形式，中间的<strong>JNI层其实也是C++代码，它的作用就是桥梁，在这个C++代码中我们可以调用Java层代码也可以调用Native层的C++代码(天然可以，都是C++)<strong>。由于这里特殊的C++代码，可以把俩种混调用(Java和C++)，所以</strong>JNI有它自己的类型</strong>。例如：</p><ul><li><code>int</code> → <code>jint</code></li><li><code>boolean</code> → <code>jboolean</code></li></ul><p><img src="https://s2.loli.net/2024/12/19/ZSuBchRUQf8GF4O.jpg" alt="3fbc8cdc00c9070bffc0f094ae7792e3"></p><h4 id="本地实现函数的命名规则"><a href="#本地实现函数的命名规则" class="headerlink" title="本地实现函数的命名规则"></a>本地实现函数的命名规则</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- 前缀“Java_”。</span><br><span class="hljs-deletion">- 类的全名。</span><br><span class="hljs-deletion">- 下划线分隔符“_”。</span><br><span class="hljs-deletion">- 方法名字。</span><br><span class="hljs-deletion">- 有方法重载的情况时，还会有两个下划线（“__”），后面跟着参数描述符。</span><br></code></pre></td></tr></table></figure><p>假设 Java 类 <code>com.example.MyClass</code> 中有如下的本地方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>对应的本地方法 C 实现会是：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">JNIEXPORT </span>void <span class="hljs-keyword">JNICALL </span><span class="hljs-keyword">Java_com_example_MyClass_doSomething(JNIEnv </span>*, <span class="hljs-keyword">jobject);</span><br></code></pre></td></tr></table></figure><p>这样，通过 JNI 约定的命名规则，虚拟机可以根据 Java 方法的名称和参数生成与之匹配的本地方法名称，从而成功调用 C&#x2F;C++ 实现的本地方法。</p><h4 id="类加载器与本地库的关系"><a href="#类加载器与本地库的关系" class="headerlink" title="类加载器与本地库的关系"></a><strong>类加载器与本地库的关系</strong></h4><h5 id="1-本地库绑定到类加载器"><a href="#1-本地库绑定到类加载器" class="headerlink" title="(1) 本地库绑定到类加载器"></a><strong>(1) 本地库绑定到类加载器</strong></h5><ul><li>当一个类调用 <code>System.loadLibrary</code> 或 <code>System.load</code> 加载本地库时，该本地库会被绑定到加载该类的类加载器。</li><li>JVM 会确保一个本地库在同一个类加载器中只加载一次。</li><li>如果两个不同的类加载器加载同一个本地库，会导致冲突或错误。</li></ul><h5 id="2-本地方法的作用域"><a href="#2-本地方法的作用域" class="headerlink" title="(2) 本地方法的作用域"></a><strong>(2) 本地方法的作用域</strong></h5><ul><li>本地库中的方法仅在加载该库的类加载器和其加载的类中可用。</li><li>如果不同类加载器的类需要共享同一个本地库，则需要注意：<ul><li>本地库必须显式加载一次，并由共享的类加载器负责。</li><li>否则可能引发 <code>UnsatisfiedLinkError</code>。</li></ul></li></ul><p><strong>(3) 自定义类加载器的影响</strong></p><p>如果使用自定义类加载器加载一个类，并在该类中调用本地方法：</p><ul><li>自定义类加载器的作用域会限制本地库的使用。</li><li>需要确保本地库文件在正确的路径中，或者显式调用 <code>System.load</code> 指定绝对路径。</li></ul><h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><h5 id="类加载器与本地库的关联"><a href="#类加载器与本地库的关联" class="headerlink" title="类加载器与本地库的关联"></a>类加载器与本地库的关联</h5><p>类加载器在加载 Java 类的字节码（<code>.class</code> 文件）如果发现：</p><ul><li><p><strong>显式关联：</strong> 使用 <code>System.loadLibrary()</code> 或 <code>System.load()</code> 函数显式加载本地库。</p><p>例如，如果 Java 类 <code>MyClass</code> 需要调用一个本地方法 <code>nativeMethod()</code>，则在 <code>static</code> 块或类初始化过程中，可能会显式调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.loadLibrary(<span class="hljs-string">&quot;mylibrary&quot;</span>);  <span class="hljs-comment">// 显式加载名为 &quot;mylibrary&quot; 的本地库</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeMethod</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>System.loadLibrary(&quot;mylibrary&quot;)</code> 会将名为 <code>&quot;mylibrary&quot;</code> 的本地库与 <code>MyClass</code> 关联。这时，类加载器就会知道需要加载哪个本地库。</p></li><li><p><strong>隐式关联：</strong> 本地库的加载通常在第一次调用本地方法时自动发生。此时，JVM 会在类加载器关联的路径中搜索本地库，并加载适当的本地库。</p><p>例如，当第一次调用 <code>nativeMethod()</code> 时，JVM 会查找并加载该方法对应的本地库。类加载器会使用它的 <code>nativeLibrary</code> 搜索路径来找到相应的本地库。</p></li></ul><h5 id="类加载器如何与本地库关联"><a href="#类加载器如何与本地库关联" class="headerlink" title="类加载器如何与本地库关联"></a>类加载器如何与本地库关联</h5><p>加载器会维护一个本地库搜索路径，来查找它关联的本地库。这个路径通常是在启动 Java 程序时通过环境变量、Java 参数或类加载器配置进行设置的。类加载器的本地库搜索路径包括：</p><p><strong>系统路径：</strong> 默认情况下，JVM 会在操作系统的标准路径（如 <code>PATH</code> 环境变量中的路径，Windows 上的 <code>.dll</code> 文件路径，Unix&#x2F;Linux 上的 <code>.so</code> 文件路径）中查找本地库。</p><p><strong>指定路径：</strong> 当调用 <code>System.loadLibrary()</code> 时，本地库路径可能会通过 JVM 参数传递（例如 <code>-Djava.library.path</code>）。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">java -Djava.<span class="hljs-keyword">library</span>.path=/path/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">library</span> MyClass<br></code></pre></td></tr></table></figure><p>在这个例子中，JVM 会使用 <code>-Djava.library.path</code> 参数指定的路径来搜索本地库。</p><p><strong>类加载器路径：</strong> 每个类加载器（比如 <code>AppClassLoader</code> 或自定义的类加载器）也可能有自己独立的路径来加载本地库。这个路径由类加载器的实现决定。</p><h5 id="本地库加载的时机"><a href="#本地库加载的时机" class="headerlink" title="本地库加载的时机"></a>本地库加载的时机</h5><p>本地库的加载通常发生在第一次调用本地方法时，即在 <strong>链接本地方法时</strong>。这个过程分为几个步骤：</p><ol><li><strong>类加载：</strong> 当 JVM 加载包含本地方法的类时，它会检查该类是否包含 <code>native</code> 方法。如果包含，JVM 就会在后续的调用中解析这个本地方法。</li><li><strong>本地方法调用：</strong> 当 Java 代码首次调用 <code>native</code> 方法时，JVM 会尝试加载与该方法相关联的本地库。</li><li><strong>本地库加载：</strong> JVM 会根据类加载器的配置，搜索本地库。如果找到相应的本地库，JVM 就会将本地方法与本地库中的实现绑定，并建立关联。</li><li><strong>链接成功：</strong> 一旦本地方法被链接，JVM 会创建内部的数据结构（如函数指针或本地方法的映射表），使得后续的调用可以直接跳转到本地库中的对应函数。</li></ol><h3 id="Native-代码调用-Java"><a href="#Native-代码调用-Java" class="headerlink" title="Native 代码调用 Java"></a><strong>Native 代码调用 Java</strong></h3><h4 id="JNIEnv接口指针"><a href="#JNIEnv接口指针" class="headerlink" title="JNIEnv接口指针"></a>JNIEnv接口指针</h4><p>本地代码通过JNIEnv接口指针里暴露的方法来使用虚拟机的功能。</p><p>JNIEnv是一个指向本地线程数据的接口指针，这个指针里面包含了一个指向函数表的指针。每一个接口函数在这表中都有一个 预定义的偏移位置。JNIEnv很像一个C++虚函数表或者Microsoft COM接口。</p><p><img src="https://s2.loli.net/2024/12/19/ZtgFubyJGQTnYMv.png" alt="jnienv"></p><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p>像int、char等这样的基本数据类型，在本地代码和JVM之间进行复制传递，而对象是引用传递的。每一个引用都包含一个指向JVM 中相应的对象的指针，但本地代码不能直接使用这个指针，必须通过引用来间接使用。<br>比起传递直接指针来说，传递引用可以让VM更灵活地管理对象。</p><h5 id="局部引用与全局引用"><a href="#局部引用与全局引用" class="headerlink" title="局部引用与全局引用"></a>局部引用与全局引用</h5><p>JNI可以为本地代码创建两种对象引用：局部引用和全局引用。局部引用的有效期是本地方法的调用期间，调用完成后，局部引用 会被JVM自动铲除。而全局引用，除非显示释放它，否则将一直存在。<br>JVM中的对象作为参数传递给本地方法时，用的是局部引用。大部分的JNI函数返回局部引用。JNI允许程序员从局部引用创建一个 全局引用。接受对象作为参数的JNI函数既支持全局引用也支持局部引用。本地方法执行完毕后，向JVM返回结果时，它可能向JVM 返回局部引用，也可能返回全局引用。<br>局部引用只在创建它的线程内部有效。本地代码不能跨线程传递和使用局部引用。<br>JNI中的NULL引用指向JVM中的null对象。对一个全局引用或者局部引用来说，只要它的值不是NULL，它就不会指向一个null对象。</p><h5 id="局部引用的实现"><a href="#局部引用的实现" class="headerlink" title="局部引用的实现"></a>局部引用的实现</h5><p>一个对象从JVM传递给本地方法时，就把控制权移交了过去，JVM会为每一个对象的传递创建一条记录，一条记录就是一个本地代码 中的引用和JVM中的对象的一个映射。记录中的对象不会被GC回收。所有传递到本地代码中的对象和从JNI函数返回的对象都被自动 地添加到映射表中。当本地方法返回时，VM会删除这些映射，允许GC回收记录中的数据。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用所指向的对象允许JVM回收，当对象被回收以后，弱引用也会被清除。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://blog.csdn.net/Delilah_java/article/details/119778422">一篇JVM详细图解，坚持看完！带你真正搞懂Java虚拟机！_jvm图解-CSDN博客</a></p><p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程_java jni-CSDN博客</a></p><p><a href="https://luori366.github.io/JNI_doc/jni_design_theory.html">JNI的作用与工作原理 | JNI_doc</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android系统启动流程</title>
    <link href="/2024/12/12/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/12/12/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="android整体架构图"><a href="#android整体架构图" class="headerlink" title="android整体架构图"></a>android整体架构图</h1><p><img src="https://s2.loli.net/2024/12/20/NiF83nBS4sItpYR.png" alt="android整体架构"></p><p>可以看出android系统是基于底层linux构建的。也正因如此，android系统启动的起点在linux启动后的用户空间的第一个进程init，进程号为1.当bootloader启动后，启动kernel，kernel启动完后，在用户空间启动init进程。</p><p>倘若再往上走就是linux启动过程，具体可自行百度linux启动流程。</p><ul><li><strong>1.引导加载程序（Bootloader）启动</strong>： 当设备上电或者重启时，首先会由引导加载程序负责启动。引导加载程序通常存储在设备的固件中，它的主要任务是初始化硬件，并加载并启动操作系统内核。引导加载程序会首先运行自身的初始化代码，然后加载操作系统内核到内存中。</li><li><strong>2.内核加载</strong>： 引导加载程序会根据预定义的配置从设备存储中加载操作系统内核。在Android设备中，通常使用的是Linux内核。引导加载程序将内核加载到内存中的指定位置。</li><li><strong>3.内核初始化</strong>： 一旦内核加载到内存中，引导加载程序会将控制权转交给内核。内核开始执行初始化过程，包括对硬件进行初始化、建立虚拟文件系统、创建进程和线程等。</li><li><strong>4.启动 init 进程</strong>： 内核初始化完成后，会启动名为init的用户空间进程。init进程是Android系统的第一个用户空间进程，它负责系统的进一步初始化和启动。init进程会读取系统配置文件（例如 init.rc），并根据其中的指令启动系统服务和应用程序。</li></ul><h1 id="Init进程"><a href="#Init进程" class="headerlink" title="Init进程"></a>Init进程</h1><p><img src="https://s2.loli.net/2024/10/08/3YcVQto2GbqMzCN.png" alt="Android系统启动流程"></p><p>根据不同的入参，响应init不同阶段、处理不同业务逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;ueventd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> ueventd_main(argc, argv);<br>    &#125;<br>    <span class="hljs-comment">////watchdogd俗称看门狗，用于系统出问题时重启系统</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strcmp</span>(basename(argv[<span class="hljs-number">0</span>]), <span class="hljs-string">&quot;watchdogd&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> watchdogd_main(argc, argv);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;subcontext&quot;</span>)) &#123;<br>        InitKernelLogging(argv);<br>        <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>        <span class="hljs-keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);<br>    &#125;<br>    <span class="hljs-comment">//如果设置了 REBOOT_BOOTLOADER_ON_PANIC，则安装重启信号处理器，确保在系统崩溃时能够重启进入 bootloader 模式。</span><br>    <span class="hljs-keyword">if</span> (REBOOT_BOOTLOADER_ON_PANIC) &#123;<br>        InstallRebootSignalHandlers();<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ol><li>挂载文件系统并创建目录</li><li>初始化日志输出、挂载分区设备</li><li>启用SELinux安全策略</li><li>开始第二阶段前的准备</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    ...<br>    <span class="hljs-type">bool</span> is_first_stage = (getenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>) == nullptr);<br>    <span class="hljs-comment">// 在第一阶段，初始化基本的文件系统，并创建和挂载必要的系统目录</span><br>    <span class="hljs-keyword">if</span> (is_first_stage) &#123;<br>        boot_clock::time_point start_time = boot_clock::now();<br>        umask(<span class="hljs-number">0</span>);<br>        clearenv();<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/dev&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOSUID, <span class="hljs-string">&quot;mode=0755&quot;</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-number">0755</span>);<br>        mkdir(<span class="hljs-string">&quot;/dev/socket&quot;</span>, <span class="hljs-number">0755</span>);<br>        mount(<span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-string">&quot;/dev/pts&quot;</span>, <span class="hljs-string">&quot;devpts&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_STR(x) __STRING(x)</span><br>        mount(<span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-string">&quot;/proc&quot;</span>, <span class="hljs-string">&quot;proc&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;hidepid=2,gid=&quot;</span> MAKE_STR(AID_READPROC));<br>        chmod(<span class="hljs-string">&quot;/proc/cmdline&quot;</span>, <span class="hljs-number">0440</span>);<br>        <span class="hljs-type">gid_t</span> groups[] = &#123; AID_READPROC &#125;;<br>        setgroups(arraysize(groups), groups);<br>        mount(<span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-string">&quot;/sys&quot;</span>, <span class="hljs-string">&quot;sysfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mount(<span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-string">&quot;/sys/fs/selinux&quot;</span>, <span class="hljs-string">&quot;selinuxfs&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>        mknod(<span class="hljs-string">&quot;/dev/kmsg&quot;</span>, S_IFCHR | <span class="hljs-number">0600</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">constexpr</span> <span class="hljs-params">(WORLD_WRITABLE_KMSG)</span> &#123;<br>            mknod(<span class="hljs-string">&quot;/dev/kmsg_debug&quot;</span>, S_IFCHR | <span class="hljs-number">0622</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>));<br>        &#125;<br>        <span class="hljs-comment">//创建 /dev/kmsg、/dev/random、/dev/urandom 等设备节点，用于日志和随机数生成。</span><br>        mknod(<span class="hljs-string">&quot;/dev/random&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>));<br>        mknod(<span class="hljs-string">&quot;/dev/urandom&quot;</span>, S_IFCHR | <span class="hljs-number">0666</span>, makedev(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>));<br>        mount(<span class="hljs-string">&quot;tmpfs&quot;</span>, <span class="hljs-string">&quot;/mnt&quot;</span>, <span class="hljs-string">&quot;tmpfs&quot;</span>, MS_NOEXEC | MS_NOSUID | MS_NODEV,<br>        mkdir(<span class="hljs-string">&quot;/mnt/vendor&quot;</span>, <span class="hljs-number">0755</span>);<br>        <span class="hljs-comment">//初始化log系统并打印</span><br>        InitKernelLogging(argv);<br>        ......<br>        <span class="hljs-comment">//初始化Android的安全框架Android Verified Boot</span><br>        SetInitAvbVersionInRecovery();<br>        global_seccomp();<br>        ...<br>        <span class="hljs-comment">// Set up SELinux, loading the SELinux policy.</span><br>        <span class="hljs-comment">//为第二阶段启动加载安全策略(安全策略：一个Linux内核模块和安全架构，旨在提供更细粒度的访问控制)</span><br>        SelinuxSetupKernelLogging();<br>        SelinuxInitialize();<br>        ...<br>        <span class="hljs-comment">//设置第二阶段开关</span><br>        setenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">static</span> constexpr <span class="hljs-type">uint32_t</span> kNanosecondsPerMillisecond = <span class="hljs-number">1e6</span>;<br>        <span class="hljs-type">uint64_t</span> start_ms = start_time.time_since_epoch().count() / kNanosecondsPerMillisecond;<br><br><span class="hljs-comment">//设置环境变量 INIT_SECOND_STAGE 并重新执行 init 进程，进入第二阶段。</span><br>        setenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>, <span class="hljs-built_in">std</span>::to_string(start_ms).c_str(), <span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span>* path = argv[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span>* args[] = &#123; path, nullptr &#125;;<br>        execv(path, args);<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;execv(\&quot;&quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;\&quot;) failed&quot;</span>;<br>    &#125;<br>              <br> &#125;<br>   <br></code></pre></td></tr></table></figure><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><ol><li>初始化属性系统</li><li>执行SELinux第二阶段并恢复一些文件安全上下文</li><li>新建epoll并初始化子进程终止信号处理函数</li><li>设置其他系统属性并开启属性服务</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">//初始化属性系统</span><br>   <span class="hljs-comment">//继续初始化日志、属性系统和内核命令行参数，并准备系统启动。</span><br>    InitKernelLogging(argv);<br>    ....<br>    <span class="hljs-comment">//property系统用于管理系统属性</span><br>    process_kernel_dt();<br>    process_kernel_cmdline();<br><br>    export_kernel_boot_props();<br><br>    property_set(<span class="hljs-string">&quot;ro.boottime.init&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>));<br>    property_set(<span class="hljs-string">&quot;ro.boottime.init.selinux&quot;</span>, getenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>));<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* avb_version = getenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br>    <span class="hljs-keyword">if</span> (avb_version) property_set(<span class="hljs-string">&quot;ro.boot.avb_version&quot;</span>, avb_version);<br>    <span class="hljs-comment">// Clean up our environment.</span><br>    unsetenv(<span class="hljs-string">&quot;INIT_SECOND_STAGE&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_STARTED_AT&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_SELINUX_TOOK&quot;</span>);<br>    unsetenv(<span class="hljs-string">&quot;INIT_AVB_VERSION&quot;</span>);<br><br>    <span class="hljs-comment">//加载 SELinux 策略</span><br>    SelinuxSetupKernelLogging();<br>    SelabelInitialize();<br>    SelinuxRestoreContext();<br>    <span class="hljs-comment">//启动 epoll 等待系统事件(设置 epoll 文件描述符，用于监听系统事件，并启动属性服务和信号处理。)</span><br>    epoll_fd = epoll_create1(EPOLL_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (epoll_fd == <span class="hljs-number">-1</span>) &#123;<br>        PLOG(FATAL) &lt;&lt; <span class="hljs-string">&quot;epoll_create1 failed&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">//来初始化信号处理过程</span><br>    sigchld_handler_init();<br><br>    <span class="hljs-keyword">if</span> (!IsRebootCapable()) &#123;<br>    <br>        InstallSigtermHandler();<br>    &#125;<br>    <span class="hljs-comment">//设置其他系统属性并开启属性服务</span><br>    property_load_boot_defaults();<br>    export_oem_lock_status();<br>    start_property_service();<br>    set_usb_controller();<br>    ...<br>    <span class="hljs-type">const</span> BuiltinFunctionMap function_map;<br>    Action::set_function_map(&amp;function_map);<br><br>   <span class="hljs-comment">// Android 中负责管理子上下文</span><br>    subcontexts = InitializeSubcontexts();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h2><ol><li>通过init.rc机制，读取配置文件，来启动不同的进程。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>    <span class="hljs-comment">//通常负责管理系统中的各种动作或命令, 解析init.rc等文件，建立rc文件的action 、service，启动其他进程</span><br>    <span class="hljs-comment">//ActionManager 和 ServiceList 管理系统中的命令和服务，初始化并触发系统的启动事件和动作。</span><br>    ActionManager&amp; am = ActionManager::GetInstance();<br><span class="hljs-comment">//负责管理系统中所有的服务</span><br>    ServiceList&amp; sm = ServiceList::GetInstance();<br><br>    <span class="hljs-comment">//加载脚本文件命令</span><br>    LoadBootScripts(am, sm);<br><br>    ...<br><br>   <span class="hljs-comment">//进入主循环，使用 epoll_wait 监听系统事件，并执行相应的系统命令和服务操作。</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// By default, sleep until something happens.</span><br>        <span class="hljs-type">int</span> epoll_timeout_ms = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-keyword">if</span> (do_shutdown &amp;&amp; !shutting_down) &#123;<br>            do_shutdown = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (HandlePowerctlMessage(shutdown_command)) &#123;<br>                shutting_down = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            am.ExecuteOneCommand();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(waiting_for_prop || Service::is_exec_service_running())) &#123;<br>            <span class="hljs-keyword">if</span> (!shutting_down) &#123;<br>                <span class="hljs-keyword">auto</span> next_process_restart_time = RestartProcesses();<br>                <span class="hljs-keyword">if</span> (next_process_restart_time) &#123;<br>                    epoll_timeout_ms = <span class="hljs-built_in">std</span>::chrono::<span class="hljs-built_in">ceil</span>&lt;<span class="hljs-built_in">std</span>::chrono::milliseconds&gt;(<br>                                           *next_process_restart_time - boot_clock::now())<br>                                           .count();<br>                    <span class="hljs-keyword">if</span> (epoll_timeout_ms &lt; <span class="hljs-number">0</span>) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (am.HasMoreCommands()) epoll_timeout_ms = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        epoll_event ev;<br>        <span class="hljs-type">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="hljs-number">1</span>, epoll_timeout_ms));<br>        <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">-1</span>) &#123;<br>            PLOG(ERROR) &lt;&lt; <span class="hljs-string">&quot;epoll_wait failed&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nr == <span class="hljs-number">1</span>) &#123;<br>            ((<span class="hljs-type">void</span> (*)()) ev.data.ptr)();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="init-rc脚本"><a href="#init-rc脚本" class="headerlink" title="init.rc脚本"></a><code>init.rc</code>脚本</h3><p><img src="https://s2.loli.net/2024/12/20/kTpboDfICxgNz1Q.png" alt="image-20241008120230933"></p><p><strong>service zygote &#x2F;system&#x2F;bin&#x2F;app_process -Xzygote &#x2F;system&#x2F;bin –zygote –start-system-server</strong>:</p><ul><li><strong>service zygote</strong>: 定义一个名为zygote的服务</li><li><strong>&#x2F;system&#x2F;bin&#x2F;app_process</strong>：这是启动Zygote进程的可执行文件，64位系统为<code>app_process64</code>。</li><li><strong>-Xzygote</strong>：标志表明这是一个Zygote进程启动的特殊模式。</li><li><strong>&#x2F;system&#x2F;bin</strong>：指定进程的工作目录。</li><li><strong>–zygote</strong>：告诉app_process以Zygote模式启动。</li><li><strong>–start-system-server</strong>：Zygote启动时还要启动System Server进程，这是Android系统中管理关键系统服务的核心进程。</li></ul><p><strong>class main</strong>:</p><ul><li>将Zygote服务归类为main类别。</li><li>Android系统在启动过程中会启动所有“main”类别的服务。</li></ul><p><strong>socket zygote stream 660 root system</strong>:<br>创建了一个名为zygote的UNIX域Socket套接字，用于其他进程与Zygote进程通信。</p><p><strong>onrestart write &#x2F;sys&#x2F;android_power&#x2F;request_state wake</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;android_power&#x2F;request_state”文件的内容设置为“wake”，以唤醒设备。</p><p><strong>onrestart write &#x2F;sys&#x2F;power&#x2F;state on</strong>：<br>当zygote服务重启时，系统应该将“&#x2F;sys&#x2F;power&#x2F;state”文件的内容设置为 “on”，以打开电源。</p><p><strong>onrestart restart media</strong>：<br>当zygote服务重启时，系统应该重启媒体服务（如音频、视频等），以恢复媒体功能。</p><p><strong>onrestart restart netd</strong>：<br>当zygote服务重启时，系统应该重启网络守护进程（netd），以恢复网络功能。</p><h1 id="Zygote进程"><a href="#Zygote进程" class="headerlink" title="Zygote进程"></a>Zygote进程</h1><p>在上一节，可以看到在启动 app_process中，启动zygote了进程，并同时启动了诸如audioserver、cameraserver、media等服务。</p><h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a><code>main</code>方法</h2><p><code>app_process</code>主入口点是<code>main</code>方法，它是整个进程启动流程的起点。</p><p>通过解析rc文件参数，启动ZygoteInit。</p><p><img src="https://s2.loli.net/2024/10/08/md2z6wo5qugXxY8.png" alt="image-20241008194103840"></p><h2 id="AppRuntime类-AndroidRuntime"><a href="#AppRuntime类-AndroidRuntime" class="headerlink" title="AppRuntime类(AndroidRuntime)"></a><code>AppRuntime</code>类(AndroidRuntime)</h2><p><strong>AppRuntime</strong>继承自<strong>AndroidRuntime</strong>(ART)，是Android中的一个关键类，负责管理和启动 Android 应用程序或系统服务的 Java 虚拟机 (JVM)。</p><p><img src="https://s2.loli.net/2024/10/08/htVWoFqQnzSuYyL.png" alt="image-20241008194008645"></p><p><img src="https://s2.loli.net/2024/10/08/3pqmgrcHeWozPQx.png" alt="image-20241008194040488"></p><p><code>app_process</code>的main方法调用了<code>AppRuntime</code>的start方法，也就是<code>AppRuntime</code>的父类<code>AndroidRuntime</code>的start方法</p><p><img src="https://s2.loli.net/2024/10/08/dZTmxI2Yy8kz1tM.png" alt="image-20241008194334607"></p><p>通过JNI调用ZygoteInit.main()</p><p><img src="https://s2.loli.net/2024/10/08/IzisVvtlSMXnOaE.png" alt="image-20241008194356872"></p><h2 id="ZygoteInit-main"><a href="#ZygoteInit-main" class="headerlink" title="ZygoteInit.main()"></a>ZygoteInit.main()</h2><p>在<code>AndroidRuntime</code>的<strong>start</strong>方法，通过JNI调用ZygoteInit.main()，系统第一次进入Java层(ZygoteInit是系统运行的第一个Java类)，当前线程也正式成为Java虚拟机（JVM）的主线程。</p><p><img src="https://s2.loli.net/2024/10/08/RgeblPvEmN8SAQ3.png" alt="image-20241008194450720"></p><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241008194506579.png" alt="image-20241008194506579"></p><p><img src="https://s2.loli.net/2024/10/08/JMYWoLXnjBU49V1.png" alt="image-20241008194607975"></p><p><img src="https://s2.loli.net/2024/10/08/pc7S2BMIEv4QqCW.png" alt="image-20241008194639231"></p><p>整体流程图：</p><p><img src="https://s2.loli.net/2024/10/08/WKLGhCXSPNOwpg4.png" alt="753d2faffdc5f60b5e5d98fd108d4421"></p><h1 id="SystemServer进程"><a href="#SystemServer进程" class="headerlink" title="SystemServer进程"></a>SystemServer进程</h1><p>Android系统在启动的时候,在启动两个重要的进程，一个是Zygote进程，另一个是由zygote进程fork出来的system_server进程。SystemSever负责启动系统的各项服务，Android系统中Java世界的核心Service都在这里启动。比如：</p><table><thead><tr><th>服务名称</th><th>功能说明</th></tr></thead><tbody><tr><td>Activity Manager Service (AMS)</td><td>管理应用程序的生命周期，包括启动和停止应用、管理任务和活动栈、处理广播等</td></tr><tr><td>Package Manager Service (PMS)</td><td>管理应用包的安装、卸载、更新、权限分配等</td></tr><tr><td>System Config Service</td><td>管理系统配置和资源</td></tr><tr><td>Power Manager Service</td><td>管理设备的电源状态和电源策略，如休眠、唤醒等</td></tr><tr><td>Display Manager Service</td><td>管理显示设备，如屏幕亮度、显示模式等</td></tr><tr><td>User Manager Service</td><td>管理用户账户和用户信息</td></tr><tr><td>Battery Service</td><td>监控和管理电池状态和电池使用情况</td></tr><tr><td>Vibrator Service</td><td>控制设备的振动功能</td></tr><tr><td>Sensor Service</td><td>管理设备的传感器，如加速度计、陀螺仪等</td></tr><tr><td>Window Manager Service (WMS)</td><td>管理窗口和显示内容，包括窗口的创建、删除、布局等</td></tr><tr><td>Input Manager Service</td><td>管理输入设备，如触摸屏、键盘等</td></tr><tr><td>Alarm Manager Service</td><td>提供定时任务调度功能</td></tr><tr><td>Connectivity Service</td><td>管理网络连接，如 Wi-Fi、移动数据等</td></tr><tr><td>Network Management Service</td><td>管理网络接口和网络连接</td></tr><tr><td>Telephony Registry</td><td>管理电话和短信服务</td></tr><tr><td>Input Method Manager Service (IMMS)</td><td>管理输入法框架</td></tr><tr><td>Accessibility Manager Service</td><td>管理无障碍服务，为有特殊需要的用户提供辅助功能</td></tr><tr><td>Mount Service</td><td>管理存储设备的挂载和卸载</td></tr><tr><td>Location Manager Service</td><td>管理位置服务，如 GPS 和网络定位</td></tr><tr><td>Search Manager Service</td><td>管理系统搜索功能</td></tr><tr><td>Clipboard Service</td><td>管理剪贴板功能</td></tr><tr><td>DevicePolicy Manager Service</td><td>管理设备的安全策略和企业管理功能</td></tr><tr><td>Status Bar Service</td><td>管理状态栏显示和操作</td></tr><tr><td>Wallpaper Manager Service</td><td>管理壁纸设置和操作</td></tr><tr><td>Media Router Service</td><td>管理媒体设备路由</td></tr></tbody></table><p><img src="https://s2.loli.net/2024/10/08/eztnSVYgbl8LAmj.png" alt="image-20241008200351668"></p><p><img src="https://s2.loli.net/2024/10/08/G39r2btcljHy5mv.png" alt="image-20241008200413406"></p><p>整体流程如下：</p><p><img src="https://s2.loli.net/2024/10/08/Xe7iEBZK5OhstyR.png" alt="0776be314b69defe63cbf793f867f1b9"></p><h1 id="Home进程"><a href="#Home进程" class="headerlink" title="Home进程"></a>Home进程</h1><p>一般情况下，Android原生的软体会包含两个home进程，一个是Settings进程的Fallbackhome，一个是Launcher进程。</p><h2 id="Launcher进程启动"><a href="#Launcher进程启动" class="headerlink" title="Launcher进程启动"></a>Launcher进程启动</h2><p>​    FallbackHome是系统由未解密到解密过程的一个过度界面，只要用户把系统解锁过一次后，FallbackHome收到解锁广播就会退出，而WMS检测到当前Acitivity栈是空的，进而启动真正的Launcher。由于FallbackHome没有界面，所以可能会出现一个问题，home进程切换时会出现空白界面，接下来才是显示Launcher的一个图标界面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@packages</span>\apps\Settings\src\com\android\settings\FallbackHome.java<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>    ...<br>    registerReceiver(mReceiver, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(Intent.ACTION_USER_UNLOCKED));<span class="hljs-comment">//注册ACTION_USER_UNLOCKED广播</span><br>    maybeFinish();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">BroadcastReceiver</span> <span class="hljs-variable">mReceiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastReceiver</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        maybeFinish();<span class="hljs-comment">//接收ACTION_USER_UNLOCKED广播</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">maybeFinish</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (getSystemService(UserManager.class).isUserUnlocked()) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_MAIN)<br>                .addCategory(Intent.CATEGORY_HOME);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ResolveInfo</span> <span class="hljs-variable">homeInfo</span> <span class="hljs-operator">=</span> getPackageManager().resolveActivity(homeIntent, <span class="hljs-number">0</span>);<span class="hljs-comment">//查询home包名信息，此处一般是返回Launcher的信息</span><br>        <span class="hljs-keyword">if</span> (Objects.equals(getPackageName(), homeInfo.activityInfo.packageName)) &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked but no home; let&#x27;s hope someone enables one soon?&quot;</span>);<br>            mHandler.sendEmptyMessageDelayed(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);<span class="hljs-comment">//间隔500ms轮询</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;User unlocked and real home found; let&#x27;s go!&quot;</span>);<br>            getSystemService(PowerManager.class).userActivity(<br>                    SystemClock.uptimeMillis(), <span class="hljs-literal">false</span>);<br>            finish();<span class="hljs-comment">//结束当前Activity，启动Launcher应用</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上一节systemserver中注意到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startOtherServices</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动ActivityManagerService</span><br>    mActivityManagerService = mSystemServiceManager.startService(<br>            ActivityManagerService.Lifecycle.class).getService();<br>    ...<br>    <span class="hljs-comment">// 启动Launcher</span><br>    mActivityManagerService.systemReady(...)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在AMS中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">systemReady</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable goingCallback, TimingsTraceAndSlog t)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 在所有显示器上启动Launcher</span><br>    mAtmInternal.startHomeOnAllDisplays(currentUserId, <span class="hljs-string">&quot;systemReady&quot;</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此行代码最终会调用到<code>RootWindowContainer.java</code>的<code>startHomeOnAllDisplays</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnAllDisplays</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">homeStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getChildCount() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">displayId</span> <span class="hljs-operator">=</span> getChildAt(i).mDisplayId;<br>        <span class="hljs-comment">// 在每一个显示器上启动桌面程序</span><br>        homeStarted |= startHomeOnDisplay(userId, reason, displayId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> homeStarted;<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId)</span> &#123;<br>    <span class="hljs-keyword">return</span> startHomeOnDisplay(userId, reason, displayId, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, <span class="hljs-type">int</span> displayId, <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 调用startHomeOnTaskDisplayArea</span><br>    <span class="hljs-keyword">return</span> display.reduceOnAllTaskDisplayAreas((taskDisplayArea, result) -&gt;<br>                    result | startHomeOnTaskDisplayArea(userId, reason, taskDisplayArea,<br>                            allowInstrumenting, fromHomeKey),<span class="hljs-literal">false</span>);<br>&#125;<br> <br><span class="hljs-type">boolean</span> <span class="hljs-title function_">startHomeOnTaskDisplayArea</span><span class="hljs-params">(<span class="hljs-type">int</span> userId, String reason, TaskDisplayArea taskDisplayArea,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> allowInstrumenting, <span class="hljs-type">boolean</span> fromHomeKey)</span> &#123;<br>    ...<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">homeIntent</span> <span class="hljs-operator">=</span> mService.getHomeIntent();<br>    mService.getActivityStartController().startHomeActivity(homeIntent, aInfo, myReason,<br>            taskDisplayArea);<br>    ...<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>最终通过Intent和startHomeActivity方法启动了桌面程序</p><h2 id="FallbackHome进程启动"><a href="#FallbackHome进程启动" class="headerlink" title="FallbackHome进程启动"></a>FallbackHome进程启动</h2><h3 id="（1）-启动home进程"><a href="#（1）-启动home进程" class="headerlink" title="（1） 启动home进程"></a><strong>（1）</strong> 启动home进程</h3><p>   刚开机时，SystemSever进程会启动WMS服务，如果WMS未检测到Activity栈有任务时，会启动一个默认的home进程，此进程即FallbackHome。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\wm\RootWindowContainer.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">startHomeOnEmptyDisplays</span><span class="hljs-params">(String reason)</span> &#123;<br>    forAllTaskDisplayAreas(taskDisplayArea -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (taskDisplayArea.topRunningActivity() == <span class="hljs-literal">null</span>) &#123;<br>            startHomeOnTaskDisplayArea(mCurrentUser, reason, taskDisplayArea,<br>                    <span class="hljs-literal">false</span> <span class="hljs-comment">/* allowInstrumenting */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* fromHomeKey */</span>);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（2）-ACTION-USER-UNLOCKED广播发送"><a href="#（2）-ACTION-USER-UNLOCKED广播发送" class="headerlink" title="（2） ACTION_USER_UNLOCKED广播发送"></a><strong>（2）</strong> ACTION_USER_UNLOCKED广播发送</h3><p>​    系统解锁时会发送该广播，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@frameworks</span>\base\services\core\java\com\android\server\am\UserController.java<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">finishUserUnlocked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> UserState uss)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!mInjector.getUserManager().isPreCreated(userId)) &#123;<br>        <span class="hljs-comment">// Dispatch unlocked to external apps</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">unlockedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_USER_UNLOCKED);<br>        unlockedIntent.putExtra(Intent.EXTRA_USER_HANDLE, userId);<br>        unlockedIntent.addFlags(<br>                Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);<br>        mInjector.broadcastIntent(unlockedIntent, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>,<br>                <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, MY_PID, SYSTEM_UID,<br>                Binder.getCallingUid(), Binder.getCallingPid(), userId);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上一张完整流程图：</p><p><img src="https://s2.loli.net/2024/10/08/mpCSY3h7r8szdJ2.png" alt="android系统启动流程"></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/anywherego/p/18221943">Android启动过程-万字长文(Android14) - 柳云居士 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/IT_xiao_bai0516/article/details/121566564?spm=1001.2014.3001.5502">源码详解Android 9.0(P) 系统启动流程之SystemServer_android9 systemserver启动-CSDN博客</a></p><p><a href="https://www.cnblogs.com/zhiqinlin/p/18001113#44-init%E8%BF%9B%E7%A8%8B">Android 开机流程介绍 - 林奋斗同学 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Andorid源码阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学体系框架</title>
    <link href="/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <url>/2023/07/15/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在提供对密码学体系框架的了解，建立相对完善知识体系，对一些细节并没有事无巨细的进行阐述，如有纰漏错误，请多指正。</p></blockquote><h1 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h1><p><img src="https://s21.ax1x.com/2024/09/28/pA1VbIH.jpg" alt="1"></p><p>简化版：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VLid.png" alt="2"></p><h1 id="对称密码算法"><a href="#对称密码算法" class="headerlink" title="对称密码算法"></a>对称密码算法</h1><blockquote><p>机密性是指向无权访问数据者隐藏真实数据，而加密可以实现这一目标。发明密码学的初衷就是加密，加密也是早期的密码学家最关心的技术，他们经常会问自己：“如何才能向观察者隐藏我们的对话内容？”</p></blockquote><p>对称加密算法是一种加密方法，使用相同的密钥进行数据的加密和解密。发送方和接收方必须共享同一个密钥，以便于对数据进行加密和解密。对称加密算法通常速度较快，适用于大数据量的加密。这其中又因为应用场景不同又分为分块加密和流加密。</p><p>分组加密将数据分为固定大小的块逐块加密，适合大数据量，如文件加密；流加密则逐字节加密，适合实时数据传输，如音视频流。分组加密速度较慢，流加密较快，但流加密在错误传播时影响更大。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Vjzt.png" alt="image-20240928180400857"></p><h2 id="分组密码算法-Block-cipher"><a href="#分组密码算法-Block-cipher" class="headerlink" title="分组密码算法(Block cipher)"></a>分组密码算法(Block cipher)</h2><h3 id="AES算法"><a href="#AES算法" class="headerlink" title="AES算法"></a>AES算法</h3><blockquote><p>pdf源于B站:<a href="https://www.alipan.com/s/nZN1ABDPfGf">https://www.alipan.com/s/nZN1ABDPfGf</a> 提取码: sw76 </p><p>有关的数学知识参考：<a href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎</a></p></blockquote><p>由于DES加密算法被破解了，3DES加密算法虽然没有被破解，但是3DES算法的加解密效率低，所有现在都使用AES算法。<br>AES加密算法是密码学中的高级加密标准，AES为分组加密法，把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文，在AES标准规范中，分组长度只能是128位，AES是按照字节进行加密的，也就是说每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。这导致密钥长度不同，推荐加密的轮数也不同。</p><p>其加密过程如下：(解密过程同理)</p><p><img src="https://s2.loli.net/2024/12/22/W9DUKLNB7dJ38Xj.png" alt="image-20241222153104837"></p><h4 id="初识变换"><a href="#初识变换" class="headerlink" title="初识变换"></a>初识变换</h4><img src="https://s2.loli.net/2024/12/22/ERrMZa2NTvubAde.png" alt="image-20241222153413982" style="zoom:50%;" /><p>其中初识变换是对其做按字节异或操作：</p><img src="https://s2.loli.net/2024/12/22/vzXk1eYaCiBQAct.png" alt="image-20241222153444413" style="zoom:50%;" /><h4 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h4><p>属于非线性替换，具体原理就是通过一个替换表（S盒）对每个字节进行替换，实际上就是一个查表操作，并且此过程可逆，将每一个字节的前4位作为行值，后4位作为列值，去S盒查找，进行输出。<br>下图为S盒（x表示行，y表示列），例如字节为0x14，那么前四位的16进制为1，后四位的16进制为4，去查找s盒中的第1行第4列的值，可以看出为0xfa，就把原先的字节0x14替换为0xfa。解密过程与此相同，唯一就是采用的是逆S盒。</p><p><img src="https://s2.loli.net/2024/12/22/DJ8cU19IoROqPng.png" alt="image-20241222153712844"></p><h4 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h4><p>行位移操作最为简单，它是用来将输入数据作为一个4·4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRows子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态当，从而达到<a href="https://zhida.zhihu.com/search?content_id=105665820&content_type=Article&match_order=1&q=%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94&zhida_source=entity">雪崩效应</a>。在加密时行位移处理与解密时的处理相反，我们这里将解密时的处理称作逆行位移。它之所以称作行位移，是因为它只在4·4矩阵的行间进行操作，每行4字节的数据。</p><p>在加密时：</p><p>对于4*4的矩阵，操作为：<br>第0行：保持不动；<br>第1行：循环左移1个字节；<br>第2行：循环左移2个字节；<br>第3行：循环左移3个字节。<br>解密过程变为循环右移，每行移动字节数与加密过程相同，下图为列位移示意图。</p><p><img src="https://s2.loli.net/2024/12/22/8MhbPmAsDTtaL5E.png" alt="image-20241222153925099"></p><h4 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h4><p>实际上为4<em>4的矩阵与另一个4</em>4矩阵异或相乘（注意为右乘操作），重新得到一个4*4的矩阵。解密过程为重新与此矩阵异或，因为两次异或得到的值为原数据本身。但实际过程却比较复杂</p><p><img src="https://s2.loli.net/2024/12/22/G1Bd4MJoiSKyfNj.png" alt="1"></p><p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p><p><img src="https://s2.loli.net/2024/12/22/5qpuD8Q1In4cUZ3.png" alt="2"></p><p>其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算，设S1 &#x3D; (a7 a6 a5 a4 a3 a2 a1 a0)，刚0x02 * S1如下图所示：</p><p><img src="https://s2.loli.net/2024/12/22/9FNmzsqhVan2OQI.png" alt="3"></p><p>也就是说，如果a7为1，则进行异或运算，否则不进行。<br>类似地，乘以(00000100)可以拆分成两次乘以(00000010)的运算：</p><p><img src="https://s2.loli.net/2024/12/22/MeJvXsjxan6qkQA.png" alt="4"></p><p>乘以(0000 0011)可以拆分成先分别乘以(0000 0001)和(0000 0010)，再将两个乘积异或：</p><img src="https://i-blog.csdnimg.cn/blog_migrate/3cd9fdef1e1047d154a8c11bcfb898fa.png#pic_center" alt="4" style="zoom:150%;" /><p>因此，我们只需要实现乘以2的函数，其他数值的乘法都可以通过组合来实现。</p><p>最终：</p><p><img src="https://s2.loli.net/2024/12/22/7ZtU198y4rswegB.png" alt="image-20241222154656683"></p><h4 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h4><h5 id="AES密钥生成"><a href="#AES密钥生成" class="headerlink" title="AES密钥生成"></a><strong>AES密钥生成</strong></h5><p><img src="https://s2.loli.net/2024/12/22/XjW4mgapc6UZVGQ.png" alt="image-20241222155137422"></p><p>函数T由3部分组成：字循环、字节代换和轮常量异或。</p><p><strong>函数T()首先将4个输入字节进行翻转，并执行一个按字节的S盒代换，最后用第一个字节与轮系数Rcon进行异或运算。轮系数是一个有10个元素的一维数组，一个元素1个字节。</strong></p><p><img src="https://s2.loli.net/2024/12/22/jf1Xl6NpGMLJq48.png" alt="6"></p><hr><p>轮密钥与状态矩阵进行逐比特异或操作。<br>这个轮密钥是由种子密钥通过密钥编排算法得到的，并且轮密钥长度与分组长度相同。<br>解密过程与之相同，两次异或得到原始数据。</p><p>最终：</p><p><img src="https://s2.loli.net/2024/12/22/YAac6FbnZWVQ8eH.png" alt="8"></p><h4 id="1轮最终轮T"><a href="#1轮最终轮T" class="headerlink" title="1轮最终轮T"></a>1轮最终轮T</h4><p>最终轮的操作与普通轮类似，但<strong>省略了列混合（MixColumns）</strong>。最终轮包含以下三个步骤：</p><ol><li><strong>字节代换（SubBytes）</strong>。</li><li><strong>行移位（ShiftRows）</strong>。</li><li><strong>轮密钥加（AddRoundKey）</strong>。</li></ol><h3 id="TEA算法"><a href="#TEA算法" class="headerlink" title="TEA算法"></a>TEA算法</h3><p>TEA（Tiny Encryption Algorithm）是一种分组加密算法，它的实现非常简单，通常只需要很精短的几行代码。TEA 算法最初是由剑桥计算机实验室的 David Wheeler 和 Roger Needham 在 1994 年设计的。</p><p>TEA 算法使用 64 位的明文分组和 128 位的密钥，它使用 Feistel 分组加密框架，建议的迭代次数为 32 轮。该算法使用了一个常数 δ 作为倍数，它来源于黄金比率，以保证每一轮加密都不相同。但 δ 的精确值似乎并不重要，这里 TEA 把它定义为 δ&#x3D;「(√5 - 1)231」（也就是程序中的 <strong>0×9E3779B9</strong>）。</p><p>之后 TEA 算法被发现存在缺陷，作为回应，设计者提出了一个 TEA 的升级版本——XTEA（有时也被称为“tean”）。XTEA 跟 TEA 使用了相同的简单运算，但它采用了截然不同的顺序，为了阻止密钥表攻击，四个子密钥（在加密过程中，原 128 位的密钥被拆分为 4 个 32 位的子密钥）采用了一种不太正规的方式进行混合，但速度更慢了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    <span class="hljs-comment">//总共加密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        sum += delta;<br>        x += ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        y += ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Decrypt</span><span class="hljs-params">(<span class="hljs-type">long</span>* EntryData, <span class="hljs-type">long</span>* Key)</span> &#123;<br>    <span class="hljs-comment">//分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> y = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> delta = <span class="hljs-number">0x9E3779B9</span>;<br>    sum = delta &lt;&lt; <span class="hljs-number">5</span>;   <span class="hljs-comment">//注意这里,sum = 32轮之后的黄金分割值. 因为我们要反序解密.</span><br>    <span class="hljs-comment">//总共加密32轮 那么反序也解密32轮</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        <span class="hljs-comment">// 先将y解开 然后参与运算在解x</span><br>        y -= ((x &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">2</span>]) ^ (x + sum) ^ ((x &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">3</span>]);<br>        x -= ((y &lt;&lt; <span class="hljs-number">4</span>) + Key[<span class="hljs-number">0</span>]) ^ (y + sum) ^ ((y &gt;&gt; <span class="hljs-number">5</span>) + Key[<span class="hljs-number">1</span>]);<br>        sum -= delta;<br>    &#125;<br>    <span class="hljs-comment">//最后加密的结果重新写入到数组中</span><br>    EntryData[<span class="hljs-number">0</span>] = x;<br>    EntryData[<span class="hljs-number">1</span>] = y;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;  <span class="hljs-comment">//明文，必须是8字节的倍数，不够需要程序补全，参考base64方法</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;待加密的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);  <br><br>    <span class="hljs-type">long</span> key[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span> &#125;;   <span class="hljs-comment">//密钥随便</span><br><br>    <span class="hljs-comment">//Encrypt每次只是加密4字节数组中的两组(也就是每次加密8个字节) 如果你数据多.可以来个for循环来循环加密,但是Entrypt内部还有32次循环,所以速度上还是会有点影响.</span><br>    Encrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;加密后的数值：%d %d\n&quot;</span>,Data[<span class="hljs-number">0</span>],Data[<span class="hljs-number">1</span>]);<br>    Decrypt(Data, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密后的数值：%d %d\&quot;,Data[0],Data[1]);</span><br><span class="hljs-string">    system(&quot;</span>pause<span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h5 id="逆向练习："><a href="#逆向练习：" class="headerlink" title="逆向练习："></a>逆向练习：</h5><p>题目来源：攻防世界(easy-app)</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1VXRI.png" alt="image-20240925190902367"></p><h2 id="流密码算法-Stream-cipher"><a href="#流密码算法-Stream-cipher" class="headerlink" title="流密码算法(Stream cipher)"></a>流密码算法(Stream cipher)</h2><h3 id="RC4算法"><a href="#RC4算法" class="headerlink" title="RC4算法"></a>RC4算法</h3><p>RC4（Rivest Cipher 4）是一种流加密算法，由罗纳德·李维斯特（Ron Rivest）在1987年开发。RC4算法的核心思想是利用伪随机数生成器（PRNG）和密钥共同生成一个密钥流，该密钥流与明文进行异或运算得到密文。</p><p>在RC4算法中，密钥流由两部分组成：密钥调度算法（KSA）和伪随机数生成算法（PRGA）。KSA的主要作用是将输入的密钥进行排列，生成一个密钥数组。PRGA则根据密钥数组生成伪随机数序列，这个序列与明文进行异或运算，得到密文。</p><blockquote><p>来源于大佬：B站&#x2F;可厉害的土豆</p></blockquote><p><a href="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485948315-3ebda21a-836f-43c6-9a35-11d6625de6a8.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485948315-3ebda21a-836f-43c6-9a35-11d6625de6a8.png" alt="img"></a></p><p><a href="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485958208-d00e28ea-5514-4403-8db6-bd3e42d97aff.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485958208-d00e28ea-5514-4403-8db6-bd3e42d97aff.png" alt="img"></a></p><p><a href="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485982224-cd0c7eb7-671a-455b-b1bb-3622fa26455b.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485982224-cd0c7eb7-671a-455b-b1bb-3622fa26455b.png" alt="img"></a></p><p><a href="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485997966-8e7ee87e-343d-4fbe-9230-d3c657d7cf59.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724485997966-8e7ee87e-343d-4fbe-9230-d3c657d7cf59.png" alt="img"></a></p><p><a href="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724486007627-d52dab55-bae7-4a85-b072-25d12431f96b.png"><img src="https://cdn.nlark.com/yuque/0/2024/png/42436713/1724486007627-d52dab55-bae7-4a85-b072-25d12431f96b.png" alt="img"></a></p><p><a href="https://cdn.nlark.com/yuque/0/2024/jpeg/42436713/1724486420992-2478a513-48ca-428d-adc7-f9e620dbdc77.jpeg"><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/42436713/1724486420992-2478a513-48ca-428d-adc7-f9e620dbdc77.jpeg" alt="img"></a></p><h4 id="（1）初始化S表"><a href="#（1）初始化S表" class="headerlink" title="（1）初始化S表"></a>（1）初始化S表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 得到S-box */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    S[i] = i;<br>    T[i] = puc_key[i % key_length];<br>&#125;<br> <br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++) &#123;<br>    j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    swap_uchar(&amp;S[i], &amp;S[j]); <span class="hljs-comment">//交换S[i]和S[j]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）利用S盒生成密钥流"><a href="#（2）利用S盒生成密钥流" class="headerlink" title="（2）利用S盒生成密钥流"></a>（2）利用S盒生成密钥流</h4><p><img src="https://s2.loli.net/2024/12/22/cB6mPfT4FY8opqz.png" alt="10"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 生成密钥流 Keystream */</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> k = <span class="hljs-number">0</span>;<br> <br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; ul_data_length; k++) &#123;<br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    j = (j + puc_sbox[i]) % <span class="hljs-number">256</span>;<br>    swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);<br>    t = (puc_sbox[i] + puc_sbox[j]) % <span class="hljs-number">256</span>;<br>    puc_key_stream[k] = puc_sbox[t];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="非对称密码算法"><a href="#非对称密码算法" class="headerlink" title="非对称密码算法"></a><strong>非对称密码算法</strong></h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>对称加密(公钥密码算法)的安全性依赖于密钥的保密性和算法的强度。如果密钥被泄露，攻击者可以轻易解密数据。因此，在实际应用中，密钥管理和分发是对称加密的关键挑战之一。而通过使用密钥交换协议，通信双方可以安全地获得一个对称密钥，而敌手却无法知道这个对称密钥。</p><p>非对称密码算法使用一对密钥进行加密和解密，通常包括公钥和私钥。公钥可以公开，任何人都可以使用它加密数据；而私钥则必须保密，仅由拥有者使用来解密数据。</p><p><strong>主要特性</strong>：</p><ol><li><strong>密钥对</strong>：每个用户拥有一对密钥，公钥用于加密，私钥用于解密。</li><li><strong>安全性</strong>：即使公钥被公开，私钥的保密性仍能确保加密数据的安全性。</li><li><strong>身份验证</strong>：可用于数字签名，通过私钥签名的数据可以用公钥验证，确保信息来源和完整性。</li></ol><p><img src="https://s21.ax1x.com/2024/09/28/pA1VxQP.png" alt="image-20240928180525589"></p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><blockquote><p>RSA加密算法.pdf <a href="https://www.alipan.com/s/tpBA521QB9q">https://www.alipan.com/s/tpBA521QB9q</a> 提取码: k9b2 </p><p><a href="https://www.cnblogs.com/testtraveler/p/18499698">RSA算法详解及相关数学原理解析 - testtraveler - 博客园</a></p></blockquote><h4 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h4><h5 id="1-1-相关概念"><a href="#1-1-相关概念" class="headerlink" title="1.1 相关概念"></a>1.1 相关概念</h5><p>RSA（Rivest-Shamir-Adleman）加密算法是一种基于数论的非实时加密算法，广泛用于安全通信。RSA算法的核心依赖于<strong>大整数分解</strong>的困难性</p><h5 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h5><p>RSA是一种非加密加密算法，它使用<strong>公钥</strong>进行加密，<strong>私钥</strong>进行解密。非加密加密的优势在于，公钥可以公开（存储于公钥数据库PKDB），而私钥仅保留给接收者。这种设计使得消息安全传输，而消耗共享加密密钥。</p><h5 id="1-3-素数（素数）"><a href="#1-3-素数（素数）" class="headerlink" title="1.3 素数（素数）"></a>1.3 <strong>素数（素数）</strong></h5><p>RSA依赖于两个大素数的乘积。素数是指只能被1和自身整除的整数。两个大素数的乘积积极难以进行因数分解，而这一问题构成了RSA的安全基础。</p><h5 id="1-4-模运算（Modulo）"><a href="#1-4-模运算（Modulo）" class="headerlink" title="1.4 模运算（Modulo）"></a>1.4 <strong>模运算（Modulo）</strong></h5><p>余数 RSA 中广泛使用模破坏。模破坏是一种余数破坏，定义为一个整数除以另一个整数后得到的数。在 RSA 中，模破坏对加密和解密过程的避免可以在有限的数值范围内进行，从而避免溢出和精度问题。</p><h5 id="1-5欧几里得函数"><a href="#1-5欧几里得函数" class="headerlink" title="1.5欧几里得函数"></a>1.5欧几里得函数</h5><p>给定两个非负整数 a 和 b（假设 a ≥ b），欧几里得算法基于以下原理：</p><ol><li>如果 a &#x3D; b，那么结果就是 a（或 b）。</li><li>如果 a &#x3D; 0，那么结果是 b，反之亦然。</li><li>如果 a ≠ b，那么可以用较小的那个数去除较大的那个数，然后用余数代替较大的数，重复此步骤直到余数为 0。</li></ol><p>欧几里得算法的步骤</p><ol><li>计算 a mod b 得到余数 r。</li><li>如果 r &#x3D; 0，那么 b 就是 a 和 b 的最大公约数。</li><li>如果 r ≠ 0，令 a &#x3D; b，b &#x3D; r，然后重复步骤 1。</li></ol><p>示例</p><p>假设我们要找 48 和 18 的最大公约数：</p><ol><li>48mod  18&#x3D;1248mod18&#x3D;12</li><li>18mod  12&#x3D;618mod12&#x3D;6</li><li>12mod  6&#x3D;012mod6&#x3D;0，此时余数为 0，所以最大公约数是 6。</li></ol><p>扩展欧几里得算法</p><p>扩展欧几里得算法不仅可以找到 a 和 b 的最大公约数 d，还可以找到一对整数 x 和 y，使得 ax + by &#x3D; d</p><h5 id="1-6-欧拉函数φ-n"><a href="#1-6-欧拉函数φ-n" class="headerlink" title="1.6 欧拉函数φ(n)"></a>1.6 <strong>欧拉函数φ(n)</strong></h5><p>欧拉函数（Euler’s Totient Function），通常记作 φ(n)，是数论中的一个重要函数。它对于一个正整数 n 定义为小于或等于 n 的正整数中与 n 互质的数的数目。两个数互质（coprime）指的是它们的最大公约数（GCD）为 1。</p><p>例如，φ(9) &#x3D; 6，因为 1, 2, 4, 5, 7 和 8 与 9 互质；而 φ(8) &#x3D; 4，因为只有 1, 3, 5 和 7 与 8 互质。</p><p>如果 n 是一个质数 p 的幂次 p^k，则有：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(pk)=pk−pk−<span class="hljs-number">1</span>=pk(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p)*φ*<span class="hljs-comment">(*p**k*)</span>=*p**k*−*p**k*−<span class="hljs-number">1</span>=*p**k*(<span class="hljs-number">1</span>−*p*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>对于任意正整数 n，如果 n 可以分解为不同质数的乘积：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">n=p1k1⋅p2k2⋯pmkm<span class="hljs-emphasis">*n*</span>=<span class="hljs-emphasis">*p*</span>1<span class="hljs-emphasis">*k*</span>1⋅<span class="hljs-emphasis">*p*</span>2<span class="hljs-emphasis">*k*</span>2⋯<span class="hljs-emphasis">*p<span class="hljs-strong">**m**</span>k<span class="hljs-strong">**m*</span></span><br></code></pre></td></tr></table></figure><p>那么根据欧拉函数的性质，我们可以计算出：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">φ(n)=φ(p1k1)⋅φ(p2k2)⋯φ(pmkm)*φ*<span class="hljs-comment">(*n*)</span>=*φ*<span class="hljs-comment">(*p*1*k*1)⋅*φ*(*p*2*k*2)⋯*φ*(*p**m**k**m*)</span> φ(n)=n⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p1)⋅(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>p2)⋯(<span class="hljs-number">1</span>−<span class="hljs-number">1</span>pm)*φ*<span class="hljs-comment">(*n*)</span>=*n*⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">11</span>)⋅(<span class="hljs-number">1</span>−*p*<span class="hljs-number">21</span>)⋯(<span class="hljs-number">1</span>−*p**m*<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="0x02-算法描述"><a href="#0x02-算法描述" class="headerlink" title="0x02 算法描述"></a>0x02 算法描述</h4><h5 id="1-1-密钥计算步骤"><a href="#1-1-密钥计算步骤" class="headerlink" title="1.1 密钥计算步骤"></a>1.1 密钥计算步骤</h5><p>1、生成两个大素数p和q</p><p>2、计算两个素数的乘积</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">n</span>=p*q <br></code></pre></td></tr></table></figure><p>3、计算欧拉函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">φ(n)=(p-1)*(q-1)<br></code></pre></td></tr></table></figure><p>4、选择一个整数<code>e</code>（1 &lt; e &lt; φ(n)），使得<code>e</code>与<code>φ(n)</code>互质（即最大公约数gcd(e, φ(n)) &#x3D; 1）。通常情况下，<code>e</code>取一个较小的质数如65537 (<code>2^16 + 1</code>)，因为它使得加密过程更高效。</p><p>5、欧几里得算法计算d(私钥)</p><p><code>d</code>（1 &lt; d &lt; φ(n)），使得</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">(d * e) <span class="hljs-built_in">mod</span> φ(n) = <span class="hljs-number">1</span><br>d = e^<span class="hljs-number">-1</span> <span class="hljs-built_in">mod</span> φ(n)<br></code></pre></td></tr></table></figure><p>换句话说，<code>d</code>是<code>e</code>在模<code>φ(n)</code>下的乘法逆元</p><p>6、公钥：<strong>由<code>(n, e)</code>组成</strong></p><p> 私钥：<strong>由<code>(n, d)</code>组成</strong></p><p>7、加密</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r">m（其中m必须小于n）使用公钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> e<span class="hljs-punctuation">)</span>，加密公式为<span class="hljs-built_in">c</span> <span class="hljs-operator">=</span> m<span class="hljs-operator">^</span>e mod n，这里<span class="hljs-built_in">c</span>是密文<br></code></pre></td></tr></table></figure><p>8、解密</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs r"><span class="hljs-built_in">c</span>使用私钥<span class="hljs-punctuation">(</span>n<span class="hljs-punctuation">,</span> d<span class="hljs-punctuation">)</span>，解密公式为m <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-operator">^</span>d mod n，这样就恢复了原始的消息m<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><table><thead><tr><th>公钥</th><th>（e,n）</th></tr></thead><tbody><tr><td><strong>私钥</strong></td><td><strong>（d,n）</strong></td></tr><tr><td><strong>密钥对</strong></td><td><strong>（e,n,d）</strong></td></tr><tr><td><strong>加密</strong></td><td><strong>c &#x3D; m^e mod n</strong></td></tr><tr><td><strong>解密</strong></td><td><strong>m &#x3D; c ^d mod n</strong></td></tr></tbody></table><table><thead><tr><th>n</th><th>p*q</th></tr></thead><tbody><tr><td><strong>φ(n)</strong></td><td><strong>(p-1)*(q-1)</strong></td></tr><tr><td><strong>e</strong></td><td><strong>1&lt;e&lt; φ(n)</strong></td></tr><tr><td><strong>d</strong></td><td><strong>1&lt;d&lt; φ(n)</strong> <strong>,e*d mod φ(n) &#x3D; 1</strong></td></tr></tbody></table><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 计算最大公约数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : gcd(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 求模反元素</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">modInverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>; x &lt; m; x++) &#123;<br>        <span class="hljs-keyword">if</span> ((a * x) % m == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 快速幂算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> p)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    x = x % p;<br>    <span class="hljs-keyword">while</span> (y &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (y &amp; <span class="hljs-number">1</span>) <br>            res = (res * x) % p;<br>        y = y &gt;&gt; <span class="hljs-number">1</span>;<br>        x = (x * x) % p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// RSA加密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(m, e, n);<br>&#125;<br><br><span class="hljs-comment">// RSA解密</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> power(c, d, n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">61</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> q = <span class="hljs-number">53</span>; <span class="hljs-comment">// 示例素数</span><br>    <span class="hljs-type">int</span> n = p * q; <span class="hljs-comment">// 计算n</span><br>    <span class="hljs-type">int</span> phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>); <span class="hljs-comment">// 计算φ(n)</span><br>    <br>    <span class="hljs-type">int</span> e = <span class="hljs-number">17</span>; <span class="hljs-comment">// 选择公钥</span><br>    <span class="hljs-keyword">while</span> (gcd(e, phi) != <span class="hljs-number">1</span>) &#123;<br>        e++;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> d = modInverse(e, phi); <span class="hljs-comment">// 计算私钥</span><br>    <br>    <span class="hljs-type">int</span> m = <span class="hljs-number">65</span>; <span class="hljs-comment">// 明文</span><br>    <span class="hljs-type">int</span> c = rsa_encrypt(m, e, n); <span class="hljs-comment">// 加密</span><br>    <span class="hljs-type">int</span> decrypted = rsa_decrypt(c, d, n); <span class="hljs-comment">// 解密</span><br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;明文: %d\n&quot;</span>, m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;密文: %d\n&quot;</span>, c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;解密: %d\n&quot;</span>, decrypted);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>简单地说，数字签名的作用类似于现实生活中在支票和合同上的签名。当然数字签名是一种密码学技术，相比手写签名，它提供了更多的安全保证。当数字签名应用在各种各样的协议中时，它会让这些协议具有更加强大的功能</p><p>我们知道数字签名与现实生活中的签名非常相似。该密码学原语是在直观上很容易理解的密码原语之一。</p><ul><li>只有签名者本人可以对任意消息生成签名。</li><li>任何人都可以验证签名者对消息的签名。</li></ul><p><strong>在非对称密码领域，我们很容易想到数字签名的这种非对称性实现方式。</strong></p><p>签名方案通常由3种不同的算法组成。</p><ul><li>密钥对生成算法：签名者使用该算法生成新的私钥和公钥（公钥可以共享出去）。</li><li>签名算法：该算法以私钥和消息为输入，输出消息的签名。</li><li>验证算法：该算法以公钥、消息以及消息的签名为输入，输出验证结果（通过或不通过）。</li></ul><p>有时我们也将私钥称为签名密钥，将公钥称为验证密钥。上述3种算法的原理如图7.1所示。</p><p><img src="https://s2.loli.net/2024/12/22/aUc9M5T7Avg46uq.png" alt="image-20240928211112408"></p><p>那么为什么数字签名应用如此广泛呢？这是因为数字签名可以用于验证消息的来源以及完整性。</p><ul><li>来源：如果这个消息中包含某个人的签名，那么说明该消息源于这个人。</li><li>完整性：如果有人篡改了消息，签名就会失效。</li></ul><h3 id="数字证书-公钥的数字签名"><a href="#数字证书-公钥的数字签名" class="headerlink" title="数字证书(公钥的数字签名)"></a>数字证书(公钥的数字签名)</h3><p>数字证书也称为身份证书和<a href="https://zhida.zhihu.com/search?content_id=222777750&content_type=Article&match_order=1&q=%E5%85%AC%E9%92%A5%E8%AF%81%E4%B9%A6&zhida_source=entity">公钥证书</a>，是一种利用公钥基础设施(PKI)并使个人和企业能够通过互联网安全地共享数据的电子密码。</p><p>在信任可传递的假设下，数字签名将变得更加强大。简而言之，如果你相信我，而我相信Alice，那么你就可以相信Alice。信任的传递性使得系统中的信任关系得到极大地扩展。想象一下，假设我们信任某些权威机构及其验证密钥。那么，假设该权威机构对某些消息进行签名，比如Charles或者David的公钥信息等，我们就可以选择相信这个签名与消息的映射关系！这种映射称为公钥基础设施(Public Key Infrastructure，PKI)。例如，当我们尝试与Charles进行密钥交换，且他声称自己的公钥是3848时，可以通过检查我们信任的权威机构是否对类似“Charles的公钥是3848…”的消息进行签名来验证Charles的公钥的真实性。</p><p>PKI在实践中的一个应用是Web PKI。浏览器每天都通过Web PKI对我们与网站的密钥交换过程进行认证。Web PKI可以简化如下（见图7.3）过程：当我们下载浏览器时，它附带了一些内置在浏览器中的验证密钥。此验证密钥与一个权威机构相关联，该机构负责对成千上万个网站的公钥进行签名，以便网络用户可以信任这些公钥，而不必知道权威机构的存在。而用户不能观察到的是，这些网站在获得它们公钥的签名之前，必须向权威机构证明它们确实拥有自己所声称的域名。（事实上，浏览器信任许多权威机构而不仅只有一个。）</p><p><img src="https://s2.loli.net/2024/12/22/FUx1TDnlH94KktQ.png" alt="image-20240928212930338"></p><h1 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a><strong>摘要算法</strong></h1><h2 id="密码原语-基础知识"><a href="#密码原语-基础知识" class="headerlink" title="密码原语(基础知识)"></a>密码原语(基础知识)</h2><p>哈希函数(Hash Function)，它可以给任何数据生成一个全局唯一的标识符。哈希函数在密码学中随处可见！非正式地说，哈希函数以任意值为输入，并输出一个唯一的字节串。给定相同的输入，哈希函数总是产生相同的字节串。这可能看起来没什么，但在密码学中，许多算法都是基于哈希函数构造的。哈希函数的输出通常被称为摘要(Digest)或哈希值(Hash)</p><p>哈希函数的三种安全属性的表格及其简要介绍：</p><table><thead><tr><th>属性</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td>抗第一原像性</td><td>给定哈希值，无法找到一个输入值，使得该输入值的哈希值等于该给定哈希值。</td><td>这确保了即使攻击者知道哈希值，也不能轻易反推原始输入。</td></tr><tr><td>抗第二原像性</td><td>给定输入值，无法找到另一个不同的输入值，使得两个输入的哈希值相同。</td><td>这保证了不同输入产生相同哈希值的概率极低，有效抵御替换攻击。</td></tr><tr><td>抗碰撞性</td><td>任何两个不同的输入值，几乎不可能产生相同的哈希值。</td><td>这使得攻击者无法找到两个不同的输入使它们的哈希值相同。</td></tr></tbody></table><p>主要应用场景：</p><table><thead><tr><th>应用场景</th><th>描述</th></tr></thead><tbody><tr><td>数据完整性验证</td><td>检查数据在传输或存储过程中的完整性，确保未被篡改。</td></tr><tr><td>密码存储</td><td>将用户密码哈希后存储，防止直接获取明文密码。</td></tr><tr><td>数字签名</td><td>生成数字签名的摘要，确保签名的数据未被篡改并提供身份验证。</td></tr><tr><td>文件完整性校验</td><td>在软件分发时，通过哈希值验证下载文件的完整性，防止恶意篡改。</td></tr><tr><td>区块链技术</td><td>用于生成区块的哈希值，确保区块链中的数据不可篡改和一致性。</td></tr><tr><td>身份认证</td><td>在安全协议中，确保用户身份的验证，防止伪造身份。</td></tr><tr><td>网络协议安全</td><td>在SSL&#x2F;TLS等协议中用于数据传输的安全性和完整性校验。</td></tr><tr><td>防止重放攻击</td><td>确保每次通信都有唯一的哈希值，防止旧通信内容被重放。</td></tr><tr><td>电子邮件安全</td><td>用于生成邮件的哈希值，确保邮件内容未被篡改。</td></tr><tr><td>代码签名</td><td>验证软件代码的完整性和来源，确保软件未被篡改。</td></tr></tbody></table><h2 id="消息摘要算法-Message-Digest"><a href="#消息摘要算法-Message-Digest" class="headerlink" title="消息摘要算法(Message Digest)"></a>消息摘要算法(Message Digest)</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： MD5（Message-Digest Algorithm 5）是一种广泛使用的哈希函数，它产生一个128位（16字节）的哈希值，通常以32位十六进制数字表示。</p><p><strong>主要特性</strong>：</p><ul><li><strong>输出固定长度</strong>：无论输入数据大小如何，MD5总是生成128位的哈希值。</li><li><strong>快速计算</strong>：MD5的计算速度相对较快，适合处理大量数据。</li><li><strong>抗碰撞性</strong>：理论上，MD5应保证不同输入不产生相同的哈希值（尽管实际应用中存在漏洞）。</li><li><strong>广泛应用</strong>：MD5曾被广泛用于数据完整性校验、数字签名和密码存储等场景。</li></ul><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块"><a href="#数据填充和分块" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>对待加密的文件或者字符串的处理是将一个字符串分割成每512位为一个分组(小到KB大到GB都是如此划分)，形如N*512+R，这里的R是余下的位数。这个R分为几种情况：</p><ul><li>当R&#x3D;0时，实际上不需要单独“补上一个512位的分组”，因为接下来的填充和长度信息添加会自动形成一个完整的分组。</li><li>当R&lt;448时，需要在消息后面添加一个<code>1</code>，然后添加足够多的<code>0</code>，直到消息长度达到448位。之后，添加64位的长度信息（即原始消息的长度，以位为单位，低位在前）。</li><li>当R&gt;448时，确实需要添加足够的<code>0</code>（加上那个初始的<code>1</code>）来填满当前分组（即达到512位），然后在下一个分组中继续添加64位的长度信息(下一个分组的前64位)。但请注意，这里不是“再补上一个512位的分组”，而是说长度信息会放在一个新的分组中（如果原始消息加上填充的<code>1</code>和<code>0</code>不足以填满一个完整的分组，则可能看起来像是“再补”了一个分组，但实际上只是长度信息占据了一个分组的前部分）。</li></ul><p>这里的最后长度的填充一般在输出的前一刻执行。前面的分块后就可以执行后续操作了。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>  <br><span class="hljs-title function_">Md5Finalise</span>  <br><span class="hljs-params">(  </span><br><span class="hljs-params">    Md5Context*         Context,        <span class="hljs-comment">// [in out] 指向MD5上下文的指针，该上下文将被修改以完成哈希计算。  </span></span><br><span class="hljs-params">    MD5_HASH*           Digest          <span class="hljs-comment">// [out] 用于接收最终哈希值的缓冲区。  </span></span><br><span class="hljs-params">)</span>  <br>&#123;  <br>    <span class="hljs-type">uint32_t</span>    used;     <span class="hljs-comment">// 用于存储缓冲区中已使用字节的数量。  </span><br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;     <span class="hljs-comment">// 用于存储缓冲区中剩余空闲字节的数量。  </span><br>  <br>    <span class="hljs-comment">// 计算缓冲区中已使用的字节数。  </span><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;  <br>  <br>    <span class="hljs-comment">// 在缓冲区的当前位置添加一个0x80字节作为填充的开始。  </span><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;  <br>  <br>    <span class="hljs-comment">// 计算填充0x80字节后剩余的空闲空间。  </span><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;  <br>  <br>    <span class="hljs-comment">// 如果剩余的空闲空间不足以存放64位长度信息，则进行填充、变换，并重置used和free。  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)  <br>    &#123;  <br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );  <br>        <span class="hljs-comment">//压缩循环函数(暂时不要管)</span><br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br>        used = <span class="hljs-number">0</span>;  <br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 在剩余空间中填充0，直到距离缓冲区末尾剩下8个字节用于存放长度信息。  </span><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );  <br>  <br>    <span class="hljs-comment">// 将消息长度（以位为单位）左移3位（这不是标准MD5），并存储到缓冲区末尾。  </span><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;  <br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );  <br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );  <br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );  <br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );  <br>  <br>    <span class="hljs-comment">// 对填充后的缓冲区进行最后的变换，得到最终的哈希值。  </span><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );  <br></code></pre></td></tr></table></figure><h5 id="链接变量初始化"><a href="#链接变量初始化" class="headerlink" title="链接变量初始化"></a>链接变量初始化</h5><p>初始化一个128-bit 的 MD 缓冲区，初始记为CV0，可以表示成4个32-bit 寄存器（A, B, C, D），后续的迭代始终在 MD 缓冲区进行，最后一步的128-bit 输出即为MD5算法的结果。</p><p>MD5有四个32位的被称作链接变量的整数参数，这是个参数我们定义为A、B、C、D其取值为：A&#x3D;0x01234567，B&#x3D;0x89abcdef，C&#x3D;0xfedcba98，D&#x3D;0x76543210。但考虑到内存数据存储大小端的问题我们将其赋值为：A&#x3D;0x67452301，B&#x3D;0xefcdab89，C&#x3D;0x98badcfe，D&#x3D;0x10325476。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">uint32_t</span>     lo;<br>    <span class="hljs-type">uint32_t</span>     hi;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint8_t</span>      buffer[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">uint32_t</span>     block[<span class="hljs-number">16</span>];<br>&#125; Md5Context;<br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;a = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;b = <span class="hljs-number">0xefcdab89</span>;<br>    Context-&gt;c = <span class="hljs-number">0x98badcfe</span>;<br>    Context-&gt;d = <span class="hljs-number">0x10325476</span>;<br><br>    Context-&gt;lo = <span class="hljs-number">0</span>;<br>    Context-&gt;hi = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="压缩循环"><a href="#压缩循环" class="headerlink" title="压缩循环"></a>压缩循环</h5><p>MD5算法规定了四个非线性操作函数（&amp;是与，|是或，~是非，^是异或）</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">#define F( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">z</span>) ^ ((<span class="hljs-name">x</span>) &amp; ((<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>))) )<br>#define G( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">z</span>) &amp; ((<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>))) )<br>#define H( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">x</span>) ^ (<span class="hljs-name">y</span>) ^ (<span class="hljs-name">z</span>) )<br>#define I( <span class="hljs-name">x</span>, y, z )            ( (<span class="hljs-name">y</span>) ^ ((<span class="hljs-name">x</span>) | ~(<span class="hljs-name">z</span>)) )<br></code></pre></td></tr></table></figure><p>这些函数设计思想的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p><p>利用上面的四种操作，生成四个重要的计算函数。首先我们声明四个中间变量a,b,c,d，赋值：a &#x3D; A, b &#x3D; B, c &#x3D; C, d &#x3D; D。然后定义这四个计算函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">FF(a, b, c, d, M[j], s, ti)表示 a = b + ((a + F(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>GG(a, b, c, d, M[j], s, ti)表示 a = b + ((a + G(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>HH(a, b, c, d, M[j], s, ti)表示 a = b + ((a + H(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br>II(a, b, c, d, M[j], s, ti)表示 a = b + ((a + I(b, c, d) + Mj + ti) &lt;&lt;&lt; s)<br><br></code></pre></td></tr></table></figure><p>其中M[j]表示消息的第j个子分组（从0到15），&lt;&lt;表示循环左移s，常数ti是4294967296*abs(sin(i))的整数部分，i取值从1到64，单位是弧度。</p><p>定义好上述的四个计算函数后，就可以实现MD5的真正循环计算了。<strong>这个循环的循环次数为512位分组的个数</strong>。</p><blockquote><p>压缩函数每次都从CV（即上文提到的 128-bit 缓冲区）输入128位，从之前分好的消息分组中按顺序输入512位，完成4轮循环后，得到该轮压缩的128位结果，加到原来的缓冲区中，然后用下一分组继续上述步骤。（<strong>说具体一点，就是函数每次都从缓冲区(A, B, C, D)拿到四个数a, b, c, d，然后对于a, b, c, d进行压缩循环操作，把最后得到的结果a, b, c, d加到原来的(A, B, C, D)中，下一次函数执行再从(A, B, C, D)中拿数据</strong>）</p></blockquote><p>每次循环执行64次计算，上述4个函数每个16次.</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span>*<br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*     ctx,</span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*     data,</span><br><span class="hljs-params">        <span class="hljs-type">uintmax_t</span>       size</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span>*     ptr;<br>    <span class="hljs-type">uint32_t</span>     a;<br>    <span class="hljs-type">uint32_t</span>     b;<br>    <span class="hljs-type">uint32_t</span>     c;<br>    <span class="hljs-type">uint32_t</span>     d;<br>    <span class="hljs-type">uint32_t</span>     saved_a;<br>    <span class="hljs-type">uint32_t</span>     saved_b;<br>    <span class="hljs-type">uint32_t</span>     saved_c;<br>    <span class="hljs-type">uint32_t</span>     saved_d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> GET(n) (ctx-&gt;block[(n)])</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> SET(n) (ctx-&gt;block[(n)] =             \</span><br><span class="hljs-meta">            ((uint32_t)ptr[(n)*4 + 0] &lt;&lt; 0 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 1] &lt;&lt; 8 )      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 2] &lt;&lt; 16)      \</span><br><span class="hljs-meta">        |   ((uint32_t)ptr[(n)*4 + 3] &lt;&lt; 24) )</span><br><br>    ptr = (<span class="hljs-type">uint8_t</span>*)data;<br><br>    a = ctx-&gt;a;<br>    b = ctx-&gt;b;<br>    c = ctx-&gt;c;<br>    d = ctx-&gt;d;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        saved_a = a;<br>        saved_b = b;<br>        saved_c = c;<br>        saved_d = d;<br><br>        <span class="hljs-comment">// Round 1</span><br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xd76aa478</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xe8c7b756</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x242070db</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xc1bdceee</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf57c0faf</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">5</span>),  <span class="hljs-number">0x4787c62a</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa8304613</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xfd469501</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">8</span> ),  <span class="hljs-number">0x698098d8</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">9</span> ),  <span class="hljs-number">0x8b44f7af</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">10</span> ), <span class="hljs-number">0xffff5bb1</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">11</span> ), <span class="hljs-number">0x895cd7be</span>, <span class="hljs-number">22</span> )<br>        STEP( F, a, b, c, d, SET(<span class="hljs-number">12</span> ), <span class="hljs-number">0x6b901122</span>, <span class="hljs-number">7</span> )<br>        STEP( F, d, a, b, c, SET(<span class="hljs-number">13</span> ), <span class="hljs-number">0xfd987193</span>, <span class="hljs-number">12</span> )<br>        STEP( F, c, d, a, b, SET(<span class="hljs-number">14</span> ), <span class="hljs-number">0xa679438e</span>, <span class="hljs-number">17</span> )<br>        STEP( F, b, c, d, a, SET(<span class="hljs-number">15</span> ), <span class="hljs-number">0x49b40821</span>, <span class="hljs-number">22</span> )<br><br>        <span class="hljs-comment">// Round 2</span><br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xf61e2562</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xc040b340</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x265e5a51</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xe9b6c7aa</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xd62f105d</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0x02441453</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xd8a1e681</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xe7d3fbc8</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0x21e1cde6</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xc33707d6</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xf4d50d87</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x455a14ed</span>, <span class="hljs-number">20</span> )<br>        STEP( G, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0xa9e3e905</span>, <span class="hljs-number">5</span> )<br>        STEP( G, d, a, b, c, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xfcefa3f8</span>, <span class="hljs-number">9</span> )<br>        STEP( G, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x676f02d9</span>, <span class="hljs-number">14</span> )<br>        STEP( G, b, c, d, a, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x8d2a4c8a</span>, <span class="hljs-number">20</span> )<br><br>        <span class="hljs-comment">// Round 3</span><br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfffa3942</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x8771f681</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0x6d9d6122</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xfde5380c</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0xa4beea44</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0x4bdecfa9</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0xf6bb4b60</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xbebfbc70</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x289b7ec6</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xeaa127fa</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0xd4ef3085</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0x04881d05</span>, <span class="hljs-number">23</span> )<br>        STEP( H, a, b, c, d, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xd9d4d039</span>, <span class="hljs-number">4</span> )<br>        STEP( H, d, a, b, c, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0xe6db99e5</span>, <span class="hljs-number">11</span> )<br>        STEP( H, c, d, a, b, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0x1fa27cf8</span>, <span class="hljs-number">16</span> )<br>        STEP( H, b, c, d, a, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0xc4ac5665</span>, <span class="hljs-number">23</span> )<br><br>        <span class="hljs-comment">// Round 4</span><br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">0</span>),  <span class="hljs-number">0xf4292244</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">7</span>),  <span class="hljs-number">0x432aff97</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">14</span>), <span class="hljs-number">0xab9423a7</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">5</span>),  <span class="hljs-number">0xfc93a039</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">12</span>), <span class="hljs-number">0x655b59c3</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">3</span>),  <span class="hljs-number">0x8f0ccc92</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">10</span>), <span class="hljs-number">0xffeff47d</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">1</span>),  <span class="hljs-number">0x85845dd1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">8</span>),  <span class="hljs-number">0x6fa87e4f</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">15</span>), <span class="hljs-number">0xfe2ce6e0</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">6</span>),  <span class="hljs-number">0xa3014314</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">13</span>), <span class="hljs-number">0x4e0811a1</span>, <span class="hljs-number">21</span> )<br>        STEP( I, a, b, c, d, GET(<span class="hljs-number">4</span>),  <span class="hljs-number">0xf7537e82</span>, <span class="hljs-number">6</span> )<br>        STEP( I, d, a, b, c, GET(<span class="hljs-number">11</span>), <span class="hljs-number">0xbd3af235</span>, <span class="hljs-number">10</span> )<br>        STEP( I, c, d, a, b, GET(<span class="hljs-number">2</span>),  <span class="hljs-number">0x2ad7d2bb</span>, <span class="hljs-number">15</span> )<br>        STEP( I, b, c, d, a, GET(<span class="hljs-number">9</span>),  <span class="hljs-number">0xeb86d391</span>, <span class="hljs-number">21</span> )<br><br>        a += saved_a;<br>        b += saved_b;<br>        c += saved_c;<br>        d += saved_d;<br><br>        ptr += <span class="hljs-number">64</span>;<br>    &#125; <span class="hljs-keyword">while</span>( size -= <span class="hljs-number">64</span> );<br><br>    ctx-&gt;a = a;<br>    ctx-&gt;b = b;<br>    ctx-&gt;c = c;<br>    ctx-&gt;d = d;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> GET</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> SET</span><br><br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span> <span class="hljs-type">const</span>*         Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    saved_lo;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    saved_lo = Context-&gt;lo;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;lo = (saved_lo + BufferSize) &amp; <span class="hljs-number">0x1fffffff</span>) &lt; saved_lo )<br>    &#123;<br>        Context-&gt;hi++;<br>    &#125;<br>    Context-&gt;hi += (<span class="hljs-type">uint32_t</span>)( BufferSize &gt;&gt; <span class="hljs-number">29</span> );<br><br>    used = saved_lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    <span class="hljs-keyword">if</span>( used )<br>    &#123;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>        <span class="hljs-keyword">if</span>( BufferSize &lt; <span class="hljs-built_in">free</span> )<br>        &#123;<br>            <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, BufferSize );<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;buffer[used], Buffer, <span class="hljs-built_in">free</span> );<br>        Buffer = (<span class="hljs-type">uint8_t</span>*)Buffer + <span class="hljs-built_in">free</span>;<br>        BufferSize -= <span class="hljs-built_in">free</span>;<br>        TransformFunction(Context, Context-&gt;buffer, <span class="hljs-number">64</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>( BufferSize &gt;= <span class="hljs-number">64</span> )<br>    &#123;<br>        Buffer = TransformFunction( Context, Buffer, BufferSize &amp; ~(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)<span class="hljs-number">0x3f</span> );<br>        BufferSize &amp;= <span class="hljs-number">0x3f</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( Context-&gt;buffer, Buffer, BufferSize );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="结果输出"><a href="#结果输出" class="headerlink" title="结果输出"></a>结果输出</h5><p>处理完所有的512位的分组后，得到一组新的A,B,C,D的值，将这些值按ABCD的顺序级联，就得到了想要的MD5散列值。当然，输出依然要考虑内存存储的大小端问题。</p><p>代码讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Md5Finalise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Md5Context*         Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        MD5_HASH*           Digest          <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    used;<br>    <span class="hljs-type">uint32_t</span>    <span class="hljs-built_in">free</span>;<br><br>    used = Context-&gt;lo &amp; <span class="hljs-number">0x3f</span>;<br><br>    Context-&gt;buffer[used++] = <span class="hljs-number">0x80</span>;<br><br>    <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span> - used;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">free</span> &lt; <span class="hljs-number">8</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> );<br>        TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>        used = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">free</span> = <span class="hljs-number">64</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>( &amp;Context-&gt;buffer[used], <span class="hljs-number">0</span>, <span class="hljs-built_in">free</span> - <span class="hljs-number">8</span> );<br><br>    Context-&gt;lo &lt;&lt;= <span class="hljs-number">3</span>;<br>    Context-&gt;buffer[<span class="hljs-number">56</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo );<br>    Context-&gt;buffer[<span class="hljs-number">57</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">58</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">59</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;lo &gt;&gt; <span class="hljs-number">24</span> );<br>    Context-&gt;buffer[<span class="hljs-number">60</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi );<br>    Context-&gt;buffer[<span class="hljs-number">61</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">8</span> );<br>    Context-&gt;buffer[<span class="hljs-number">62</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">16</span> );<br>    Context-&gt;buffer[<span class="hljs-number">63</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;hi &gt;&gt; <span class="hljs-number">24</span> );<br><br>    TransformFunction( Context, Context-&gt;buffer, <span class="hljs-number">64</span> );<br>    <br>    <br>    <span class="hljs-comment">//-----------结果输出-----------------</span><br><br>    Digest-&gt;bytes[<span class="hljs-number">0</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a );<br>    Digest-&gt;bytes[<span class="hljs-number">1</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">2</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">3</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;a &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">4</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b );<br>    Digest-&gt;bytes[<span class="hljs-number">5</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">6</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">7</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;b &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">8</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c );<br>    Digest-&gt;bytes[<span class="hljs-number">9</span>]  = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">10</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">11</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;c &gt;&gt; <span class="hljs-number">24</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">12</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d );<br>    Digest-&gt;bytes[<span class="hljs-number">13</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">8</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">14</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">16</span> );<br>    Digest-&gt;bytes[<span class="hljs-number">15</span>] = (<span class="hljs-type">uint8_t</span>)( Context-&gt;d &gt;&gt; <span class="hljs-number">24</span> );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="MD5加盐"><a href="#MD5加盐" class="headerlink" title="MD5加盐"></a>MD5加盐</h3><p><a href="https://www.cnblogs.com/myseries/p/11581170.html">MD5算法+盐Salt - myseries - 博客园 (cnblogs.com)</a></p><p><strong>概念</strong>： MD5加盐是指在计算MD5哈希值时，向原始数据中添加一个随机的字符串（称为“盐”），以增强哈希值的安全性。盐的主要目的是防止使用预计算的哈希值（如彩虹表）进行攻击。(MD5加盐常用于密码存储、用户认证等需要保护敏感数据的场合)</p><p><strong>工作原理</strong>：</p><ol><li><strong>生成盐</strong>：为每个用户或数据生成一个随机字符串，通常长度在8至16字节之间。</li><li><strong>组合数据</strong>：将盐与原始数据（如密码）结合。可以是简单的拼接，或采用更复杂的方式。</li><li><strong>计算哈希</strong>：使用MD5算法计算组合后的数据的哈希值。</li></ol><h2 id="安全散列算法-Secure-Hash-Algorithm"><a href="#安全散列算法-Secure-Hash-Algorithm" class="headerlink" title="安全散列算法(Secure Hash Algorithm)"></a>安全散列算法(Secure Hash Algorithm)</h2><p>哈希函数的概念最早出现在计算机科学中，主要用于数据结构（如哈希表）和简单的完整性校验</p><h3 id="SHA-1算法"><a href="#SHA-1算法" class="headerlink" title="SHA-1算法"></a>SHA-1算法</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-1（Secure Hash Algorithm 1）是一种广泛使用的加密哈希函数，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于1995年。SHA-1生成一个160位（20字节）的哈希值，通常以40位十六进制数表示。(SHA-1已不再安全)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据的大小，SHA-1总是生成160位的哈希值。</li><li><strong>快速计算</strong>：SHA-1计算速度较快，适合处理大数据量。</li><li><strong>抗碰撞性</strong>：SHA-1设计上应保证不同输入产生不同哈希值，但随着研究的深入，已被发现存在碰撞漏洞。</li></ol><h4 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充和分块-1"><a href="#数据填充和分块-1" class="headerlink" title="数据填充和分块"></a>数据填充和分块</h5><p>将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。</p><p>其中分块与填充同MD5相同不多赘述</p><h5 id="初始化MD-Buffer"><a href="#初始化MD-Buffer" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-comment">// SHA1 initialisation constants</span><br>    Context-&gt;State[<span class="hljs-number">0</span>] = <span class="hljs-number">0x67452301</span>;<br>    Context-&gt;State[<span class="hljs-number">1</span>] = <span class="hljs-number">0xEFCDAB89</span>;<br>    Context-&gt;State[<span class="hljs-number">2</span>] = <span class="hljs-number">0x98BADCFE</span>;<br>    Context-&gt;State[<span class="hljs-number">3</span>] = <span class="hljs-number">0x10325476</span>;<br>    Context-&gt;State[<span class="hljs-number">4</span>] = <span class="hljs-number">0xC3D2E1F0</span>;<br>    Context-&gt;Count[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    Context-&gt;Count[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="16份子明文分组扩展为80份"><a href="#16份子明文分组扩展为80份" class="headerlink" title="16份子明文分组扩展为80份"></a>16份子明文分组扩展为80份</h5><p>扩充的方法:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1Z9eS.png" alt="image-20240919202000585"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> blk(i) (block-&gt;l[i&amp;15] = rol(block-&gt;l[(i+13)&amp;15] ^ block-&gt;l[(i+8)&amp;15] ^ block-&gt;l[(i+2)&amp;15] ^ block-&gt;l[i&amp;15],1))</span><br><span class="hljs-comment">//rol函数用于循环左移:</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rol(value, bits) (((value) <span class="hljs-string">&lt;&lt; (bits)) | ((value) &gt;</span>&gt; (32 - (bits))))</span><br></code></pre></td></tr></table></figure><h5 id="80份子明文分组进行4轮运算"><a href="#80份子明文分组进行4轮运算" class="headerlink" title="80份子明文分组进行4轮运算"></a>80份子明文分组进行4轮运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1ZSL8.png" alt="image-20240919203025400"></p><p>其中k为固定值：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eT4H.png" alt="2"></p><p>f函数为(之所以称为四轮运算的原因)：</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1eb8A.png" alt="1111"></p><h5 id="链接变量与初始链接变量进行求和运算"><a href="#链接变量与初始链接变量进行求和运算" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1eqgI.png" alt="image-20240919203559058"></p><p>这里的Ho就是初始化的5个常量</p><p>注意这里的”+”是指:</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mSUg.png" alt="image-20240919203941364"></p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span><br><span class="hljs-type">void</span><br>    <span class="hljs-title function_">TransformFunction</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            state[<span class="hljs-number">5</span>],</span><br><span class="hljs-params">        <span class="hljs-type">uint8_t</span> <span class="hljs-type">const</span>       buffer[<span class="hljs-number">64</span>]</span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>            a;<br>    <span class="hljs-type">uint32_t</span>            b;<br>    <span class="hljs-type">uint32_t</span>            c;<br>    <span class="hljs-type">uint32_t</span>            d;<br>    <span class="hljs-type">uint32_t</span>            e;<br>    <span class="hljs-type">uint8_t</span>             workspace[<span class="hljs-number">64</span>];<br>    CHAR64LONG16*       block = (CHAR64LONG16*) workspace;<br><br>    Load128BitsAsWords( block-&gt;l, buffer );<br><br>    <span class="hljs-comment">// Copy context-&gt;state[] to working vars</span><br>    a = state[<span class="hljs-number">0</span>];<br>    b = state[<span class="hljs-number">1</span>];<br>    c = state[<span class="hljs-number">2</span>];<br>    d = state[<span class="hljs-number">3</span>];<br>    e = state[<span class="hljs-number">4</span>];<br><br>    <span class="hljs-comment">// 4 rounds of 20 operations each. Loop unrolled.</span><br>    R0(a,b,c,d,e, <span class="hljs-number">0</span>); R0(e,a,b,c,d, <span class="hljs-number">1</span>); R0(d,e,a,b,c, <span class="hljs-number">2</span>); R0(c,d,e,a,b, <span class="hljs-number">3</span>);<br>    R0(b,c,d,e,a, <span class="hljs-number">4</span>); R0(a,b,c,d,e, <span class="hljs-number">5</span>); R0(e,a,b,c,d, <span class="hljs-number">6</span>); R0(d,e,a,b,c, <span class="hljs-number">7</span>);<br>    R0(c,d,e,a,b, <span class="hljs-number">8</span>); R0(b,c,d,e,a, <span class="hljs-number">9</span>); R0(a,b,c,d,e,<span class="hljs-number">10</span>); R0(e,a,b,c,d,<span class="hljs-number">11</span>);<br>    R0(d,e,a,b,c,<span class="hljs-number">12</span>); R0(c,d,e,a,b,<span class="hljs-number">13</span>); R0(b,c,d,e,a,<span class="hljs-number">14</span>); R0(a,b,c,d,e,<span class="hljs-number">15</span>);<br>    R1(e,a,b,c,d,<span class="hljs-number">16</span>); R1(d,e,a,b,c,<span class="hljs-number">17</span>); R1(c,d,e,a,b,<span class="hljs-number">18</span>); R1(b,c,d,e,a,<span class="hljs-number">19</span>);<br>    R2(a,b,c,d,e,<span class="hljs-number">20</span>); R2(e,a,b,c,d,<span class="hljs-number">21</span>); R2(d,e,a,b,c,<span class="hljs-number">22</span>); R2(c,d,e,a,b,<span class="hljs-number">23</span>);<br>    R2(b,c,d,e,a,<span class="hljs-number">24</span>); R2(a,b,c,d,e,<span class="hljs-number">25</span>); R2(e,a,b,c,d,<span class="hljs-number">26</span>); R2(d,e,a,b,c,<span class="hljs-number">27</span>);<br>    R2(c,d,e,a,b,<span class="hljs-number">28</span>); R2(b,c,d,e,a,<span class="hljs-number">29</span>); R2(a,b,c,d,e,<span class="hljs-number">30</span>); R2(e,a,b,c,d,<span class="hljs-number">31</span>);<br>    R2(d,e,a,b,c,<span class="hljs-number">32</span>); R2(c,d,e,a,b,<span class="hljs-number">33</span>); R2(b,c,d,e,a,<span class="hljs-number">34</span>); R2(a,b,c,d,e,<span class="hljs-number">35</span>);<br>    R2(e,a,b,c,d,<span class="hljs-number">36</span>); R2(d,e,a,b,c,<span class="hljs-number">37</span>); R2(c,d,e,a,b,<span class="hljs-number">38</span>); R2(b,c,d,e,a,<span class="hljs-number">39</span>);<br>    R3(a,b,c,d,e,<span class="hljs-number">40</span>); R3(e,a,b,c,d,<span class="hljs-number">41</span>); R3(d,e,a,b,c,<span class="hljs-number">42</span>); R3(c,d,e,a,b,<span class="hljs-number">43</span>);<br>    R3(b,c,d,e,a,<span class="hljs-number">44</span>); R3(a,b,c,d,e,<span class="hljs-number">45</span>); R3(e,a,b,c,d,<span class="hljs-number">46</span>); R3(d,e,a,b,c,<span class="hljs-number">47</span>);<br>    R3(c,d,e,a,b,<span class="hljs-number">48</span>); R3(b,c,d,e,a,<span class="hljs-number">49</span>); R3(a,b,c,d,e,<span class="hljs-number">50</span>); R3(e,a,b,c,d,<span class="hljs-number">51</span>);<br>    R3(d,e,a,b,c,<span class="hljs-number">52</span>); R3(c,d,e,a,b,<span class="hljs-number">53</span>); R3(b,c,d,e,a,<span class="hljs-number">54</span>); R3(a,b,c,d,e,<span class="hljs-number">55</span>);<br>    R3(e,a,b,c,d,<span class="hljs-number">56</span>); R3(d,e,a,b,c,<span class="hljs-number">57</span>); R3(c,d,e,a,b,<span class="hljs-number">58</span>); R3(b,c,d,e,a,<span class="hljs-number">59</span>);<br>    R4(a,b,c,d,e,<span class="hljs-number">60</span>); R4(e,a,b,c,d,<span class="hljs-number">61</span>); R4(d,e,a,b,c,<span class="hljs-number">62</span>); R4(c,d,e,a,b,<span class="hljs-number">63</span>);<br>    R4(b,c,d,e,a,<span class="hljs-number">64</span>); R4(a,b,c,d,e,<span class="hljs-number">65</span>); R4(e,a,b,c,d,<span class="hljs-number">66</span>); R4(d,e,a,b,c,<span class="hljs-number">67</span>);<br>    R4(c,d,e,a,b,<span class="hljs-number">68</span>); R4(b,c,d,e,a,<span class="hljs-number">69</span>); R4(a,b,c,d,e,<span class="hljs-number">70</span>); R4(e,a,b,c,d,<span class="hljs-number">71</span>);<br>    R4(d,e,a,b,c,<span class="hljs-number">72</span>); R4(c,d,e,a,b,<span class="hljs-number">73</span>); R4(b,c,d,e,a,<span class="hljs-number">74</span>); R4(a,b,c,d,e,<span class="hljs-number">75</span>);<br>    R4(e,a,b,c,d,<span class="hljs-number">76</span>); R4(d,e,a,b,c,<span class="hljs-number">77</span>); R4(c,d,e,a,b,<span class="hljs-number">78</span>); R4(b,c,d,e,a,<span class="hljs-number">79</span>);<br><br>    <span class="hljs-comment">// Add the working vars back into context.state[]</span><br>    state[<span class="hljs-number">0</span>] += a;<br>    state[<span class="hljs-number">1</span>] += b;<br>    state[<span class="hljs-number">2</span>] += c;<br>    state[<span class="hljs-number">3</span>] += d;<br>    state[<span class="hljs-number">4</span>] += e;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha1Update</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha1Context*        Context,        <span class="hljs-comment">// [in out]</span></span><br><span class="hljs-params">        <span class="hljs-type">void</span>  <span class="hljs-type">const</span>*        Buffer,         <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">        <span class="hljs-type">uint32_t</span>            BufferSize      <span class="hljs-comment">// [in]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span>    i;<br>    <span class="hljs-type">uint32_t</span>    j;<br><br>    j = (Context-&gt;Count[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">63</span>;<br>    <span class="hljs-keyword">if</span>( (Context-&gt;Count[<span class="hljs-number">0</span>] += BufferSize &lt;&lt; <span class="hljs-number">3</span>) &lt; (BufferSize &lt;&lt; <span class="hljs-number">3</span>) )<br>    &#123;<br>        Context-&gt;Count[<span class="hljs-number">1</span>]++;<br>    &#125;<br><br>    Context-&gt;Count[<span class="hljs-number">1</span>] += (BufferSize &gt;&gt; <span class="hljs-number">29</span>);<br>    <span class="hljs-keyword">if</span>( (j + BufferSize) &gt; <span class="hljs-number">63</span> )<br>    &#123;<br>        i = <span class="hljs-number">64</span> - j;<br>        <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], Buffer, i );<br>        TransformFunction(Context-&gt;State, Context-&gt;Buffer);<br>        <span class="hljs-keyword">for</span>( ; i + <span class="hljs-number">63</span> &lt; BufferSize; i += <span class="hljs-number">64</span> )<br>        &#123;<br>            TransformFunction(Context-&gt;State, (<span class="hljs-type">uint8_t</span>*)Buffer + i);<br>        &#125;<br>        j = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        i = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">memcpy</span>( &amp;Context-&gt;Buffer[j], &amp;((<span class="hljs-type">uint8_t</span>*)Buffer)[i], BufferSize - i );<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mp5Q.png" alt="image-20240919203902118"></p><p>代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pf">// Copy context-&gt;state[] <span class="hljs-keyword">to</span> working vars<br>  a = <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>];<br>  b = <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>];<br>  c = <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>];<br>  d = <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>];<br>  e = <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>];<br><br>  // <span class="hljs-number">4</span> rounds of <span class="hljs-number">20</span> operations each. Loop unrolled.<br>  ............<br>  .....<br>  .<br><br>  // Add the working vars back into context.<span class="hljs-keyword">state</span>[]<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">0</span>] += a;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">1</span>] += b;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">2</span>] += c;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">3</span>] += d;<br>  <span class="hljs-keyword">state</span>[<span class="hljs-number">4</span>] += e;<br></code></pre></td></tr></table></figure><h5 id="最后5个链接变量里面的数据就是SHA1摘要"><a href="#最后5个链接变量里面的数据就是SHA1摘要" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>在所有数据块处理完成后，5个链接变量的最终值即为SHA1的摘要值。</p><h3 id="SHA2算法"><a href="#SHA2算法" class="headerlink" title="SHA2算法"></a>SHA2算法</h3><h4 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>概述</strong>： SHA-2（Secure Hash Algorithm 2）是一组加密哈希函数的集合，由美国国家安全局（NSA）设计并由国家标准与技术研究所（NIST）发布于2001年。SHA-2包含多个变种，主要有SHA-224、SHA-256、SHA-384、SHA-512等，输出的哈希值长度分别为224、256、384和512位。</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出长度可变</strong>：SHA-2支持多种输出长度，适应不同安全需求。</li><li><strong>增强的安全性</strong>：相较于SHA-1，SHA-2提供更强的抗碰撞性和抗预映像性，当前被认为是安全的哈希算法。</li><li><strong>广泛应用</strong>：被广泛用于数据完整性验证、数字签名、SSL&#x2F;TLS证书等领域。</li></ol><h4 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h4><h5 id="数据填充与分组"><a href="#数据填充与分组" class="headerlink" title="数据填充与分组"></a>数据填充与分组</h5><p>同MD5 算法、SHA-1 算法，第一步还是要将数据填充为512 bits 的整数倍，也就是64字节的整数倍。这些n 段512bits(64字节)的数据会作为原始信息进行处理。</p><h5 id="初始化MD-Buffer-1"><a href="#初始化MD-Buffer-1" class="headerlink" title="初始化MD Buffer"></a>初始化MD Buffer</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>    <span class="hljs-title function_">Sha256Initialise</span><br>    <span class="hljs-params">(</span><br><span class="hljs-params">        Sha256Context*      Context         <span class="hljs-comment">// [out]</span></span><br><span class="hljs-params">    )</span><br>&#123;<br>    Context-&gt;curlen = <span class="hljs-number">0</span>;<br>    Context-&gt;length = <span class="hljs-number">0</span>;<br>    Context-&gt;state[<span class="hljs-number">0</span>] = <span class="hljs-number">0x6A09E667</span>UL;<br>    Context-&gt;state[<span class="hljs-number">1</span>] = <span class="hljs-number">0xBB67AE85</span>UL;<br>    Context-&gt;state[<span class="hljs-number">2</span>] = <span class="hljs-number">0x3C6EF372</span>UL;<br>    Context-&gt;state[<span class="hljs-number">3</span>] = <span class="hljs-number">0xA54FF53A</span>UL;<br>    Context-&gt;state[<span class="hljs-number">4</span>] = <span class="hljs-number">0x510E527F</span>UL;<br>    Context-&gt;state[<span class="hljs-number">5</span>] = <span class="hljs-number">0x9B05688C</span>UL;<br>    Context-&gt;state[<span class="hljs-number">6</span>] = <span class="hljs-number">0x1F83D9AB</span>UL;<br>    Context-&gt;state[<span class="hljs-number">7</span>] = <span class="hljs-number">0x5BE0CD19</span>UL;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="将512bits数据（164字节）扩展为644字节"><a href="#将512bits数据（164字节）扩展为644字节" class="headerlink" title="将512bits数据（164字节）扩展为644字节"></a>将512bits数据（16<em>4字节）扩展为64</em>4字节</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mCCj.png" alt="image-20240919212319707"></p><p><img src="https://s21.ax1x.com/2024/09/28/pA1mP8s.png" alt="image-20240919212345601"></p><h5 id="进入主循环，进行64次循环"><a href="#进入主循环，进行64次循环" class="headerlink" title="进入主循环，进行64次循环"></a>进入主循环，进行64次循环</h5><p><img src="https://s21.ax1x.com/2024/09/28/pA1mi2n.png" alt="image-20240919212616394"></p><p><img src="https://s2.loli.net/2024/09/29/HyfBTmEteP3s1h6.png" alt="image-20240919213245654.png"></p><p>注意A、B、C、D 、E、F、G、H分别是上一段512bits 处理后留下来的8个整数(<strong>第一次运算的时候这8个数为固定的常数</strong>)。在对该512bits 数据运算前需要先把这8个整数临时存起来（作为下一组运算的初始值，一直到64 次循环彻底结束。）。</p><p><img src="https://s2.loli.net/2024/09/29/2MSCtv1HZTLQg4o.png" alt="image-20240919212718907.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5ed7f15772e4ddc5d23f140f85027b53.gif" alt="W_t">表示一个32 bits(4个字节) 的输入数据(512bits 数据其中的32bits)，<img src="https://i-blog.csdnimg.cn/blog_migrate/23a5f8b290dde5116088d13bad292457.gif" alt="K_t"> 表示一个32bits 的常数(这个也是固定的)</p><p><img src="https://s2.loli.net/2024/09/29/21ld5pgQmVKWs3t.png" alt="image-20240919213306065.png"></p><h5 id="链接变量与初始链接变量进行求和运算-1"><a href="#链接变量与初始链接变量进行求和运算-1" class="headerlink" title="链接变量与初始链接变量进行求和运算"></a>链接变量与初始链接变量进行求和运算</h5><p><img src="https://s2.loli.net/2024/09/29/xurShl8HjsMXFZN.png" alt="image-20240919213011417.png"></p><h5 id="链接变量作为下一个明文分组的输入重复进行以上操作-1"><a href="#链接变量作为下一个明文分组的输入重复进行以上操作-1" class="headerlink" title="链接变量作为下一个明文分组的输入重复进行以上操作"></a>链接变量作为下一个明文分组的输入重复进行以上操作</h5><p>每次处理512位的分组数据，更新链接变量，重复此过程直到所有数据块被处理完毕。</p><h5 id="最后5个链接变量里面的数据就是SHA1摘要-1"><a href="#最后5个链接变量里面的数据就是SHA1摘要-1" class="headerlink" title="最后5个链接变量里面的数据就是SHA1摘要"></a>最后5个链接变量里面的数据就是SHA1摘要</h5><p>最后一段512bits 运算后得到最终的A、B、C、D、E，即为最终的160bits数，因为需要得到最后256bits(64 位16进制)的字符串，所以要将每个4字节的数转换成8位的16进制字符串。</p><hr><h2 id="消息认证码法-Message-Authentication-Code"><a href="#消息认证码法-Message-Authentication-Code" class="headerlink" title="消息认证码法(Message Authentication Code)"></a>消息认证码法(Message Authentication Code)</h2><p><img src="https://s2.loli.net/2024/09/29/PG2V5SeEJ4IvfxH.png" alt="image-20240919215256824"></p><p><strong>把哈希函数和密钥结合起来</strong>，将得到一个新的保护数据完整性的密码学原语——消息认证码(Message Authentication Code，MAC)。密钥是安全的基础：没有密钥就无法保证机密性，也无法实现认证性。虽然哈希函数可以为任意数据提供认证性或完整性，但它需要依赖于一个不可篡改的可信信道.</p><blockquote><p><em>比如：恶意用户可以修改cookie中的信息。若cookie中仅包含用户名及用户名的哈希值，则可以通过修改这些信息来模拟不同的用户</em></p><p><em>为了确保用户的cookie不被随意更改，我们可以使用上面提到的密码学原语。当用户第一次登录网站时，网站根据密钥和用户名生成一个认证标签，并让用户将用户名和认证标签存储在cookie中。由于不知道密钥，所以用户无法伪造其他用户名的有效认证标签。</em></p></blockquote><p>实现方式有：</p><table><thead><tr><th><strong>实现方式</strong></th><th><strong>原理</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>使用场景</strong></th></tr></thead><tbody><tr><td><strong>HMAC</strong></td><td>基于哈希函数与密钥结合，经过两次哈希生成认证码</td><td>简单易实现，支持多种哈希函数，安全性好</td><td>相较于其他方法，计算效率较低</td><td>网络协议（TLS、IPsec）、API认证、OAuth</td></tr><tr><td><strong>CMAC</strong></td><td>基于分组密码（如AES），通过分组加密生成认证码</td><td>适合硬件实现，安全性高</td><td>密钥管理相对复杂</td><td>无线通信协议（如IEEE 802.11i）、密码学库</td></tr><tr><td><strong>OMAC</strong></td><td>基于CMAC的简化版本，仅使用一个密钥</td><td>密钥管理简单，适合低资源场景</td><td>不适合并行计算</td><td>嵌入式系统</td></tr><tr><td><strong>PMAC</strong></td><td>通过块加密算法并行处理消息块生成认证码</td><td>支持并行处理，速度快</td><td>实现复杂度较高</td><td>高性能场景，如高速网络、数据加密存储</td></tr><tr><td><strong>GMAC</strong></td><td>基于Galois&#x2F;Counter Mode（GCM）模式生成认证码</td><td>高性能，支持并行处理</td><td>需要与加密模式结合使用</td><td>IPsec、TLS等加密协议</td></tr><tr><td><strong>Poly1305</strong></td><td>基于伪随机函数，通过模数运算生成认证码</td><td>轻量级设计，计算效率高</td><td>需要与ChaCha20等算法配合</td><td>嵌入式设备、高效加密协议（如TLS 1.3）</td></tr><tr><td><strong>CBC-MAC</strong></td><td>基于分组加密的CBC模式生成认证码</td><td>简单易实现</td><td>对变长消息不安全，容易受长度攻击</td><td>已被更安全的CMAC替代</td></tr></tbody></table><h3 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h3><h4 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h4><p><strong>HMAC</strong>（基于哈希的消息认证码）是一种通过哈希函数生成消息认证码的算法。它的主要作用是验证消息的完整性和真实性，防止消息在传输过程中被篡改。HMAC 结合了加密哈希函数（如SHA-256或SHA-1）和一个密钥，生成一个固定长度的消息摘要。</p><h4 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="https://s2.loli.net/2024/09/29/p4hcDSjUk9e3YG2.png" alt="image-20240919214933334"><br>其中：<br>H 为密码Hash函数（如MD5或SHA-2），能够对明文进行分组循环压缩；<br>k 为密钥（secret key）；<br>m 为要认证的消息；<br>k’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列）<br>ipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）；<br>opad 外部填充（0x363636…3636，一段十六进制常量)<br><img src="https://s2.loli.net/2024/09/29/2XDcgNFAbvwBxmG.png" alt="R-C"></p><p>a) 在密钥k后面添加0，或者对密钥k用H（Hash函数）进行处理，创建一个字长为B的字符串（B为Hash函数的明文分组长度）；<br>b) 将上一步生成的B字长的字符串ipad做异或运算；<br>c)将数据流m填充至第二步的结果字符串中；<br>d)用H作用于第三步生成的数据流；<br>e)将第一步生成的B字长字符串与opad做异或运算；<br>f)再将第四步的结果填充进第五步的结果中；<br>g)用H作用于第六步生成的数据流，输出最终结果。</p><hr><h2 id="国密-SM3"><a href="#国密-SM3" class="headerlink" title="国密(SM3)"></a>国密(SM3)</h2><h3 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h3><p><strong>概述</strong>： SM3是一种由中国国家密码管理局设计的加密哈希函数，属于国密算法系列，发布于2010年。SM3主要用于确保数据完整性和身份验证，输出的哈希值长度为256位。(SM3广泛应用于电子商务、数字签名、区块链和信息安全等领域)</p><p><strong>主要特性</strong>：</p><ol><li><strong>输出固定长度</strong>：无论输入数据大小，SM3总是生成256位的哈希值。</li><li><strong>安全性</strong>：SM3经过严格的安全评估，具有良好的抗碰撞性和抗预映像性，适合用于高安全性需求的场合。</li><li><strong>高效性</strong>：在硬件和软件实现上具有较高的效率，适合处理大规模数据。</li></ol><h3 id="算法流程-4"><a href="#算法流程-4" class="headerlink" title="算法流程"></a>算法流程</h3><h4 id="消息填充"><a href="#消息填充" class="headerlink" title="消息填充"></a>消息填充</h4><p><img src="https://s2.loli.net/2024/09/29/wTA6OfE2Yb4lJ5H.png" alt="image-20240920102423212"></p><h4 id="消息扩展"><a href="#消息扩展" class="headerlink" title="消息扩展"></a>消息扩展</h4><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再<strong>用这16个消息字递推生成剩余的116个消息字</strong>。</p><p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p><p><img src="https://s2.loli.net/2024/09/29/SYcCjgi3HDQW2pN.png" alt="image-20240920102620139"></p><h4 id="迭代压缩"><a href="#迭代压缩" class="headerlink" title="迭代压缩"></a>迭代压缩</h4><p>这块结构和SHA系列算法也比较相似，由初始化向量然后对于每一个扩展后的消息进行处理，直到处理完最后一个分块。</p><p><img src="https://s2.loli.net/2024/09/29/xBK6a4djoQMH5tV.jpg" alt="f0adf403fda784ac40e30771876caede (1)"></p><h5 id="压缩函数-核心"><a href="#压缩函数-核心" class="headerlink" title="压缩函数(核心)"></a>压缩函数(核心)</h5><p><img src="https://s2.loli.net/2024/09/29/1Ao9rcevbuyjOtM.png" alt="image-20240920103047143"></p><p>其中初值IV被放在A、B、C、D、E、F、G、H八个<a href="https://www.zhihu.com/search?q=32%E4%BD%8D%E5%8F%98%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:129692191%7D">32位变量</a>中</p><p>压缩函数将这八个变量进行64轮相同的计算，一轮的计算过程如下图所示：</p><p><img src="https://s2.loli.net/2024/09/29/PH7kIDdAfOyKMSc.jpg" alt="748a9c1bcf39b12e4d868474649ff333"></p><p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><p><img src="https://s2.loli.net/2024/09/29/DafG4M9qZjzh1LC.png" alt="image-20240920103309918"></p><p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p><h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="Base系列算法"><a href="#Base系列算法" class="headerlink" title="Base系列算法"></a>Base系列算法</h2><h3 id="Base16编码"><a href="#Base16编码" class="headerlink" title="Base16编码"></a>Base16编码</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Base16（也称为Hexadecimal或Hex）是一种常见的编码方式，用于将二进制数据转换为可读的文本格式。它使用16个不同的字符来表示每4位二进制数。Base16编码使用的字符集包括<code>0-9</code>和<code>A-F</code>，其中<code>A-F</code>代表10到15的数字。这种编码方式通常用于计算机系统中表示二进制数据，并且非常适合于调试和数据展示。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据（通常是字节）准备好。</li><li><strong>分组处理</strong>：将每个字节（8位）分解为两个4位的部分。</li><li><strong>映射字符</strong>：使用Base16字符集将每个4位部分映射为一个Base16字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base16字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base16编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base16字符转换为对应的4位二进制值。</li><li><strong>合并处理</strong>：将这些4位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base16 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* hexChars = <span class="hljs-string">&quot;0123456789ABCDEF&quot;</span>;<br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 每个字节对应两个十六进制字符</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &gt;&gt; <span class="hljs-number">4</span>]);   <span class="hljs-comment">// 高四位</span><br>        output.<span class="hljs-built_in">push_back</span>(hexChars[c &amp; <span class="hljs-number">0x0F</span>]); <span class="hljs-comment">// 低四位</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base16 解码函数</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">decodeHexChar</span><span class="hljs-params">(<span class="hljs-type">char</span> hexChar)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;F&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hexChar &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; hexChar &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> hexChar - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid hex character&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase16</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">length</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base16 input length&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    output.<span class="hljs-built_in">reserve</span>(input.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> high = <span class="hljs-built_in">decodeHexChar</span>(input[i]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> low = <span class="hljs-built_in">decodeHexChar</span>(input[i + <span class="hljs-number">1</span>]);<br>        output.<span class="hljs-built_in">push_back</span>((high &lt;&lt; <span class="hljs-number">4</span>) | low);  <span class="hljs-comment">// 高位和低位合并成一个字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase16</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase16</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base32编码"><a href="#Base32编码" class="headerlink" title="Base32编码"></a>Base32编码</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>Base32是一种编码方案，用于将二进制数据转换为可打印的文本格式。它使用32个不同的字符来表示每5位二进制数。Base32编码使用的字符集通常包括<code>A-Z</code>和<code>2-7</code>，这些字符在ASCII范围内都是可打印的。Base32通常用于需要对数据进行一定程度的可读性增强的场景，例如在URL中或在一些认证系统中。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好。</li><li><strong>分组处理</strong>：将数据分成每5位二进制的一组，每组对应一个Base32字符。</li><li><strong>映射字符</strong>：使用Base32字符集将每5位二进制数据映射为一个Base32字符。</li><li><strong>填充处理</strong>：如果数据长度不是5的倍数，使用<code>=</code>字符进行填充，以确保编码字符串的长度为8的倍数。</li><li><strong>输出结果</strong>：将所有映射得到的Base32字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base32编码后的字符串，并去除可能存在的填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base32字符转换为对应的5位二进制值。</li><li><strong>合并处理</strong>：将这些5位二进制值重新组合成字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE32_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span>;<br><br><span class="hljs-comment">// Base32 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 将缓冲区左移8位</span><br>        buffer |= c;   <span class="hljs-comment">// 将当前字节加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">5</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &gt;&gt; (bitsLeft - <span class="hljs-number">5</span>)) &amp; <span class="hljs-number">0x1F</span>]);  <span class="hljs-comment">// 取高5位</span><br>            bitsLeft -= <span class="hljs-number">5</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余位数不足5位的情况</span><br>    <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE32_ALPHABET[(buffer &lt;&lt; (<span class="hljs-number">5</span> - bitsLeft)) &amp; <span class="hljs-number">0x1F</span>]);<br>        paddingCount = (<span class="hljs-number">8</span> - (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">8</span>)) % <span class="hljs-number">8</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 Base32 的 &quot;=&quot; 填充字符</span><br>    output.<span class="hljs-built_in">append</span>(paddingCount, <span class="hljs-string">&#x27;=&#x27;</span>);<br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base32 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase32</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">int</span> buffer = <span class="hljs-number">0</span>, bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> paddingCount = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;=&#x27;</span>) &#123;<br>            paddingCount++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> index = BASE32_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base32 character&quot;</span>);<br>        &#125;<br><br>        buffer &lt;&lt;= <span class="hljs-number">5</span>;  <span class="hljs-comment">// 将缓冲区左移5位</span><br>        buffer |= index;  <span class="hljs-comment">// 将当前字符的值加入缓冲区</span><br>        bitsLeft += <span class="hljs-number">5</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (bitsLeft - <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 取高8位</span><br>            bitsLeft -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase32</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase32</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base58-编码"><a href="#Base58-编码" class="headerlink" title="Base58 编码"></a>Base58 编码</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Base58是一种用于将二进制数据编码为可打印字符的方案，广泛应用于加密货币（如比特币地址）等领域。Base58编码通过去除Base64编码中的某些容易混淆的字符（如<code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>），使编码结果更易于手动输入和读取。它使用58个可打印的ASCII字符，编码效率高，每4字节二进制数据编码为5个Base58字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>转换为整数</strong>：将二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：用58作为基数，将大整数逐步除以58，得到的余数用于索引Base58字符集，从而得到Base58字符。</li><li><strong>处理前导零</strong>：在编码结果前添加相应数量的Base58字符<code>1</code>，以保持与原始数据前导零的对应关系。</li><li><strong>输出结果</strong>：将所有映射得到的Base58字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base58编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base58字符转换为其在Base58字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个大整数。</li><li><strong>处理前导零</strong>：根据编码结果中的前导<code>1</code>的数量，将相应数量的前导零添加到解码结果中。</li><li><strong>转换为二进制数据</strong>：将大整数转换回二进制数据，得到原始数据。</li></ol><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE58_ALPHABET = <span class="hljs-string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span>;<br><br><span class="hljs-comment">// 辅助函数：将字节数组解释为大整数</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">toBigInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(input.begin(), input.end())</span></span>;<br>    <span class="hljs-keyword">return</span> bigInt;<br>&#125;<br><br><span class="hljs-comment">// Base58 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; digits;<br>    std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; bigInt = <span class="hljs-built_in">toBigInt</span>(input);<br><br>    <span class="hljs-comment">// 跳过前导的0字节</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte : bigInt) &#123;<br>        <span class="hljs-keyword">if</span> (byte == <span class="hljs-number">0</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将大整数转为Base58编码</span><br>    <span class="hljs-keyword">while</span> (!bigInt.<span class="hljs-built_in">empty</span>() &amp;&amp; *std::<span class="hljs-built_in">max_element</span>(bigInt.<span class="hljs-built_in">begin</span>(), bigInt.<span class="hljs-built_in">end</span>()) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = carry * <span class="hljs-number">256</span> + byte;<br>            byte = value / <span class="hljs-number">58</span>;<br>            carry = value % <span class="hljs-number">58</span>;<br>        &#125;<br>        digits.<span class="hljs-built_in">push_back</span>(carry);<br>    &#125;<br><br>    <span class="hljs-comment">// 将前导0字节编码为Base58的`1`字符</span><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;1&#x27;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 反转余数得到的Base58编码</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = digits.<span class="hljs-built_in">rbegin</span>(); it != digits.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += BASE58_ALPHABET[*it];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Base58 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase58</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt; <span class="hljs-title">bigInt</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-type">size_t</span> index = BASE58_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (index == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base58 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> carry = index;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&amp; byte : bigInt) &#123;<br>            <span class="hljs-type">int</span> value = byte * <span class="hljs-number">58</span> + carry;<br>            carry = value &gt;&gt; <span class="hljs-number">8</span>;<br>            byte = value &amp; <span class="hljs-number">0xFF</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (carry) &#123;<br>            bigInt.<span class="hljs-built_in">push_back</span>(carry &amp; <span class="hljs-number">0xFF</span>);<br>            carry &gt;&gt;= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理前导的&#x27;1&#x27;字符</span><br>    <span class="hljs-type">size_t</span> zeroCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            zeroCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">result</span><span class="hljs-params">(zeroCount, <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bigInt.<span class="hljs-built_in">rbegin</span>(); it != bigInt.<span class="hljs-built_in">rend</span>(); ++it) &#123;<br>        result += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(*it);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase58</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase58</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>Base64是一种广泛使用的编码方式，将二进制数据转换为可打印的ASCII字符。它常用于在需要将二进制数据嵌入到文本格式中时（如在电子邮件、URL、JSON等）。Base64将每3字节的二进制数据编码为4个ASCII字符，使得编码后的数据长度增加约33%。Base64字符集包括<code>A-Z</code>、<code>a-z</code>、<code>0-9</code>、<code>+</code>、<code>/</code>和<code>=</code>（作为填充字符）。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每3字节（24位）的一组，如果数据长度不足3字节，则使用填充字符<code>=</code>进行填充，以确保处理的字节数为3的倍数。</li><li><strong>转换为6位组</strong>：将每组24位二进制数据分成4组6位的二进制数。</li><li><strong>映射字符</strong>：使用Base64字符集将每6位二进制数据映射为一个Base64字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base64字符和填充字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base64编码后的字符串，并去除填充字符<code>=</code>。</li><li><strong>字符映射</strong>：将每个Base64字符转换为对应的6位二进制值。</li><li><strong>组合处理</strong>：将这些6位二进制值重新组合成24位的二进制数据。</li><li><strong>分解字节</strong>：将24位二进制数据分解为3个字节（8位），还原原始的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE64_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;<br><br><span class="hljs-comment">// Base64 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output; <span class="hljs-comment">// 存储编码后的输出字符串</span><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于存储当前处理的字符值</span><br>    <span class="hljs-type">int</span> bits = <span class="hljs-number">-6</span>; <span class="hljs-comment">// 当前处理的位数，初始化为 -6，因为我们要填充 6 位的 Base64 字符</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> b63 = <span class="hljs-number">0x3F</span>; <span class="hljs-comment">// 64 的二进制数（111111），用于获取 Base64 字符</span><br><br>    <span class="hljs-comment">// 遍历输入字符串的每一个字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        val = (val &lt;&lt; <span class="hljs-number">8</span>) + c; <span class="hljs-comment">// 将当前字符的 ASCII 值添加到 val 中，左移 8 位</span><br>        bits += <span class="hljs-number">8</span>; <span class="hljs-comment">// 增加已处理的位数</span><br><br>        <span class="hljs-comment">// 当处理的位数大于等于 0 时，进行编码</span><br>        <span class="hljs-keyword">while</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 从 val 中提取出高 6 位，并查找对应的 Base64 字符</span><br>            output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[(val &gt;&gt; bits) &amp; b63]);<br>            bits -= <span class="hljs-number">6</span>; <span class="hljs-comment">// 每次处理 6 位，减少 bits 的值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位，如果还有剩余的 bits &gt; -6，则需要继续编码</span><br>    <span class="hljs-keyword">if</span> (bits &gt; <span class="hljs-number">-6</span>) &#123;<br>        <span class="hljs-comment">// 将剩余的位向左移动并提取对应的 Base64 字符</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE64_ALPHABET[((val &lt;&lt; <span class="hljs-number">8</span>) &gt;&gt; (bits + <span class="hljs-number">8</span>)) &amp; b63]);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 output 的大小不是 4 的倍数，则添加 &#x27;=&#x27; 作为填充</span><br>    <span class="hljs-keyword">while</span> (output.<span class="hljs-built_in">size</span>() % <span class="hljs-number">4</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-comment">// 添加填充字符 &#x27;=&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output; <span class="hljs-comment">// 返回编码后的 Base64 字符串</span><br>&#125;<br><br><br><span class="hljs-comment">// Base64 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase64</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>        T[BASE64_ALPHABET[i]] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>, bits = <span class="hljs-number">-8</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c : input) &#123;<br>        <span class="hljs-keyword">if</span> (T[c] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;<br>        val = (val &lt;&lt; <span class="hljs-number">6</span>) + T[c];<br>        bits += <span class="hljs-number">6</span>;<br><br>        <span class="hljs-keyword">if</span> (bits &gt;= <span class="hljs-number">0</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">char</span>((val &gt;&gt; bits) &amp; <span class="hljs-number">0xFF</span>));<br>            bits -= <span class="hljs-number">8</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase64</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    std::string decoded = <span class="hljs-built_in">decodeBase64</span>(encoded);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base85编码"><a href="#Base85编码" class="headerlink" title="Base85编码"></a>Base85编码</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>Base85是一种用于将二进制数据转换为可打印字符的编码方案。它通过使用85个不同的ASCII字符来表示每4字节（32位）的二进制数据。这种编码方式常用于需要将二进制数据嵌入文本中的场景，如在PDF文件中。相比于Base64，Base85编码能够以更高的效率将数据压缩成更短的字符串，因为每4字节的二进制数据在Base85中编码为5个字符。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每4字节（32位）的组，如果数据长度不足4字节，则进行填充。</li><li><strong>转换为整数</strong>：将每4字节的二进制数据转换为一个32位的整数。</li><li><strong>映射字符</strong>：将32位整数转换为5个Base85字符。具体来说，整数被逐步除以85，得到的余数对应Base85字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base85字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base85编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base85字符转换为Base85字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个32位的整数。</li><li><strong>分解字节</strong>：将32位整数转换回4字节（32位）的二进制数据。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-type">const</span> std::string BASE85_ALPHABET = <span class="hljs-string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!#$%&amp;()*+-;&lt;=&gt;?@^_`&#123;|&#125;~&quot;</span>;<br><br><span class="hljs-comment">// Base85 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        buffer = buffer * <span class="hljs-number">256</span> + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(input[i]);<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>                buffer /= <span class="hljs-number">85</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">end</span>());<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        buffer &lt;&lt;= (<span class="hljs-number">4</span> - count) * <span class="hljs-number">8</span>;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">encoded</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">4</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            encoded[j] = BASE85_ALPHABET[buffer % <span class="hljs-number">85</span>];<br>            buffer /= <span class="hljs-number">85</span>;<br>        &#125;<br>        output.<span class="hljs-built_in">append</span>(encoded.<span class="hljs-built_in">begin</span>(), encoded.<span class="hljs-built_in">begin</span>() + count + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base85 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase85</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE85_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base85 character&quot;</span>);<br>        &#125;<br>        buffer = buffer * <span class="hljs-number">85</span> + pos;<br>        ++count;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>            &#125;<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = count; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>            buffer = buffer * <span class="hljs-number">85</span> + <span class="hljs-number">84</span>;  <span class="hljs-comment">// 用最大值填充</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">3</span>; j &gt;= <span class="hljs-number">4</span> - count; --j) &#123;<br>            output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; (j * <span class="hljs-number">8</span>)) &amp; <span class="hljs-number">0xFF</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase85</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase85</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base91编码"><a href="#Base91编码" class="headerlink" title="Base91编码"></a>Base91编码</h3><h4 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h4><p>Base91是一种编码方案，用于将二进制数据转换为可打印的ASCII字符。它使用91个字符来表示每13位的二进制数据。Base91设计的目的是在保证编码效率的同时，提供更好的数据密度比Base64和Base85。Base91编码通常用于需要高数据密度的应用场景，例如某些压缩算法和数据传输协议。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每13位（即1.625字节）的组。由于13位并不整除8位字节，因此每个Base91编码块处理的字节数可能会有所不同。</li><li><strong>转换为整数</strong>：将每组13位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base91字符。整数会被逐步除以91，得到的余数对应Base91字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base91字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base91编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base91字符转换为Base91字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个13位的二进制整数。</li><li><strong>分解字节</strong>：将13位的二进制整数转换回原始的字节数据。这可能涉及到将整数拆分为多个字节（通常是2或3个字节）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base91 字符集</span><br><span class="hljs-type">const</span> std::string BASE91_ALPHABET = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;</span><br>                                    <span class="hljs-string">&quot;!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~\&quot;&quot;</span>;<br><br><span class="hljs-comment">// Base91 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer |= (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(c) &lt;&lt; bitsLeft);<br>        bitsLeft += <span class="hljs-number">8</span>;<br><br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">13</span>) &#123;<br>            <span class="hljs-type">uint32_t</span> value = buffer &amp; <span class="hljs-number">8191</span>;  <span class="hljs-comment">// 取13位</span><br>            <span class="hljs-keyword">if</span> (value &gt; <span class="hljs-number">88</span>) &#123;                <span class="hljs-comment">// 处理特殊情况</span><br>                buffer &gt;&gt;= <span class="hljs-number">13</span>;<br>                bitsLeft -= <span class="hljs-number">13</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                value = buffer &amp; <span class="hljs-number">16383</span>;      <span class="hljs-comment">// 取14位</span><br>                buffer &gt;&gt;= <span class="hljs-number">14</span>;<br>                bitsLeft -= <span class="hljs-number">14</span>;<br>            &#125;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value % <span class="hljs-number">91</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[value / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余不足13位的部分</span><br>    <span class="hljs-keyword">if</span> (bitsLeft) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer % <span class="hljs-number">91</span>]);<br>        <span class="hljs-keyword">if</span> (bitsLeft &gt; <span class="hljs-number">7</span> || buffer &gt; <span class="hljs-number">90</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE91_ALPHABET[buffer / <span class="hljs-number">91</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base91 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase91</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint32_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> bitsLeft = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> value = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        <span class="hljs-keyword">auto</span> pos = BASE91_ALPHABET.<span class="hljs-built_in">find</span>(c);<br>        <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base91 character&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-number">0</span>) &#123;<br>            value = pos;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            value += pos * <span class="hljs-number">91</span>;<br>            buffer |= value &lt;&lt; bitsLeft;<br>            bitsLeft += (value &amp; <span class="hljs-number">8191</span>) &gt; <span class="hljs-number">88</span> ? <span class="hljs-number">13</span> : <span class="hljs-number">14</span>;<br><br>            <span class="hljs-keyword">while</span> (bitsLeft &gt;= <span class="hljs-number">8</span>) &#123;<br>                output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);<br>                buffer &gt;&gt;= <span class="hljs-number">8</span>;<br>                bitsLeft -= <span class="hljs-number">8</span>;<br>            &#125;<br>            value = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的位</span><br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0</span>) &#123;<br>        output.<span class="hljs-built_in">push_back</span>(buffer | (value &lt;&lt; bitsLeft));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase91</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase91</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Base100编码"><a href="#Base100编码" class="headerlink" title="Base100编码"></a>Base100编码</h3><h4 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h4><p>Base100是一种用于将二进制数据转换为可打印字符的编码方案。它使用100个不同的字符来表示每16位的二进制数据。这种编码方式在字符集选择上较为宽松，通常选择可打印的ASCII字符。Base100的设计旨在提供比Base64和Base85更高的数据密度，使得编码后的数据更为紧凑。</p><p>编码步骤</p><ol><li><strong>输入数据准备</strong>：将要编码的二进制数据准备好，通常是字节流。</li><li><strong>分组处理</strong>：将数据分成每16位（即2字节）的组。如果数据长度不足2字节，则进行填充。</li><li><strong>转换为整数</strong>：将每16位的二进制数据转换为一个大整数。</li><li><strong>映射字符</strong>：将这个整数转换为Base100字符。整数会被逐步除以100，得到的余数对应Base100字符集中的字符。</li><li><strong>输出结果</strong>：将所有映射得到的Base100字符连接起来，形成编码后的字符串。</li></ol><p>解码步骤</p><ol><li><strong>输入数据准备</strong>：获取Base100编码后的字符串。</li><li><strong>字符映射</strong>：将每个Base100字符转换为Base100字符集中的索引值。</li><li><strong>转换为整数</strong>：将这些索引值重新组合成一个16位的二进制整数。</li><li><strong>分解字节</strong>：将16位的二进制整数转换回原始的字节数据，通常是2个字节（或1个字节的填充情况）。</li><li><strong>输出结果</strong>：将还原后的字节数据输出，形成解码后的原始数据。</li></ol><h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><br><span class="hljs-comment">// Base100 字符集 (ASCII 范围: 33-132)</span><br><span class="hljs-type">const</span> std::string BASE100_ALPHABET = <span class="hljs-string">&quot; !\&quot;#$%&amp;&#x27;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz&#123;|&#125;~&quot;</span><br>                                     <span class="hljs-string">&quot;€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ&quot;</span>;<br><br><span class="hljs-comment">// Base100 编码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">encodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c : input) &#123;<br>        buffer = (buffer &lt;&lt; <span class="hljs-number">8</span>) | c;<br>        count++;<br><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">2</span>) &#123;<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>            output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>            buffer = <span class="hljs-number">0</span>;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的字节</span><br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        buffer &lt;&lt;= <span class="hljs-number">8</span>;  <span class="hljs-comment">// 填充一个字节</span><br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer / <span class="hljs-number">100</span>]);<br>        output.<span class="hljs-built_in">push_back</span>(BASE100_ALPHABET[buffer % <span class="hljs-number">100</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-comment">// Base100 解码函数</span><br><span class="hljs-function">std::string <span class="hljs-title">decodeBase100</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; input)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 input length.&quot;</span>);<br>    &#125;<br><br>    std::string output;<br>    <span class="hljs-type">uint16_t</span> buffer = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; input.<span class="hljs-built_in">size</span>(); i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> index1 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i]);<br>        <span class="hljs-type">int</span> index2 = BASE100_ALPHABET.<span class="hljs-built_in">find</span>(input[i + <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-keyword">if</span> (index1 == std::string::npos || index2 == std::string::npos) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid Base100 character.&quot;</span>);<br>        &#125;<br><br>        buffer = index1 * <span class="hljs-number">100</span> + index2;<br>        output.<span class="hljs-built_in">push_back</span>((buffer &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 高字节</span><br>        output.<span class="hljs-built_in">push_back</span>(buffer &amp; <span class="hljs-number">0xFF</span>);         <span class="hljs-comment">// 低字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> output;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string data = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 原始数据</span><br><br>    <span class="hljs-comment">// 编码</span><br>    std::string encoded = <span class="hljs-built_in">encodeBase100</span>(data);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Encoded: &quot;</span> &lt;&lt; encoded &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 解码</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::string decoded = <span class="hljs-built_in">decodeBase100</span>(encoded);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Decoded: &quot;</span> &lt;&lt; decoded &lt;&lt; std::endl;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/0yst3r-2046/p/11962942.html">Base系列编码浅析【base16 base32 base64 base85 base36 base 58 base91 base 92 base62】 - 0yst3r - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.equinox.chat/archives/45/">Base系列编码详解 - 二进制学习 (equinox.chat)</a></p><p><a href="https://blog.csdn.net/m0_62690279/article/details/123941239">常见加密算法总结-base系列部分_base加密-CSDN博客</a></p><p><a href="https://danielxuuuuu.github.io/2019/11/18/MD5%E7%AE%97%E6%B3%95%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84">MD5算法的C语言实现 · Daniel’s Studio (danielxuuuuu.github.io)</a></p><p><a href="https://www.cnblogs.com/foxclever/p/7668369.html">信息摘要算法之一：MD5算法解析及实现 - Moonan - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/450180396">RSA —— 经典的非对称加密算法 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/78913397">密码学基础：AES加密算法 - 知乎 (zhihu.com)</a></p><p><a href="http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">RSA算法原理（二） - 阮一峰的网络日志 (ruanyifeng.com)</a></p><p>[RSA算法详解 - 飞翔的大熊 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B">https://www.cnblogs.com/richard-xiong/p/9923283.html#:~:text=RSA算法流程</a> 1 生成秘钥 选择两个不相等的质数p%2Cq 计算p%2Cq的乘积n 计算n的欧拉函数φ (n)%3D (p-1)*,根据上面的公式可以算出密文C 解密 接收方获取密文c，使用自己的私钥 (n%2Cd)依照如下公式解密 c^d%3Dm (mod n) c%2Cd%2Cn已知，可以算出明文m)</p><p><a href="https://blog.csdn.net/s2603898260/article/details/122389816">RSA 算法图解+数学证明_rsa算法流程图-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/98514678">AES加密算法流程介绍 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/TheSkyLee/article/details/108699243">一文彻底搞懂加密、数字签名和数字证书，看不懂你打我！-CSDN博客</a></p><p><a href="https://blog.csdn.net/xiao__1bai/article/details/123307059">解析 TEA 加密算法(C语言、python)：_tea加密-CSDN博客</a></p><p><a href="https://www.cnblogs.com/shelmean/p/14281332.html">RC4加密算法 - shelmean - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1c34y1M7NW/?spm_id_from=333.999.0.0">HMAC | MAC | 基于哈希函数的消息认证码</a></p>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AES算法原理与逆向练习</title>
    <link href="/2023/06/05/AES%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0/"/>
    <url>/2023/06/05/AES%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E4%B8%8E%E9%80%86%E5%90%91%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
      <category>对称密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件格式解析</title>
    <link href="/2023/05/08/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/08/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要以x64架构为解析对象(x32功能实现相似)，使用C++编写ELF解析器，实现readel大多数功能。建议读者阅读前浏览官方ELF64文档：</p><p><a href="https://uclibc.org/docs/elf-64-gen.pdf">ELF-64 Object File Format</a></p><p>初次借着学习elf结构进行编写，如有纰漏请多指正</p></blockquote><h1 id="从源代码编写到最终生成可执行文件"><a href="#从源代码编写到最终生成可执行文件" class="headerlink" title="从源代码编写到最终生成可执行文件"></a>从源代码编写到最终生成可执行文件</h1><p><img src="https://s2.loli.net/2024/12/16/OnRbL8FDeEiHs9f.jpg" alt="1"></p><p>编译器原理：</p><p><img src="https://s2.loli.net/2024/12/16/KIi5EDF7JPkjyB9.jpg" alt="2"></p><p>汇编器原理：</p><p>汇编器将汇编代码作为输入并将其转换为可重定位的机器代码。汇编器检查每条指令的正确性并生成诊断消息。</p><p><img src="https://s2.loli.net/2024/12/16/PafYKlsAFJ8OWro.png" alt="image-20241216142318994"></p><h1 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h1><h2 id="ELF整体结构"><a href="#ELF整体结构" class="headerlink" title="ELF整体结构"></a>ELF整体结构</h2><p>如下图所示:</p><p><img src="https://s2.loli.net/2024/12/16/ct3oTXChOJZeDq2.png" alt="ELF文件格式"></p><p>更详细一点：</p><p><img src="https://s2.loli.net/2024/12/16/X5WAjmOb8e1fkls.png" alt="ELF文件格式"></p><p>注意：可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。程序头表描述了ELF文件中Segment在文件中的布局，描述了OS该如何装载可执行文件到内存</p><p>ELF 文件的基本结构由以下几个主要部分组成：</p><ol><li><strong>ELF Header（ELF 文件头）</strong></li><li><strong>Program Header Table（程序头表）</strong></li><li><strong>Section Header Table（节头表）</strong></li><li><strong>Data Sections（数据节）</strong></li><li><strong>Dynamic Section（动态节，针对共享库或动态加载的情况）</strong></li><li><strong>String Table（字符串表，通常存储符号名称、节名称等）</strong></li></ol><p>其中，<strong>Program Header Table</strong> 和 <strong>Section Header Table</strong> 是两种不同的表格，它们分别用于描述不同类型的信息：<code>Program Header</code> 用于描述文件加载到内存时的映射，而 <code>Section Header</code> 用于描述文件内部的具体内容（如代码段、数据段等）。</p><h3 id="1-ELF-Header（ELF-文件头）"><a href="#1-ELF-Header（ELF-文件头）" class="headerlink" title="1. ELF Header（ELF 文件头）"></a>1. ELF Header（ELF 文件头）</h3><p>ELF 文件的开头是一个固定大小的 ELF 文件头，它包含了文件格式和该文件结构的基本信息。主要字段有：</p><ul><li>**e_ident[16]**：一个 16 字节的数组，用于标识 ELF 文件的类型和版本信息。<ul><li><code>e_ident[0]</code> 和 <code>e_ident[1]</code> 为魔数，值为 <code>0x7f &#39;E&#39; &#39;L&#39; &#39;F&#39;</code>，用于标识 ELF 文件。</li><li><code>e_ident[4]</code> 为目标架构，值通常是 <code>ELF32</code> 或 <code>ELF64</code>。</li><li><code>e_ident[5]</code> 表示数据编码格式（如小端或大端）。</li><li><code>e_ident[6]</code> 为 ELF 版本号，通常为 1。</li><li><code>e_ident[7]</code> 为操作系统版本（通常是 0）。</li></ul></li><li><strong>e_type</strong>：表示 ELF 文件的类型，常见值有：<ul><li><code>ET_EXEC</code>：可执行文件（Executable File）。</li><li><code>ET_DYN</code>：共享库（Shared Object）。</li><li><code>ET_REL</code>：重定位文件（Relocatable File）。</li></ul></li><li><strong>e_machine</strong>：指定该 ELF 文件运行的目标架构，如 <code>EM_386</code> 表示 x86，<code>EM_X86_64</code> 表示 x86-64。</li><li><strong>e_version</strong>：文件版本号，通常是 1。</li><li><strong>e_entry</strong>：程序入口地址，指示程序执行开始的位置。</li><li><strong>e_phoff</strong>：程序头表的偏移量，指示程序头在文件中的位置。</li><li><strong>e_shoff</strong>：节头表的偏移量，指示节头表在文件中的位置。</li><li><strong>e_flags</strong>：架构相关的标志（例如，x86 处理器的标志）。</li><li><strong>e_ehsize</strong>：ELF 文件头的大小。</li><li><strong>e_phentsize</strong>：程序头表中每个条目的大小。</li><li><strong>e_phnum</strong>：程序头表的条目数量。</li><li><strong>e_shentsize</strong>：节头表中每个条目的大小。</li><li><strong>e_shnum</strong>：节头表的条目数量。</li><li><strong>e_shstrndx</strong>：节头表中字符串表的位置索引。</li></ul><h3 id="2-Program-Header-Table（程序头表）"><a href="#2-Program-Header-Table（程序头表）" class="headerlink" title="2. Program Header Table（程序头表）"></a>2. Program Header Table（程序头表）</h3><p>程序头表是 ELF 文件中的一个重要部分，描述了文件中每个可加载段的信息。每个条目包含以下信息：</p><ul><li><strong>p_type</strong>：段的类型，如 <code>PT_LOAD</code>（可加载段），<code>PT_DYNAMIC</code>（动态段），<code>PT_INTERP</code>（解释器段）等。</li><li><strong>p_offset</strong>：该段在 ELF 文件中的偏移量。</li><li><strong>p_vaddr</strong>：段在内存中的虚拟地址。</li><li><strong>p_paddr</strong>：段的物理地址（在大多数现代系统中为 0）。</li><li><strong>p_filesz</strong>：段在文件中的大小。</li><li><strong>p_memsz</strong>：段在内存中的大小。</li><li><strong>p_flags</strong>：段的访问权限标志，如可读（<code>PF_R</code>），可写（<code>PF_W</code>），可执行（<code>PF_X</code>）等。</li><li><strong>p_align</strong>：段在内存中的对齐要求。</li></ul><h3 id="3-Section-Header-Table（节头表）"><a href="#3-Section-Header-Table（节头表）" class="headerlink" title="3. Section Header Table（节头表）"></a>3. Section Header Table（节头表）</h3><p>节头表是一个包含 ELF 文件中各个节（Section）描述的表。每个节是 ELF 文件的一个独立部分，包含程序的代码、数据、符号表、调试信息等。每个节由一个节头描述，字段包括：</p><ul><li><p><strong>sh_name</strong>：节名称的字符串表索引。</p></li><li><p>sh_type</p><p>：节的类型，常见的类型包括：</p><ul><li><code>SHT_PROGBITS</code>：包含程序数据。</li><li><code>SHT_SYMTAB</code>：符号表。</li><li><code>SHT_STRTAB</code>：字符串表。</li><li><code>SHT_RELA</code>：重定位表。</li><li><code>SHT_DYNAMIC</code>：动态链接信息。</li></ul></li><li><p><strong>sh_flags</strong>：节的标志，如 <code>SHF_ALLOC</code>（该节需要在内存中加载），<code>SHF_EXECINSTR</code>（该节包含可执行代码）等。</p></li><li><p><strong>sh_addr</strong>：节在内存中的虚拟地址（如果该节需要加载到内存）。</p></li><li><p><strong>sh_offset</strong>：节在文件中的偏移量。</p></li><li><p><strong>sh_size</strong>：节的大小。</p></li><li><p><strong>sh_link</strong>：与该节相关联的其他节的索引（例如符号表和字符串表之间的关联）。</p></li><li><p><strong>sh_info</strong>：该字段的具体含义依赖于节的类型。</p></li><li><p><strong>sh_addralign</strong>：节的对齐要求。</p></li><li><p><strong>sh_entsize</strong>：节中每个条目的大小（如果适用）。</p></li></ul><h3 id="4-数据节（Data-Sections）"><a href="#4-数据节（Data-Sections）" class="headerlink" title="4. 数据节（Data Sections）"></a>4. 数据节（Data Sections）</h3><p>数据节包含 ELF 文件中各种数据和信息。例如：</p><ul><li><strong>.text</strong>：通常包含程序的可执行代码。</li><li><strong>.data</strong>：包含已初始化的全局变量和静态变量。</li><li><strong>.bss</strong>：包含未初始化的全局变量和静态变量（程序启动时会清零）。</li><li><strong>.rodata</strong>：只读数据，如常量字符串。</li><li><strong>.dynamic</strong>：动态链接信息（动态库相关的符号和重定位信息）。</li><li><strong>.symtab</strong>：符号表，用于存储符号名称和地址等信息。</li><li><strong>.strtab</strong>：字符串表，存储字符串数据，如符号表中符号的名称。</li></ul><h3 id="5-动态节（Dynamic-Section）"><a href="#5-动态节（Dynamic-Section）" class="headerlink" title="5. 动态节（Dynamic Section）"></a>5. 动态节（Dynamic Section）</h3><p>动态节在动态链接程序中非常重要，它存储与程序在运行时加载和链接相关的信息。常见字段有：</p><ul><li><strong>DT_NEEDED</strong>：需要的共享库。</li><li><strong>DT_SONAME</strong>：共享库的名称。</li><li><strong>DT_SYMBOLIC</strong>：指定共享库的符号是否应该全局可见。</li></ul><h3 id="6-字符串表（String-Table）"><a href="#6-字符串表（String-Table）" class="headerlink" title="6. 字符串表（String Table）"></a>6. 字符串表（String Table）</h3><p>ELF 文件使用字符串表存储符号、节、程序头等各种名称信息。它通常存储在一个 <code>.strtab</code> 节中。</p><h3 id="7-重定位信息"><a href="#7-重定位信息" class="headerlink" title="7. 重定位信息"></a>7. 重定位信息</h3><p>ELF 文件中的重定位节（如 <code>.rela</code> 或 <code>.rel</code> 节）用于动态链接时解决符号地址。重定位项包含了一个符号的地址，并指示程序在加载时如何进行修改。</p><p><img src="https://s2.loli.net/2024/11/28/jNrA5GCPpEOymML.png" alt="2052730-20220612221409797-515360683"></p><h2 id="ELF具体结构"><a href="#ELF具体结构" class="headerlink" title="ELF具体结构"></a>ELF具体结构</h2><h3 id="ELF头-ELF-Header"><a href="#ELF头-ELF-Header" class="headerlink" title="ELF头(ELF Header)"></a>ELF头(ELF Header)</h3><p><strong>概述文件结构和基本信息</strong>：ELF 文件头是 ELF 文件的入口，它包含描述文件布局和格式的关键信息。提取文件总体信息，指导后续程序头表、节头表等解析工作。</p><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_hdr</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> e_indet[EI_NIDENT];<span class="hljs-comment">//ELF文件的描述，是一个16字节的标识，表明当前文件的数据格式，位数等[16B]</span><br>    Elf64_Half e_type;<span class="hljs-comment">//文件的标识字段标识文件的类型；比如可执行文件，共享目标文件[2B]</span><br>    Elf64_Half e_machine;<span class="hljs-comment">//目标文件的体系结构(处理器架构)[2B]</span><br>    Elf64_Half e_version;<span class="hljs-comment">//当前文件的版本[2B]</span><br><br>    Elf64_Addr e_entry;<span class="hljs-comment">//程序的虚拟入口地址[8B]</span><br>    Elf64_Off  e_phoff;<span class="hljs-comment">//程序头表的偏移地址[8B]</span><br>    Elf64_Off  e_shoff;<span class="hljs-comment">//段表/节表的偏移[8B]</span><br><br>    Elf64_Word e_flags; <span class="hljs-comment">//处理器相关的标志位[4B]</span><br>    Elf64_Half e_ehsize; <span class="hljs-comment">//ELF文件头的大小[2B]</span><br><br>    Elf64_Half e_phentsize;<span class="hljs-comment">//程序头表的单项大小[2B]</span><br>    Elf64_Half e_phnum;<span class="hljs-comment">//程序头表的单项数目[2B]</span><br><br>    Elf64_Half e_shentsize;<span class="hljs-comment">//节表中单项的大小[2B]</span><br>    Elf64_Half e_shnum;<span class="hljs-comment">//节表中单项的数目[2B]</span><br>    Elf64_Half e_shstrndx;<span class="hljs-comment">//节表中节名的索引[2B]------- 存储节名称，它包含所有节头的名字，如 .text, .data, .bss, 等等。</span><br>&#125;Elf64_hdr;<br></code></pre></td></tr></table></figure><h4 id="解析代码："><a href="#解析代码：" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfHeaderParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-number">0</span>, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(elf64_hdr, <span class="hljs-built_in">sizeof</span>(Elf64_hdr), <span class="hljs-number">1</span>, fp);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Magic:\t\t\t&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; EI_NIDENT; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02x &quot;</span>, elf64_hdr-&gt;e_indet[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件格式:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知的文件格式\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;重定向文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;可执行文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;共享文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Core转储文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0xff00</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;特定处理器的文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0xffff</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;特定处理器的文件\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;处理器体系结构:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_machine)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;未知体系结构\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AT&amp;T WE 32100\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SPARC\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intel Architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Motorola 68000\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Motorola 88000\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Intel 80860\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MIPS RS3000 Big-Endian\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;MIPS RS4000 Big-Endian\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AMD x86-64 architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">183</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;AArch64 architecture\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;version:\t\t&quot;</span>);<br>    <span class="hljs-keyword">switch</span> (elf64_hdr-&gt;e_version) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>); <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序入口虚拟地址:\t0x%016x\n&quot;</span>, elf64_hdr-&gt;e_entry);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的偏移地址:\t0x%08x\n&quot;</span>, elf64_hdr-&gt;e_phoff);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;段表/节表的编译地址：\t0x%08x\n&quot;</span>, elf64_hdr-&gt;e_shoff);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;处理器标志位:\t\t%x\n&quot;</span>, elf64_hdr-&gt;e_flags);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ELF文件头大小:\t\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_ehsize);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的单项大小:\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_phentsize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序头表的单项数量:\t%u\n&quot;</span>, elf64_hdr-&gt;e_phnum);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节表的单项大小:\t%u bytes\n&quot;</span>, elf64_hdr-&gt;e_shentsize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;节表的单项数量:\t%u\n&quot;</span>, elf64_hdr-&gt;e_shnum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串表在节头表中索引:\t%u\n&quot;</span>, elf64_hdr-&gt;e_shstrndx);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/iptQJ2Z4duKga5c.png" alt="image-20241222095101754"></p><h3 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h3><p><strong>描述程序的内存映射方式</strong>：用于运行时加载 ELF 文件的指令，告诉加载器哪些部分需要映射到内存。处理与加载相关的段，例如 <code>.text</code>（代码段）、<code>.data</code>（数据段）、<code>.dynamic</code>（动态段）等。用于动态链接器加载共享库或可执行文件。</p><h4 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_phdr</span> &#123;<br>    Elf64_Word p_type;<span class="hljs-comment">//当前Segment的类型[4B]</span><br>    Elf64_Word p_flags;<span class="hljs-comment">//段相关的标志[4B]</span><br>    Elf32_Off  p_offset;<span class="hljs-comment">//当前段相对于文件起始位置的偏移量;[4B]</span><br>    Elf64_Addr      p_vaddr;<span class="hljs-comment">//段的第一个字节将被映射到到内存中的虚拟地址[8B]</span><br>    Elf64_Addr      p_paddr;<span class="hljs-comment">//此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的；[8B]</span><br>    Elf64_Xword     p_filesz;<span class="hljs-comment">//段在文件映像中所占的字节数[8B]</span><br>    Elf64_Xword     p_memsz;<span class="hljs-comment">//段在内存映像中占用的字节数</span><br>    Elf64_Xword     p_align;<span class="hljs-comment">//段在文件中和内存中如何对齐</span><br>&#125;Elf64_Phdr;<br></code></pre></td></tr></table></figure><h4 id="解析代码：-1"><a href="#解析代码：-1" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfProgramHeaderTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span></span><br><span class="hljs-function"></span>&#123;<br>    Elf64_Phdr phdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_phoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_phnum;<br>    <span class="hljs-built_in">fread</span>(phdr, <span class="hljs-built_in">sizeof</span>(Elf64_Phdr), count, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d program headers, starting at offset 0x%04x:\n\n&quot;</span>, count, elf64_hdr-&gt;e_phoff);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;程序头表:&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;类型\t\t属性\t偏移量\t\t虚拟地址\t\t物理地址\t\t文件大小\t镜像大小\t对齐长度&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count;i++ )<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (phdr[i].p_type) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_NULL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前项未使用，项中的成员是未定义的，需要忽略当前项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_LOAD\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前Segment是一个可装载的Segment，即可以被装载映射到内存中，其大小由p_filesz和p_memsz描述。如果p_memsz&gt;p_filesz则剩余的字节被置零，但是p_filesz&gt;p_memsz是非法的。动态库一般包含两个该类型的段：代码段和数据段；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_DYNAMIC\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//动态段，动态库特有的段，包含了动态链接必须的一些信息，比如需要链接的共享库列表、GOT等等</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_INTERP\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前段用于存储一段以NULL为结尾的字符串，该字符串表明了程序解释器的位置。且当前段仅仅对于可执行文件有实际意义</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_NOTE\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//用于保存与特定供应商或者系统相关的附加信息以便于兼容性、一致性检查，但是实际上只保存了操作系统的规范信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_SHLIB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保留段；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_PHDR\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存程序头表本身的位置和大小，当前段不能在文件中出现一次以上，且仅仅当程序表头为内存映像的一部分时起作用，它必须在所有加载项目之前；</span><br>            <span class="hljs-comment">/*[PT_LPROC(0x70000000),PT_HIPROC(0x7fffffff)]：该范围内的值用作预留*/</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e550</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_EH_FRAME\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e551</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_STACK\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6474e552</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GNU_RELRO\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_LOPROC\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PT_HIPROC\t&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\t&#x27;</span>);<br>        <span class="hljs-keyword">switch</span> (phdr[i].p_flags) &#123;<span class="hljs-comment">//段相关的标志(权限)；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;none&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;w&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;r&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rw&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;rwx&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%08x&quot;</span>, phdr[i].p_offset);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%016x&quot;</span>, phdr[i].p_vaddr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%016x&quot;</span>, phdr[i].p_paddr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%6u bytes&quot;</span>, phdr[i].p_filesz);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%6u bytes&quot;</span>, phdr[i].p_memsz);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t0x%08x&quot;</span>, phdr[i].p_align);<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/lRgI7oCc9qTdDxh.png" alt="image-20241222095134236"></p><h3 id="节区头表-Section-Header-Table"><a href="#节区头表-Section-Header-Table" class="headerlink" title="节区头表(Section Header Table)"></a>节区头表(Section Header Table)</h3><p><strong>描述 ELF 文件的逻辑组织</strong>：包含每个节（如 <code>.text</code>、<code>.data</code>、<code>.bss</code>、<code>.symtab</code> 等）的信息。确定各个节的位置及内容，如符号表 <code>.symtab</code>、重定位表 <code>.rel</code> 等。提供调试和符号信息。</p><h4 id="数据结构：-2"><a href="#数据结构：-2" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf64_shrd</span> &#123;<br>    Elf64_Word sh_name;<span class="hljs-comment">//节名称在字符串表中的索引</span><br>    Elf64_Word sh_type;<span class="hljs-comment">//节的类型和语义</span><br>    Elf64_Xword sh_flags;<span class="hljs-comment">//1bit位的标志位</span><br><br>    Elf64_Addr sh_addr;<span class="hljs-comment">//如果当前节需要被装载到内存，则当前项存储当前节映射到内存的首地址，否则应该为0；[8B]</span><br>    Elf64_Off  sh_offset;<span class="hljs-comment">//当前节的首地址相对于文件的偏移；[8B]</span><br>    Elf64_Xword sh_size;<span class="hljs-comment">//节的大小[8B]</span><br><br>    Elf64_Word sh_link;<span class="hljs-comment">//[4B]符号表（.symtab 或 .dynsym）</span><br>    <span class="hljs-comment">//用途：sh_link 表示符号表关联的字符串表的节头表索引。</span><br>    <span class="hljs-comment">//原因：符号表中的每个符号名存储在字符串表中，而 sh_link 指向该字符串表的节。</span><br>    Elf64_Word sh_info;<span class="hljs-comment">//节的附加信息。对于特定的节有特定的含义，其他为0；[4B]</span><br>    Elf64_Xword sh_addralign;<span class="hljs-comment">//地址约束对齐，值应该为0或者2的幂次方，0和1表示未进行对齐；[8B]</span><br>    Elf64_Xword sh_entsize;<span class="hljs-comment">//如果该节包含一个表格（例如符号表、重定位表等），sh_entsize 表示表中每个条目的大小（以字节为单位）。</span><br>    <span class="hljs-comment">//如果该节不是一个表格（例如.text 节），sh_entsize 通常设置为 0，因为这些节不分条目，所有数据都连续存放。</span><br><br>&#125;Elf64_Shdr;<br><br></code></pre></td></tr></table></figure><h4 id="解析代码：-2"><a href="#解析代码：-2" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ElfSectionHeaderTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp);<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d section headers, starting at offset 0x%04x:\n\n&quot;</span>, count, elf64_hdr-&gt;e_shoff);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;节头表:&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[编号]\t名称\t\t\  类型\t\t属性\t虚拟地址\t\t偏移量\t\t大小\t\t索引值\t信息\t对齐长度\t表项大小\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)<br>    &#123;<br>        <span class="hljs-comment">//&amp;strtable[shdr[i].sh_name] 表示获取该字符的地址，这实际上是偏移量对应的字符串在数组中的起始地址。</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%02d]\t%s&quot;</span>, i, &amp;strtable[shdr[i].sh_name]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">20</span> - <span class="hljs-built_in">strlen</span>(&amp;strtable[shdr[i].sh_name]); ++j) &#123;<br>            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (shdr[i].sh_type)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NULL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//当前节是非活跃的，没有一个对应的具体的节内存；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_PROGBITS\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//包含了程序的指令信息、数据等程序运行相关的信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_SYMTAB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存了符号信息，用于重定位；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_STRTAB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//一个字符串表，保存了每个节的节名称；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_RELA\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储可重定位表项，可能会有附加内容，目标文件可能有多个可重定位表项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HASH\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储符号哈希表，所有参与动态链接的目标只能包含一个哈希表，一个目标文件只能包含一个哈希表；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_DYAMIC\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储包含动态链接的信息，一个目标文件只能包含一个；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NOTE\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//存储以某种形式标记文件的信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_NOBITS\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//这种类型的节不占据文件空间，但是成员sh_offset依然会包含对应的偏移；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_REL\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//包含可重定位表项，无附加内容，目标文件可能有多个可重定位表项；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_SHLIB\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//：保留区，包含此节的程序与ABI不兼容</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_DYNSYM\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//保存共享库导入动态符号信息；</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t&quot;</span>); <span class="hljs-keyword">break</span>;<span class="hljs-comment">//</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_LOPROC&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HIPROC&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x80000000</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_LOUSER&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xffffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_HIUSER&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6ffffff6</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_HASH&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6fffffff</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_versym&quot;</span>); <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x6ffffffe</span>: <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SHT_GNU_verneed&quot;</span>); <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%016x\t&quot;</span>, shdr[i].sh_addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%08x\t&quot;</span>, shdr[i].sh_offset);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4lu bytes\t&quot;</span>, shdr[i].sh_size);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\t&quot;</span>, shdr[i].sh_link);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%u\t&quot;</span>, shdr[i].sh_info);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2lu bytes\t&quot;</span>, shdr[i].sh_entsize);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%4x\n&quot;</span>, shdr[i].sh_addralign);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/KY7pl9Ln6ruy1fv.png" alt="image-20241222095159256"></p><h4 id="特殊的节"><a href="#特殊的节" class="headerlink" title="特殊的节"></a>特殊的节</h4><p>ELF 文件中有一些特定的节是预定义好的，其内容是指令代码或者控制信息</p><p>这些节专门为操作系统使用，对于不同的操作系统，这些节的类型和属性有所不同</p><table><thead><tr><th align="left">节名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><strong>.text</strong></td><td align="left"><strong>代码段</strong></td></tr><tr><td align="left"><strong>.data</strong></td><td align="left"><strong>保存已经初始化的全局变量和局部静态变量</strong></td></tr><tr><td align="left"><strong>.bss</strong></td><td align="left"><strong>保存未初始化的全局变量和局部静态变量</strong></td></tr><tr><td align="left">.rodata</td><td align="left">存放只读数据, 例如常量字符串</td></tr><tr><td align="left">.comment</td><td align="left">编译器版本信息</td></tr><tr><td align="left">.debug</td><td align="left">调试信息</td></tr><tr><td align="left"><strong>.dynamic</strong></td><td align="left"><strong>动态链接信息</strong>, linker解析该段以加载elf文件</td></tr><tr><td align="left">.hash</td><td align="left">符号哈希表 (可查导入和导出符号)</td></tr><tr><td align="left">.gnu.hash</td><td align="left">GNU哈希表 (只可查导出符号,导出表)</td></tr><tr><td align="left">.line</td><td align="left">调试行号表 即源代码行号与编译后指令的对应表</td></tr><tr><td align="left">.note</td><td align="left">额外的编译器信息 例如公司名,版本号</td></tr><tr><td align="left">.rel.dyn</td><td align="left">动态链接重定位表 存放全局变量重定位项</td></tr><tr><td align="left">.rel.plt</td><td align="left">动态链接函数跳转重定位表 存放plt重定位项</td></tr><tr><td align="left">.symtab</td><td align="left">符号表</td></tr><tr><td align="left">.dynsym</td><td align="left">动态链接符号表</td></tr><tr><td align="left">.strtab</td><td align="left">字符串表</td></tr><tr><td align="left">.shstrtab</td><td align="left">节名表</td></tr><tr><td align="left">.dynstr</td><td align="left">动态链接字符串表</td></tr><tr><td align="left">.plt</td><td align="left">动态链接跳转表</td></tr><tr><td align="left">.got</td><td align="left">动态链接全局偏移表</td></tr><tr><td align="left">.init</td><td align="left">程序初始化代码段(节)</td></tr><tr><td align="left">.fini</td><td align="left">程序结束代码段(节)</td></tr></tbody></table><h3 id="字符串表-String-Table"><a href="#字符串表-String-Table" class="headerlink" title="字符串表(String Table)"></a>字符串表(String Table)</h3><p><strong>存储字符串信息</strong>：供节头表、符号表等引用的字符串。解析 ELF 文件中字符串索引值，获取节名称、符号名称等人类可读的信息。</p><h4 id="数据结构：-3"><a href="#数据结构：-3" class="headerlink" title="数据结构："></a>数据结构：</h4><p>ELF文件中有很多字符串,例如段名,变量名等, 由于字符串长度往往不固定,所以使用固定结构描述比较困难，常见做法是将字符串集中起来存放到一张字符串表,然后通过索引查表来引用字符串</p><p>常见的有:</p><ol><li><p>.strtab(字符串表,保存普通字符串)</p><p>遍历section header, 查找type&#x3D;&#x3D;SHT_STRTAB的即为字符串表 (包括段表字符串表)</p></li><li><p>.shstrtab(段表字符串表,保存段表用到的字符串)</p><p>获取该表可以通过ELF Header的e_shstrndx成员做索引,查找ELF Section Header Table</p><p>即p_shstrtab&#x3D;ELFSectionHeaderTable[ELFHeader.e_shstrndx]</p></li></ol><h4 id="解析代码：-3"><a href="#解析代码：-3" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">StringTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is stringtable \n&quot;</span>);<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-type">uint8_t</span> stringBuffer[<span class="hljs-number">9999</span>]; <span class="hljs-comment">// 用于保存单个字符串表</span><br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp);<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t==========String Table %s==========\n&quot;</span>, &amp;strtable[shdr[i].sh_name]);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[i].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(stringBuffer, <span class="hljs-number">1</span>, shdr[i].sh_size, fp);<br>            <span class="hljs-type">uint32_t</span> pos = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (pos &lt; shdr[i].sh_size) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, stringBuffer + pos);<br>                pos += <span class="hljs-built_in">strlen</span>((<span class="hljs-type">char</span>*)(stringBuffer + pos)) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 跳过当前字符串（加上末尾 &#x27;\0&#x27;）</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ELF String Table End\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-3"><a href="#结果：-3" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/kz4UueFKX9SCaD3.png" alt="image-20241222095217758"></p><h3 id="符号表信息-Symbol-Table"><a href="#符号表信息-Symbol-Table" class="headerlink" title="符号表信息(Symbol Table)"></a>符号表信息(Symbol Table)</h3><p><strong>存储符号信息</strong>：符号表保存了 ELF 文件中的全局和局部符号（如函数名、变量名）。为调试、链接提供符号信息。动态链接时，解析符号依赖（如函数地址的重定位）。符号表的作用是描述导入和导出符号,这里的符号可以是全局变量,函数,外部引用等，通过符号表和对应的字符串表可以得到符号名,符号大小,符号地址等信息</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">.dynsym //动态链接符号表<br>.symtab //符号表<br><br>.dynstr //动态链接符号表的字符串表<br>.strtab //符号表的字符串表<br></code></pre></td></tr></table></figure><h4 id="数据结构：-4"><a href="#数据结构：-4" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Word st_name; <span class="hljs-comment">/* Symbol name */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info; <span class="hljs-comment">/* Type and Binding attributes */</span><span class="hljs-comment">//符号的类型和属性, 高4bit标识了符号绑定(symbol binding), 低4bit标识了符号类型(symbol type), 组成符号信息(symbol information)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other; <span class="hljs-comment">/* Reserved */</span><br>    Elf64_Half st_shndx; <span class="hljs-comment">/* Section table index用于表示符号所在的段（Section）索引 */</span><br>    Elf64_Addr st_value; <span class="hljs-comment">/* Symbol value */</span><br>    Elf64_Xword st_size; <span class="hljs-comment">/* Size of object (e.g., common) */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><p>注意：st_info</p><p>符号的类型和属性,高4bit标识了符号绑定(symbol binding), 低4bit标识了符号类型(symbol type),组成符号信息(symbol information)</p><p>有3个宏分别读取这三个属性值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_BIND(val)      (((unsigned char) (val)) &gt;&gt; 4)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_TYPE(val)      ((val) &amp; 0xf)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF32_ST_INFO(bind, type)   (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</span><br></code></pre></td></tr></table></figure><p>具体类型值:</p><p><img src="https://s2.loli.net/2024/12/22/2K6AaGHtlMyXIRo.png" alt="image-20241222093256869"></p><p><img src="https://s2.loli.net/2024/12/22/Hkc5sdLWTNfeb3E.png" alt="image-20241222093313451"></p><h4 id="解析代码：-4"><a href="#解析代码：-4" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolBindingString</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> symbolBinding)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (symbolBinding) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOCAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GLOBAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WEAK&quot;</span>;<br>    <span class="hljs-comment">/*case STB_NUM:          return &quot;STB_NUM&quot;;</span><br><span class="hljs-comment">    case STB_GNU_UNIQUE:   return &quot;GNU_UNIQUE&quot;;*/</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_HIOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_LOPROC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STB_HIPROC&quot;</span>;<br>    <span class="hljs-keyword">default</span>:               <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolTypeString</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> symbolType)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (symbolType) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NOTYPE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OBJECT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FUNC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SECTION&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FILE&quot;</span>;<br>    <span class="hljs-comment">//case STT_COMMON:    return &quot;COMMON&quot;;</span><br>    <span class="hljs-comment">//case STT_TLS:       return &quot;TLS&quot;;</span><br>    <span class="hljs-comment">//case STT_NUM:       return &quot;STT_NUM&quot;;</span><br>    <span class="hljs-comment">//case STT_GNU_IFUNC: return &quot;GNU_IFUNC&quot;;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIOS&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;LOPROC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>:    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIPROC&quot;</span>;<br>    <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getSymbolVisibility</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> st_other)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> visibility = st_other &amp; <span class="hljs-number">0x03</span>;<br>    <span class="hljs-keyword">switch</span> (visibility) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEFAULT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INTERNAL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HIDDEN&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PROTECTED&quot;</span>;<br>    <span class="hljs-keyword">default</span>:           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOWN&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SymbolTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>    <span class="hljs-type">char</span> str_table[<span class="hljs-number">9999</span>];<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-type">int</span> count = elf64_hdr-&gt;e_shnum;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), count, fp) != count) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Failed to read section headers&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fread</span>(str_table, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp) != shdr[elf64_hdr-&gt;e_shstrndx].sh_size) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Failed to read string table&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">2</span> || shdr[i].sh_type == <span class="hljs-number">11</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t==========symbol Table %s==========\n&quot;</span>, &amp;strtable[shdr[i].sh_name]);<br>            <span class="hljs-keyword">if</span> (shdr[i].sh_entsize == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            Elf64_Xword symbolnum = shdr[i].sh_size / shdr[i].sh_entsize;<br><br>            <span class="hljs-comment">// 加载符号表段</span><br>            Elf64_Sym* pSymbolTable = (Elf64_Sym*)<span class="hljs-built_in">malloc</span>(shdr[i].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[i].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTable, <span class="hljs-number">1</span>, shdr[i].sh_size, fp);<br><br>            <span class="hljs-comment">// 加载关联的字符串表</span><br>            <span class="hljs-type">char</span>* str_table = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(shdr[shdr[i].sh_link].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[shdr[i].sh_link].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(str_table, <span class="hljs-number">1</span>, shdr[shdr[i].sh_link].sh_size, fp);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tNum \tValue\t\tSize\t\tIndex\t\tName\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; symbolnum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%04d&quot;</span>, j);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pSymbolTable[j].st_value);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pSymbolTable[j].st_size);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%04x&quot;</span>, pSymbolTable[j].st_shndx);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, str_table + pSymbolTable[j].st_name);<br>            &#125;<br><br>            <span class="hljs-built_in">free</span>(pSymbolTable);<br>            <span class="hljs-built_in">free</span>(str_table);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-4"><a href="#结果：-4" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/ILUkq2hCuRD5aAt.png" alt="image-20241222095255525"></p><h3 id="重定位表信息-Relocation-Table"><a href="#重定位表信息-Relocation-Table" class="headerlink" title="重定位表信息(Relocation Table)"></a>重定位表信息(Relocation Table)</h3><p><strong>处理动态链接和地址调整</strong>：用于修改可执行代码和数据的地址（例如修正指针或调用目标地址）。修正动态库或共享库的符号引用地址。实现位置无关代码（PIC）。</p><p>一般有两张重定位表:</p><ol><li><strong>.rel.plt</strong> 修复外部函数地址</li><li><strong>.rel.dyn</strong> 修复全局变量地址</li></ol><p>重定位表有SHT_REL, SHT_RELA, SHT_RELR三种类型。</p><h4 id="数据结构：-5"><a href="#数据结构：-5" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Addr r_offset; <span class="hljs-comment">/* 引用地址（需要重定位的位置） */</span><br>    Elf64_Xword r_info;  <span class="hljs-comment">/* 符号索引和重定位类型（编码信息） */</span><br>&#125;Elf64_Rel;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Addr r_offset;     <span class="hljs-comment">/* 引用地址（需要重定位的位置） */</span><br>    Elf64_Xword r_info;      <span class="hljs-comment">/* 符号索引和重定位类型（编码信息） */</span><br>    Elf64_Sxword r_addend;   <span class="hljs-comment">/* 表达式中的常量部分 */</span><br>&#125;Elf64_Rela;<br></code></pre></td></tr></table></figure><h4 id="解析代码：-5"><a href="#解析代码：-5" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getRelocationTypeString64</span><span class="hljs-params">(Elf64_Word value)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_NONE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOT32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PLT32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_COPY&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GLOB_DAT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_JMP_SLOT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_RELATIVE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOTOFF&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOTPC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_32PLT&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_TPOFF&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_IE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GOTIE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_16&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC16&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_8&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_PC8&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_PUSH&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GD_POP&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_PUSH&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDM_POP&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LDO_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_IE_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_LE_32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DTPMOD32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DTPOFF32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_TPOFF32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_SIZE32&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_GOTDESC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DESC_CALL&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_TLS_DESC&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_IRELATIVE&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">43</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;R_386_GOT32X&quot;</span>;<br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown relocation type&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">RelocationTableParse</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sectionNum = elf64_hdr-&gt;e_shnum;<br>    Elf64_Shdr shdr[<span class="hljs-number">99</span>];<br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(shdr, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), sectionNum, fp);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Relocation Tables:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sectionNum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (shdr[i].sh_type == <span class="hljs-number">4</span>) &#123; <span class="hljs-comment">// 检查是否为重定位表</span><br>            Elf64_Shdr* pRelocationTableHeader = &amp;shdr[i];<br>            Elf64_Rel* pRelocationTable = (Elf64_Rel*)<span class="hljs-built_in">malloc</span>(pRelocationTableHeader-&gt;sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, pRelocationTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pRelocationTable, pRelocationTableHeader-&gt;sh_size, <span class="hljs-number">1</span>, fp);<br><br>            Elf64_Word relocItemNum = pRelocationTableHeader-&gt;sh_size / pRelocationTableHeader-&gt;sh_entsize;<br><br>            <span class="hljs-comment">// 符号表头部</span><br>            Elf64_Shdr* pSymbolTableHeader = &amp;shdr[pRelocationTableHeader-&gt;sh_link];<br>            Elf64_Sym* pSymbolTable = (Elf64_Sym*)<span class="hljs-built_in">malloc</span>(pSymbolTableHeader-&gt;sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, pSymbolTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTable, pSymbolTableHeader-&gt;sh_size, <span class="hljs-number">1</span>, fp);<br><br>            <span class="hljs-comment">// 符号表的字符串表</span><br>            <span class="hljs-type">char</span>* pSymbolTableStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(shdr[pSymbolTableHeader-&gt;sh_link].sh_size);<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[pSymbolTableHeader-&gt;sh_link].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pSymbolTableStringTable, shdr[pSymbolTableHeader-&gt;sh_link].sh_size, <span class="hljs-number">1</span>, fp);<br><br>            <span class="hljs-comment">// 段名字符串表</span><br>            <span class="hljs-type">char</span> strtable[<span class="hljs-number">9999</span>];<br>            <span class="hljs-built_in">fseek</span>(fp, shdr[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(strtable, <span class="hljs-number">1</span>, shdr[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Relocation Section &#x27;%s&#x27; at offset contains %d entries\n&quot;</span>, (<span class="hljs-type">char</span>*)strtable + shdr[i].sh_name, relocItemNum);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tOffset\t\tInfo\t\tType\t\t\t\tSym.value\t\tSym.name\n&quot;</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; relocItemNum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pRelocationTable[j].r_offset);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pRelocationTable[j].r_info);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\t&quot;</span>, <span class="hljs-built_in">getRelocationTypeString32</span>(<span class="hljs-built_in">ELF64_R_TYPE</span>(pRelocationTable[j].r_info)));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx\t&quot;</span>, pSymbolTable[<span class="hljs-built_in">ELF64_R_SYM</span>(pRelocationTable[j].r_info)].st_value);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%s\n&quot;</span>, &amp;pSymbolTableStringTable[pSymbolTable[<span class="hljs-built_in">ELF64_R_SYM</span>(pRelocationTable[j].r_info)].st_name]);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放动态内存</span><br>            <span class="hljs-built_in">free</span>(pRelocationTable);<br>            <span class="hljs-built_in">free</span>(pSymbolTable);<br>            <span class="hljs-built_in">free</span>(pSymbolTableStringTable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-5"><a href="#结果：-5" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/bv1kTzN6wXH2UeF.png" alt="image-20241222095355945"></p><h3 id="动态段-Dynamic-Segment"><a href="#动态段-Dynamic-Segment" class="headerlink" title="动态段(Dynamic Segment)"></a><strong>动态段(Dynamic Segment)</strong></h3><p>如果目标文件参与动态链接,必定包含一个类型为 PT_DYNAMIC 的Program表项, 对应节名为 .dynamic (type&#x3D;SHT_DYNAMIC)</p><p>动态段的作用是提供动态链接器所需要的信息,比如依赖哪些共享库文件,动态链接符号表的位置,动态链接重定位表的位置等</p><h4 id="数据结构：-6"><a href="#数据结构：-6" class="headerlink" title="数据结构："></a>数据结构：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//提供动态链接器所需要的信息,</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    Elf64_Sxword d_tag;<br>    <span class="hljs-keyword">union</span> &#123;<br>        Elf64_Xword d_val;<br>        Elf64_Addr d_ptr;<br>    &#125; d_un;<br>&#125; Elf64_Dyn;<br><span class="hljs-keyword">extern</span> Elf64_Dyn _DYNAMIC[];<br></code></pre></td></tr></table></figure><h4 id="解析代码：-6"><a href="#解析代码：-6" class="headerlink" title="解析代码："></a>解析代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_VAL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DT_PTR 1</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getDynamicType</span><span class="hljs-params">(Elf64_Xword value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0x60000000</span> &amp;&amp; value &lt;= <span class="hljs-number">0x6fffffff</span>) <span class="hljs-comment">// DT_LOOS 和 DT_HIOS 的范围</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OS-Specific&quot;</span>;<br>    <span class="hljs-keyword">if</span> (value &gt;= <span class="hljs-number">0x70000000</span> &amp;&amp; value &lt;= <span class="hljs-number">0x7fffffff</span>) <span class="hljs-comment">// DT_LOPROC 和 DT_HIPROC 的范围</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Processor-Specific&quot;</span>;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>;  <span class="hljs-comment">// DT_NULL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NEEDED&quot;</span>;  <span class="hljs-comment">// DT_NEEDED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTRELSZ&quot;</span>;  <span class="hljs-comment">// DT_PLTRELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTGOT&quot;</span>;  <span class="hljs-comment">// DT_PLTGOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HASH&quot;</span>;  <span class="hljs-comment">// DT_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STRTAB&quot;</span>;  <span class="hljs-comment">// DT_STRTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMTAB&quot;</span>;  <span class="hljs-comment">// DT_SYMTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELA&quot;</span>;  <span class="hljs-comment">// DT_RELA</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELASZ&quot;</span>;  <span class="hljs-comment">// DT_RELASZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELAENT&quot;</span>;  <span class="hljs-comment">// DT_RELAENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;STRSZ&quot;</span>;  <span class="hljs-comment">// DT_STRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMENT&quot;</span>;  <span class="hljs-comment">// DT_SYMENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT&quot;</span>;  <span class="hljs-comment">// DT_INIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI&quot;</span>;  <span class="hljs-comment">// DT_FINI</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SONAME&quot;</span>;  <span class="hljs-comment">// DT_SONAME</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RPATH&quot;</span>;  <span class="hljs-comment">// DT_RPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMBOLIC&quot;</span>;  <span class="hljs-comment">// DT_SYMBOLIC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;REL&quot;</span>;  <span class="hljs-comment">// DT_REL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELSZ&quot;</span>;  <span class="hljs-comment">// DT_RELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELENT&quot;</span>;  <span class="hljs-comment">// DT_RELENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTREL&quot;</span>;  <span class="hljs-comment">// DT_PLTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG&quot;</span>;  <span class="hljs-comment">// DT_DEBUG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TEXTREL&quot;</span>;  <span class="hljs-comment">// DT_TEXTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;JMPREL&quot;</span>;  <span class="hljs-comment">// DT_JMPREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;BIND_NOW&quot;</span>;  <span class="hljs-comment">// DT_BIND_NOW</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT_ARRAY&quot;</span>;  <span class="hljs-comment">// DT_INIT_ARRAY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">26</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI_ARRAY&quot;</span>;  <span class="hljs-comment">// DT_FINI_ARRAY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INIT_ARRAYSZ&quot;</span>;  <span class="hljs-comment">// DT_INIT_ARRAYSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FINI_ARRAYSZ&quot;</span>;  <span class="hljs-comment">// DT_FINI_ARRAYSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RUNPATH&quot;</span>;  <span class="hljs-comment">// DT_RUNPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">30</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FLAGS&quot;</span>;  <span class="hljs-comment">// DT_FLAGS</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ENCODING&quot;</span>;  <span class="hljs-comment">// DT_ENCODING</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">32</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMTAB_SHNDX&quot;</span>;  <span class="hljs-comment">// DT_SYMTAB_SHNDX</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELRSZ&quot;</span>;  <span class="hljs-comment">// DT_RELRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELR&quot;</span>;  <span class="hljs-comment">// DT_RELR</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">35</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELRENT&quot;</span>;  <span class="hljs-comment">// DT_RELRENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">36</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NUM&quot;</span>;  <span class="hljs-comment">// DT_NUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">37</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VALRNGLO&quot;</span>;  <span class="hljs-comment">// DT_VALRNGLO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_PRELINKED&quot;</span>;  <span class="hljs-comment">// DT_GNU_PRELINKED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_CONFLICTSZ&quot;</span>;  <span class="hljs-comment">// DT_GNU_CONFLICTSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">40</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_LIBLISTSZ&quot;</span>;  <span class="hljs-comment">// DT_GNU_LIBLISTSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">41</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CHECKSUM&quot;</span>;  <span class="hljs-comment">// DT_CHECKSUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">42</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTPADSZ&quot;</span>;  <span class="hljs-comment">// DT_PLTPADSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">43</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVEENT&quot;</span>;  <span class="hljs-comment">// DT_MOVEENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">44</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVESZ&quot;</span>;  <span class="hljs-comment">// DT_MOVESZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">45</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FEATURE_1&quot;</span>;  <span class="hljs-comment">// DT_FEATURE_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">46</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;POSFLAG_1&quot;</span>;  <span class="hljs-comment">// DT_POSFLAG_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">47</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINSZ&quot;</span>;  <span class="hljs-comment">// DT_SYMINSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">48</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINENT&quot;</span>;  <span class="hljs-comment">// DT_SYMINENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">49</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ADDRRNGLO&quot;</span>;  <span class="hljs-comment">// DT_ADDRRNGLO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">50</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_HASH&quot;</span>;  <span class="hljs-comment">// DT_GNU_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">51</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TLSDESC_PLT&quot;</span>;  <span class="hljs-comment">// DT_TLSDESC_PLT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">52</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TLSDESC_GOT&quot;</span>;  <span class="hljs-comment">// DT_TLSDESC_GOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">53</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_CONFLICT&quot;</span>;  <span class="hljs-comment">// DT_GNU_CONFLICT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">54</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;GNU_LIBLIST&quot;</span>;  <span class="hljs-comment">// DT_GNU_LIBLIST</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">55</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CONFIG&quot;</span>;  <span class="hljs-comment">// DT_CONFIG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">56</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEPAUDIT&quot;</span>;  <span class="hljs-comment">// DT_DEPAUDIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">57</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AUDIT&quot;</span>;  <span class="hljs-comment">// DT_AUDIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">58</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PLTPAD&quot;</span>;  <span class="hljs-comment">// DT_PLTPAD</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">59</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MOVETAB&quot;</span>;  <span class="hljs-comment">// DT_MOVETAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;SYMINFO&quot;</span>;  <span class="hljs-comment">// DT_SYMINFO</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">61</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERSYM&quot;</span>;  <span class="hljs-comment">// DT_VERSYM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELACOUNT&quot;</span>;  <span class="hljs-comment">// DT_RELACOUNT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">63</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RELCOUNT&quot;</span>;  <span class="hljs-comment">// DT_RELCOUNT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">64</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FLAGS_1&quot;</span>;  <span class="hljs-comment">// DT_FLAGS_1</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERDEF&quot;</span>;  <span class="hljs-comment">// DT_VERDEF</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">66</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERDEFNUM&quot;</span>;  <span class="hljs-comment">// DT_VERDEFNUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">67</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERNEED&quot;</span>;  <span class="hljs-comment">// DT_VERNEED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">68</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;VERNEEDNUM&quot;</span>;  <span class="hljs-comment">// DT_VERNEEDNUM</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">69</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AUXILIARY&quot;</span>;  <span class="hljs-comment">// DT_AUXILIARY</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">70</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FILTER&quot;</span>;  <span class="hljs-comment">// DT_FILTER</span><br>    <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Unknown Type&quot;</span>;  <span class="hljs-comment">// Unknown DT type</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint32_t</span> <span class="hljs-title">getDynamicDunType</span><span class="hljs-params">(Elf64_Xword value)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (value) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// DT_NULL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// DT_NEEDED</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// DT_PLTRELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: <span class="hljs-comment">// DT_RELASZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: <span class="hljs-comment">// DT_RELAENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>: <span class="hljs-comment">// DT_STRSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>: <span class="hljs-comment">// DT_SYMENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-comment">// DT_SONAME</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">15</span>: <span class="hljs-comment">// DT_RPATH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">16</span>: <span class="hljs-comment">// DT_SYMBOLIC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">18</span>: <span class="hljs-comment">// DT_RELSZ</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">19</span>: <span class="hljs-comment">// DT_RELENT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">20</span>: <span class="hljs-comment">// DT_PLTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">21</span>: <span class="hljs-comment">// DT_TEXTREL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">24</span>: <span class="hljs-comment">// DT_BIND_NOW</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x70000000</span>: <span class="hljs-comment">// DT_LOPROC</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x7fffffff</span>: <span class="hljs-comment">// DT_HIPROC</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// DT_VAL</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">// DT_PLTGOT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">// DT_HASH</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: <span class="hljs-comment">// DT_STRTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: <span class="hljs-comment">// DT_SYMTAB</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: <span class="hljs-comment">// DT_RELA</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>: <span class="hljs-comment">// DT_INIT</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>: <span class="hljs-comment">// DT_FINI</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">23</span>: <span class="hljs-comment">// DT_JMPREL</span><br>    <span class="hljs-comment">//case 21: // DT_DEBUG</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">17</span>: <span class="hljs-comment">// DT_REL</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// DT_PTR</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// DT_VAL</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printDynamicSegment64</span><span class="hljs-params">(FILE* fp, Elf64_hdr* elf64_hdr)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取 ELF 文件中的节头表信息</span><br>    Elf64_Shdr* pSectionHeader = (Elf64_Shdr*)<span class="hljs-built_in">malloc</span>(elf64_hdr-&gt;e_shnum * <span class="hljs-built_in">sizeof</span>(Elf64_Shdr));<br>    <span class="hljs-keyword">if</span> (!pSectionHeader) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for section header failed&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, elf64_hdr-&gt;e_shoff, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(pSectionHeader, <span class="hljs-built_in">sizeof</span>(Elf64_Shdr), elf64_hdr-&gt;e_shnum, fp);<br><br>    <span class="hljs-comment">// 获取节头字符串表</span><br>    <span class="hljs-type">char</span>* pSectionHeaderStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_size);<br>    <span class="hljs-keyword">if</span> (!pSectionHeaderStringTable) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for section header string table failed&quot;</span>);<br>        <span class="hljs-built_in">free</span>(pSectionHeader);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">fseek</span>(fp, pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_offset, SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(pSectionHeaderStringTable, <span class="hljs-number">1</span>, pSectionHeader[elf64_hdr-&gt;e_shstrndx].sh_size, fp);<br><br>    <span class="hljs-comment">// 处理动态节</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elf64_hdr-&gt;e_shnum; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pSectionHeader[i].sh_type == <span class="hljs-number">6</span>) &#123;  <span class="hljs-comment">// SHT_DYNAMIC == 6</span><br>            Elf64_Shdr* pDynamicSection = &amp;pSectionHeader[i];<br>            Elf64_Word dynamicItemNum = pDynamicSection-&gt;sh_size / pDynamicSection-&gt;sh_entsize;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dynamic Section At File Offset %#lx Contains %d Entries:\n&quot;</span>, pDynamicSection-&gt;sh_offset, dynamicItemNum);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\tTag \t\tType\t\t\t\tName/Value\n&quot;</span>);<br><br>            <span class="hljs-comment">// 动态段表项</span><br>            Elf64_Dyn* pDynamicTable = (Elf64_Dyn*)<span class="hljs-built_in">malloc</span>(pDynamicSection-&gt;sh_size);<br>            <span class="hljs-keyword">if</span> (!pDynamicTable) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for dynamic table failed&quot;</span>);<br>                <span class="hljs-built_in">free</span>(pSectionHeader);<br>                <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 获取动态字符串表</span><br>            Elf64_Shdr* pDynamicStringTableHeader = &amp;pSectionHeader[pDynamicSection-&gt;sh_link];<br>            <span class="hljs-type">char</span>* pDynamicStringTable = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(pDynamicStringTableHeader-&gt;sh_size);<br>            <span class="hljs-keyword">if</span> (!pDynamicStringTable) &#123;<br>                <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;Memory allocation for dynamic string table failed&quot;</span>);<br>                <span class="hljs-built_in">free</span>(pSectionHeader);<br>                <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>                <span class="hljs-built_in">free</span>(pDynamicTable);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 读取动态表项和字符串表数据</span><br>            <span class="hljs-built_in">fseek</span>(fp, pDynamicSection-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pDynamicTable, <span class="hljs-built_in">sizeof</span>(Elf64_Dyn), dynamicItemNum, fp);<br><br>            <span class="hljs-built_in">fseek</span>(fp, pDynamicStringTableHeader-&gt;sh_offset, SEEK_SET);<br>            <span class="hljs-built_in">fread</span>(pDynamicStringTable, <span class="hljs-number">1</span>, pDynamicStringTableHeader-&gt;sh_size, fp);<br><br>            <span class="hljs-comment">// 打印动态表项</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; dynamicItemNum; j++) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx&quot;</span>, pDynamicTable[j].d_tag);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%-16s&quot;</span>, <span class="hljs-built_in">getDynamicType</span>(pDynamicTable[j].d_tag));<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t%08lx\t&quot;</span>, pDynamicTable[j].d_un.d_val);<br><br>                <span class="hljs-comment">// 判断指针类型并输出特殊处理</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getDynamicDunType</span>(pDynamicTable[j].d_tag) == DT_PTR) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(PTR)&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-comment">// 如果是共享库路径或者 soname，则输出字符串</span><br>                <span class="hljs-keyword">switch</span> (pDynamicTable[j].d_tag) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// DT_NEEDED</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">14</span>: <span class="hljs-comment">// DT_SONAME</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[%s]&quot;</span>, pDynamicStringTable + pDynamicTable[j].d_un.d_val);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 释放动态表和字符串表内存</span><br>            <span class="hljs-built_in">free</span>(pDynamicTable);<br>            <span class="hljs-built_in">free</span>(pDynamicStringTable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放节头表和节头字符串表内存</span><br>    <span class="hljs-built_in">free</span>(pSectionHeader);<br>    <span class="hljs-built_in">free</span>(pSectionHeaderStringTable);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果：-6"><a href="#结果：-6" class="headerlink" title="结果："></a>结果：</h4><p><img src="https://s2.loli.net/2024/12/22/hXzbduwpFji7Vrs.png" alt="image-20241222095317517"></p><p>完整代码放在github上：<a href="https://github.com/wangxiaobai08/ELFReader.git">https://github.com/wangxiaobai08/ELFReader.git</a></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.cnblogs.com/SpiritiualWander/p/17903141.html">《程序员的自我修养——链接、装载与库》（作者：俞子甲）读书笔记 - 逝玄 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">ELF文件格式简介_elf文件格式详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_45896211/article/details/138139225">可执行文件格式：ELF_elf文件-CSDN博客</a></p><p><a href="https://www.52pojie.cn/thread-1985443-1-1.html#51841344_symbol-table">ELF文件结构浅析-解析器和加载器实现 - 吾爱破解 - 52pojie.cn</a></p>]]></content>
    
    
    <categories>
      
      <category>Reverse(android)</category>
      
      <category>文件格式/装载链接运行</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Reverse(android)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webbench压测源码分析</title>
    <link href="/2023/03/26/%E5%8E%8B%E6%B5%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/26/%E5%8E%8B%E6%B5%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="webbench压测源码分析"><a href="#webbench压测源码分析" class="headerlink" title="webbench压测源码分析"></a>webbench压测源码分析</h1><p>Webbench是知名的网站压力测试工具，它是由Lionbridge公司开发。Web Bench 是用于对 WWW 或代理服务器进行基准测试的非常简单的工具。使用 fork() 模拟多个客户端，可以使用 HTTP&#x2F;0.9-HTTP&#x2F;1.1 请求。这个基准测试不是很现实，但它可以测试您的 HTTPD 是否真的可以一次处理那么多客户端（尝试运行一些 CGI）而无需关闭您的机器。</p><hr><p>Webbench源码代码量虽小(500行左右)，但麻雀虽小五脏俱全。这其中包含了LInux下的网络Socket编程，HTTP报文，进程通信的信号与管道等系统编程知识，对于正在学习Linux环境下服务器编程的学习者来说可以是很好的入门源码分析对象。本文只起到抛砖引玉的作用。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Linux网络编程基本流程"><a href="#Linux网络编程基本流程" class="headerlink" title="Linux网络编程基本流程"></a>Linux网络编程基本流程</h3><p><img src="https://s2.loli.net/2024/05/28/zOQbgrUGXWMuVt4.png" alt="20190618104623551"></p><h3 id="套接字地址结构体"><a href="#套接字地址结构体" class="headerlink" title="套接字地址结构体"></a>套接字地址结构体</h3><p><img src="https://s2.loli.net/2024/05/28/Cblm86NPkXQBWph.png" alt="20210603143753607"></p><p>在Linux下进行套接字（Socket）编程时，主要涉及以下几个结构体：</p><ol><li><p><strong>struct sockaddr</strong>：</p><ul><li>用于表示通用的套接字地址结构体。</li><li>包含地址族（address family）和地址数据等信息。</li></ul></li><li><p><strong>struct sockaddr_in</strong>：</p><ul><li>用于表示 IPv4 的套接字地址结构体。</li><li>是在 <code>netinet/in.h</code> 头文件中定义的，常用于 IPv4 套接字编程。</li><li>包含了 IPv4 的地址和端口等信息。</li></ul></li><li><p><strong>struct sockaddr_in6</strong>：</p><ul><li>用于表示 IPv6 的套接字地址结构体。</li><li>是在 <code>netinet/in.h</code> 头文件中定义的，用于 IPv6 套接字编程。</li><li>包含了 IPv6 的地址和端口等信息。</li></ul></li><li><p><code>sockaddr_un</code> 是用于 Unix 域套接字（Unix Domain Socket）的结构体，用于表示 Unix 域套接字的地址信息。在 Linux 系统中，Unix 域套接字是一种特殊的套接字类型，用于在同一台主机上的进程间通信，而不需要经过网络协议栈。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sun_family;    <span class="hljs-comment">// 地址族，通常设置为 AF_UNIX</span><br>    <span class="hljs-type">char</span>        sun_path[UNIX_PATH_MAX];   <span class="hljs-comment">// 套接字路径名，UNIX_PATH_MAX 是路径名的最大长度限制</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>sa_family_t</code> 是用于表示套接字地址族（Address Family）的数据类型，通常是一个无符号整数类型。在套接字编程中，地址族用于指定套接字的类型或协议族。常见的地址族包括：</p><ul><li><code>AF_INET</code>：IPv4 地址族，用于 Internet 套接字。</li><li><code>AF_INET6</code>：IPv6 地址族，用于 Internet 套接字。</li><li><code>AF_UNIX</code>：Unix 域地址族，用于本地进程间通信的 Unix 域套接字。</li><li><code>AF_PACKET</code>：用于原始套接字的地址族，可用于发送和接收数据帧。Socket函数</li></ul></li></ol><hr><h2 id="Socket函数"><a href="#Socket函数" class="headerlink" title="Socket函数"></a>Socket函数</h2><p>该函数的作用是根据指定的主机名和端口号创建一个 TCP 套接字，并尝试连接到指定的主机和端口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Socket</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">int</span> clientPort)</span><br>&#123;<br>    <span class="hljs-type">int</span> sock;                         <span class="hljs-comment">// 定义套接字描述符</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> inaddr;             <span class="hljs-comment">// 存储主机地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ad</span>;</span>            <span class="hljs-comment">// 定义套接字地址结构体</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span> *<span class="hljs-title">hp</span>;</span>               <span class="hljs-comment">// 存储主机信息</span><br><br>    <span class="hljs-built_in">memset</span>(&amp;ad, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(ad));       <span class="hljs-comment">// 初始化套接字地址结构体为零</span><br>    ad.sin_family = AF_INET;          <span class="hljs-comment">// 设置地址族为 IPv4</span><br><br>    inaddr = inet_addr(host);         <span class="hljs-comment">// 将主机名转换为网络字节序的 IP 地址</span><br>    <span class="hljs-keyword">if</span> (inaddr != INADDR_NONE)<br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, &amp;inaddr, <span class="hljs-keyword">sizeof</span>(inaddr));  <span class="hljs-comment">// 如果转换成功，则将地址复制到地址结构体中</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        hp = gethostbyname(host);     <span class="hljs-comment">// 如果转换失败，则获取主机信息</span><br>        <span class="hljs-keyword">if</span> (hp == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                 <span class="hljs-comment">// 如果获取失败，则返回错误码 -1</span><br>        <span class="hljs-built_in">memcpy</span>(&amp;ad.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);  <span class="hljs-comment">// 将获取到的地址复制到地址结构体中</span><br>    &#125;<br>    ad.sin_port = htons(clientPort);  <span class="hljs-comment">// 将客户端端口号转换为网络字节序，并存储在地址结构体中</span><br><br>    sock = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 创建一个 TCP 套接字</span><br>    <span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> sock;                   <span class="hljs-comment">// 如果创建失败，则返回错误码</span><br><br>    <span class="hljs-keyword">if</span> (connect(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ad, <span class="hljs-keyword">sizeof</span>(ad)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                     <span class="hljs-comment">// 尝试连接到指定主机和端口，如果失败则返回错误码 -1</span><br><br>    <span class="hljs-keyword">return</span> sock;                       <span class="hljs-comment">// 如果连接成功，则返回套接字描述符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><blockquote><p>在这里使用memcpy而不是&#x3D;的目的是将 <code>inaddr</code> 中的内容复制到 <code>ad.sin_addr</code> 中。尽管 <code>inaddr</code> 和 <code>ad.sin_addr</code> 都是 <code>unsigned long</code> 类型的变量，但它们可能在内存中的存储方式或大小端字节序上有所不同。</p><p><code>memcpy</code> 函数可以确保在不同类型之间进行字节级别的拷贝，而不受内存布局或字节序的影响。这样可以确保在复制数据时保持数据的准确性和完整性。</p><p>另外，<code>inaddr</code> 可能是在 <code>host</code> 为点分十进制 IP 地址时使用 <code>inet_addr</code> 函数转换的，而 <code>ad.sin_addr</code> 是 <code>struct sockaddr_in</code> 结构体中的字段，直接赋值可能会导致类型不匹配或数据不一致的问题，因此使用 <code>memcpy</code> 更为安全和可靠。</p></blockquote><hr><h2 id="webbench主函数"><a href="#webbench主函数" class="headerlink" title="webbench主函数"></a>webbench主函数</h2><h3 id="HTTP基础知识"><a href="#HTTP基础知识" class="headerlink" title="HTTP基础知识"></a>HTTP基础知识</h3><h4 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h4><p><img src="https://s2.loli.net/2024/05/28/J5hwdAEK4zVCUBf.webp" alt="4"></p><h5 id="HTTP-GET和POST方法之间的区别"><a href="#HTTP-GET和POST方法之间的区别" class="headerlink" title="HTTP GET和POST方法之间的区别"></a>HTTP GET和POST方法之间的区别</h5><ol><li><strong>GET 方法</strong>：<ul><li>用于请求从服务器获取数据。</li><li>参数在 URL 中传递，通过查询字符串（Query String）的形式附加在 URL 后面。</li><li>GET 请求可以被缓存，可以被书签收藏，并且可以被历史记录保存。</li><li>GET 请求的长度有限制，因为参数会附加在 URL 上，因此可能受到 URL 长度限制的影响。</li><li>不安全敏感的数据（如密码）不应该通过 GET 请求发送，因为它们会显示在 URL 中，可能被截获或泄露。</li></ul></li><li><strong>POST 方法</strong>：<ul><li>用于向服务器提交数据，通常用于提交表单数据。</li><li>参数在请求体中传递，而不是在 URL 中。因此，POST 请求可以发送大量数据，并且不受 URL 长度限制。</li><li>POST 请求不会被缓存，不会被保存在历史记录中。</li><li>POST 请求在用户交互后可能会显示一个警告对话框，提示用户是否要重新发送数据。</li><li>POST 请求更安全，适合发送敏感信息，因为参数不会显示在 URL 中。</li></ul></li></ol><p><em><strong>总的来说，GET 方法用于获取数据，通常是读取操作；而 POST 方法用于提交数据，通常是写入操作。</strong></em></p><h5 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h5><p><img src="https://s2.loli.net/2024/05/28/Y61zuPms7MSEG2H.png" alt="d3bd60168c43458a85dec80c2253f187"></p><h4 id="HTTP响应报文结构"><a href="#HTTP响应报文结构" class="headerlink" title="HTTP响应报文结构"></a>HTTP响应报文结构</h4><p><img src="https://s2.loli.net/2024/05/28/y8WvP3kSftibTE7.webp" alt="3"></p><hr><h3 id="构造请求报文"><a href="#构造请求报文" class="headerlink" title="构造请求报文"></a>构造请求报文</h3><p>这段代码主要是根据传入的URL和其他参数构建一个HTTP请求字符串，其中包括请求方法、协议版本、主机名、端口号等信息。根据不同的情况，拼接不同的信息到请求字符串中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">build_request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url)</span><br>&#123;<br>  <span class="hljs-type">char</span> tmp[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 临时存储的字符数组</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// 用于循环计数的变量</span><br><br>  bzero(host,MAXHOSTNAMELEN); <span class="hljs-comment">// 清空host数组</span><br>  bzero(request,REQUEST_SIZE); <span class="hljs-comment">// 清空request数组</span><br><br>  <span class="hljs-keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="hljs-literal">NULL</span> &amp;&amp; http10&lt;<span class="hljs-number">1</span>) http10=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_HEAD &amp;&amp; http10&lt;<span class="hljs-number">1</span>) http10=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_OPTIONS &amp;&amp; http10&lt;<span class="hljs-number">2</span>) http10=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span>(method==METHOD_TRACE &amp;&amp; http10&lt;<span class="hljs-number">2</span>) http10=<span class="hljs-number">2</span>;<br><br>  <span class="hljs-keyword">switch</span>(method) <span class="hljs-comment">// 根据请求方法类型选择相应的字符串</span><br>  &#123;<br>  <span class="hljs-keyword">default</span>:<br>  <span class="hljs-keyword">case</span> METHOD_GET: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;GET&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// GET请求</span><br>  <span class="hljs-keyword">case</span> METHOD_HEAD: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;HEAD&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// HEAD请求</span><br>  <span class="hljs-keyword">case</span> METHOD_OPTIONS: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;OPTIONS&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// OPTIONS请求</span><br>  <span class="hljs-keyword">case</span> METHOD_TRACE: <span class="hljs-built_in">strcpy</span>(request,<span class="hljs-string">&quot;TRACE&quot;</span>);<span class="hljs-keyword">break</span>; <span class="hljs-comment">// TRACE请求</span><br>  &#125;<br>  <br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">// 在请求字符串后面拼接空格</span><br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span>==<span class="hljs-built_in">strstr</span>(url,<span class="hljs-string">&quot;://&quot;</span>)) <span class="hljs-comment">// 检查URL是否包含&quot;://&quot;</span><br>  &#123;<br>  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n%s: is not a valid URL.\n&quot;</span>,url); <span class="hljs-comment">// 输出错误信息</span><br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(url)&gt;<span class="hljs-number">1500</span>) <span class="hljs-comment">// 检查URL长度是否超过1500</span><br>  &#123;<br>         <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;URL is too long.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br> <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 如果没有设置代理</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>!=strncasecmp(<span class="hljs-string">&quot;http://&quot;</span>,url,<span class="hljs-number">7</span>)) <span class="hljs-comment">// 如果URL不以&quot;http://&quot;开头</span><br>   &#123; <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;\nOnly HTTP protocol is directly supported, set --proxy for others.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br>             <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>           &#125;<br>  <span class="hljs-comment">/* protocol/host delimiter */</span><br>  i=<span class="hljs-built_in">strstr</span>(url,<span class="hljs-string">&quot;://&quot;</span>)-url+<span class="hljs-number">3</span>; <span class="hljs-comment">// 获取协议和主机名的分隔位置</span><br><br>  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;/&#x27;</span>)==<span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 检查URL是否包含&#x27;/&#x27;</span><br>                                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;\nInvalid URL syntax - hostname don&#x27;t ends with &#x27;/&#x27;.\n&quot;</span>); <span class="hljs-comment">// 输出错误信息</span><br>                                <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 退出程序</span><br>                              &#125;<br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 如果没有设置代理</span><br>  &#123;<br>   <span class="hljs-comment">/* get port from hostname */</span><br>   <span class="hljs-keyword">if</span>(index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)!=<span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-comment">// 如果URL包含端口号</span><br>      index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)&lt;index(url+i,<span class="hljs-string">&#x27;/&#x27;</span>))<br>   &#123;<br>   <span class="hljs-built_in">strncpy</span>(host,url+i,<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)-url-i); <span class="hljs-comment">// 获取主机名</span><br>   bzero(tmp,<span class="hljs-number">10</span>); <span class="hljs-comment">// 清空临时数组</span><br>   <span class="hljs-built_in">strncpy</span>(tmp,index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)+<span class="hljs-number">1</span>,<span class="hljs-built_in">strchr</span>(url+i,<span class="hljs-string">&#x27;/&#x27;</span>)-index(url+i,<span class="hljs-string">&#x27;:&#x27;</span>)<span class="hljs-number">-1</span>); <span class="hljs-comment">// 获取端口号</span><br>   proxyport=atoi(tmp); <span class="hljs-comment">// 将端口号转换为整数</span><br>   <span class="hljs-keyword">if</span>(proxyport==<span class="hljs-number">0</span>) proxyport=<span class="hljs-number">80</span>; <span class="hljs-comment">// 如果端口号为0，默认设为80</span><br>   &#125; <span class="hljs-keyword">else</span><br>   &#123;<br>     <span class="hljs-built_in">strncpy</span>(host,url+i,<span class="hljs-built_in">strcspn</span>(url+i,<span class="hljs-string">&quot;/&quot;</span>)); <span class="hljs-comment">// 获取主机名</span><br>   &#125;<br>   <span class="hljs-built_in">strcat</span>(request+<span class="hljs-built_in">strlen</span>(request),url+i+<span class="hljs-built_in">strcspn</span>(url+i,<span class="hljs-string">&quot;/&quot;</span>)); <span class="hljs-comment">// 拼接请求字符串</span><br>  &#125; <span class="hljs-keyword">else</span><br>  &#123;<br>   <span class="hljs-built_in">strcat</span>(request,url); <span class="hljs-comment">// 如果设置了代理，直接将URL拼接到请求字符串中</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(http10==<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; HTTP/1.0&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.0版本，拼接到请求字符串中</span><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (http10==<span class="hljs-number">2</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot; HTTP/1.1&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.1版本，拼接到请求字符串中</span><br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 拼接回车换行符</span><br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;User-Agent: WebBench &quot;</span>PROGRAM_VERSION<span class="hljs-string">&quot;\r\n&quot;</span>); <span class="hljs-comment">// 拼接用户代理信息</span><br>  <span class="hljs-keyword">if</span>(proxyhost==<span class="hljs-literal">NULL</span> &amp;&amp; http10&gt;<span class="hljs-number">0</span>)<br>  &#123;<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Host: &quot;</span>); <span class="hljs-comment">// 拼接主机名</span><br>  <span class="hljs-built_in">strcat</span>(request,host);<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(force_reload &amp;&amp; proxyhost!=<span class="hljs-literal">NULL</span>)<br>  &#123;<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Pragma: no-cache\r\n&quot;</span>); <span class="hljs-comment">// 拼接Pragma信息</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">1</span>)<br>  <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;Connection: close\r\n&quot;</span>); <span class="hljs-comment">// 如果是HTTP/1.1，拼接Connection信息</span><br>  <span class="hljs-comment">/* add empty line at end */</span><br>  <span class="hljs-keyword">if</span>(http10&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">strcat</span>(request,<span class="hljs-string">&quot;\r\n&quot;</span>);  <span class="hljs-comment">// 拼接最后的空行</span><br>  <span class="hljs-comment">// printf(&quot;Req=%s\n&quot;,request); // 打印请求字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="进程通信基础知识"><a href="#进程通信基础知识" class="headerlink" title="进程通信基础知识"></a>进程通信基础知识</h3><blockquote><p>这一部分其实需要了解一定的操作系统知识，这里只是简单的阐述一些webbench源码中的关键点。</p><p>具体参考：</p><p>[进程的基本属性|父子进程关系](<a href="https://developer.aliyun.com/article/1363183">【Linux】进程的基本属性|父子进程关系-阿里云开发者社区 (aliyun.com)</a>)</p><p><a href="%5B%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E4%BB%A5fork()%E4%B8%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Ffork-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/Bossfrank/article/details/136706625)">以fork()为例详解进程的创建过程与父子进程关系</a></p><p><a href="https://blog.csdn.net/JMW1407/article/details/107700451#:~:text=1%E3%80%81%E5%AE%9A%E4%B9%89%EF%BC%88%E6%B0%B4%E7%AE%A1%EF%BC%88pipe%EF%BC%89%EF%BC%89%201%20%E7%AE%A1%E9%81%93%E6%98%AF%E4%B8%80%E7%A7%8D%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E3%80%82%20%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A7%B0%E4%B8%BA%E4%B8%80%E4%B8%AA%E2%80%9C%E7%AE%A1%E9%81%93%E2%80%9D%EF%BC%8C%E9%80%9A%E5%B8%B8%E6%98%AF%E7%94%A8%E4%BD%9C,%E6%8A%8A%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BE%93%E5%87%BA%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BE%93%E5%85%A5%20%E3%80%82%202%20%E7%AE%A1%E9%81%93%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%86%85%E6%A0%B8%E7%9A%84%E4%B8%80%E5%9D%97%E7%BC%93%E5%AD%98%20%EF%BC%8C%E5%86%85%E6%A0%B8%E7%BB%B4%E6%8A%A4%E4%BA%86%E4%B8%80%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%AE%A1%E9%81%93%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%81%94%EF%BC%8C%E5%AF%B9%E7%AE%A1%E9%81%93%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%A2%AB%E5%86%85%E6%A0%B8%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AF%B9%E8%BF%99%E5%9D%97%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E5%AD%98%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82">管道通信</a></p></blockquote><h4 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h4><p>在 Unix 和 Linux中，每个进程都有一个唯一的进程标识符（PID），以及一个父进程标识符（PPID），这两个值使得子进程能够知道它们的父进程是什么。</p><ol><li><strong>PID（Process ID）</strong>：这是操作系统分配给每个进程的唯一标识符。每个进程都有一个唯一的 PID。</li><li><strong>PPID（Parent Process ID）</strong>：这是进程的父进程的 PID。PPID 指示了哪个进程创建了当前进程。</li></ol><p>当进程 A 调用 <code>fork()</code> 时，会创建一个子进程 B。对于子进程 B，它的 PPID 会被设置为进程 A 的 PID。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Process</span> A: PID = <span class="hljs-number">12345</span><br>Parent process: PID = <span class="hljs-number">12345</span>, Child PID = <span class="hljs-number">12346</span><br>Child process: PID = <span class="hljs-number">12346</span>, PPID = <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p><strong>同时父进程会获得一个非零的PID（子进程的PID），而子进程会获得0作为返回值。这使得我们可以通过检查返回值的大小来区分父子进程</strong></p><p><strong>注意这里的返回0并不是将子进程PID设为0</strong>，而是出于以下方面考虑：</p><ul><li><p><strong>区分父进程和子进程的执行流</strong></p><p>当调用 <code>fork()</code> 时，会创建一个新的子进程。<code>fork()</code> 在父进程中返回子进程的 PID，而在子进程中返回 0。这种设计让同一段代码能够在两个不同的进程中执行不同的逻辑。</p></li><li><p><strong>简化错误处理</strong></p><p>如果 <code>fork()</code> 返回一个负值（通常是 -1），这表明进程创建失败。父进程可以立即检查这个返回值并进行相应的错误处理。</p></li><li><p><strong>方便进程间通信和同步</strong></p><p>由于 <code>fork()</code> 在子进程中返回 0，父进程可以使用返回的子进程 PID 来进行进程间的通信和同步操作。例如，父进程可以等待子进程结束，或者通过信号与子进程进行通信。</p></li><li><p><strong>实现多进程并发</strong></p><p><code>fork()</code> 机制使得多进程并发编程变得简单。父进程可以连续调用 <code>fork()</code> 多次，创建多个子进程来处理不同的任务或相同任务的不同部分，从而实现并发处理。</p></li></ul><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png" alt="ef5085c798d54fc081611d0d488dfeb1"></p><blockquote><p><strong>信号</strong>：信号是 Linux 进程间通信的一种简单机制。它是由操作系统或进程向另一个进程发送的软件中断，用于通知进程发生了某种事件。</p><p><strong>信号处理程序</strong>：每个信号都与一个信号处理程序相关联，用于在收到信号时执行特定的操作。信号处理程序可以是预定义的函数，也可以是用户自定义的函数。</p><p><strong>信号的发送和接收</strong>：信号可以由内核、其他进程或进程自身发送。接收信号的进程可以选择忽略信号、执行默认操作或安装自定义的信号处理程序。</p><p><strong>常见的信号</strong>：Linux 系统定义了许多标准信号，如 SIGALRM（定时器到期）、SIGINT（终端中断）、SIGKILL（强制终止进程）等。</p><p><strong>信号的处理方式</strong>：每个进程都有一个信号处理表，记录了每个信号的处理方式。可以通过 <code>sigaction()</code> 函数来修改信号处理方式。</p><p><strong>信号的异步性</strong>：信号是异步事件，即进程可能在任何时刻接收到信号，而不一定是在某个特定的程序点。因此，编写信号处理程序时需要注意处理信号的竞态条件和可重入性。</p></blockquote><h5 id="使用Linux信号机制具体步骤："><a href="#使用Linux信号机制具体步骤：" class="headerlink" title="使用Linux信号机制具体步骤："></a>使用Linux信号机制具体步骤：</h5><ol><li><strong>定义信号处理程序</strong>：编写一个函数来处理特定的信号。</li><li><strong>注册信号处理程序</strong>：使用 <code>signal()</code> 或 <code>sigaction()</code> 函数将信号处理程序与特定的信号关联起来。</li><li><strong>触发信号</strong>：通过特定的操作或系统调用触发信号，或使用 <code>kill()</code> 函数向自己或其他进程发送信号。</li></ol><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信号处理程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT (Ctrl+C). Exiting gracefully...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGALRM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGALRM. Performing scheduled task...\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里执行你需要的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号处理程序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    sa.sa_handler = signal_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;sa.sa_mask);<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGINT handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGALRM handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个定时器，5秒后发送 SIGALRM 信号</span><br>    alarm(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 无限循环，等待信号</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for signals...\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h4><p>Linux的管道机制允许一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信（IPC）。管道有两种：无名管道和命名管道（FIFO）。无名管道通常用于具有亲缘关系的进程之间的通信（如父子进程），而命名管道可以用于任意两个进程之间的通信。</p><h5 id="管道的工作原理"><a href="#管道的工作原理" class="headerlink" title="管道的工作原理"></a>管道的工作原理</h5><p>管道在内核中创建一个缓冲区，一个进程可以向缓冲区写入数据，另一个进程可以从缓冲区读取数据。管道是单向的，即数据只能单方向流动。</p><p><img src="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png" alt="20200730212919317"></p><h5 id="管道通信与共享内存通信有何区别？"><a href="#管道通信与共享内存通信有何区别？" class="headerlink" title="管道通信与共享内存通信有何区别？"></a>管道通信与共享内存通信有何区别？</h5><p>管道通信适用于有亲缘关系的进程，适合简单的数据传输；而共享内存通信适用于无亲缘关系的进程，适合大量数据共享和对性能要求较高的场景</p><h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a><strong>管道通信：</strong></h5><ol><li><ul><li>管道是一种半双工的通信机制，只能在具有亲缘关系的进程之间使用（例如父子进程）。</li><li>管道是基于 I&#x2F;O 流的通信方式，数据写入管道的一端，从另一端读出。</li><li>管道通信是通过操作系统提供的管道文件进行的，可以是匿名管道（只存在于进程间）或命名管道（存在于文件系统中）。</li><li>管道通信适用于需要在两个相关进程之间进行简单数据传输的场景。</li></ul></li><li><strong>共享内存通信：</strong><ul><li>共享内存是一种进程间通信的机制，可以在无亲缘关系的进程之间使用。</li><li>共享内存允许多个进程访问同一块物理内存空间，因此可以实现高效的数据共享。</li><li>共享内存通信需要使用操作系统提供的共享内存 API，通过映射共享内存区域来实现进程间数据共享。</li><li>共享内存通信适用于需要大量数据交换且对性能要求较高的场景，因为它避免了数据复制的开销。</li></ul></li></ol><h5 id="使用管道的步骤"><a href="#使用管道的步骤" class="headerlink" title="使用管道的步骤"></a>使用管道的步骤</h5><ol><li><strong>创建管道</strong>：使用 <code>pipe()</code> 系统调用创建一个无名管道。</li><li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程。</li><li><strong>重定向输入&#x2F;输出</strong>：使用 <code>dup2()</code> 将管道的读或写端重定向到标准输入或标准输出。</li><li><strong>关闭不需要的管道端</strong>：父进程和子进程都要关闭各自不需要使用的管道端。</li><li><strong>执行程序</strong>：使用 <code>execlp()</code> 或其他 <code>exec</code> 函数执行新程序。</li></ol><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello from parent process!&quot;</span>;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (pipe(pipe_fd) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br><br>        <span class="hljs-comment">// 读取管道</span><br>        <span class="hljs-type">ssize_t</span> nbytes = read(pipe_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 打印读取到的消息</span><br>        buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received message: %s\n&quot;</span>, buf);<br><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br><br>        <span class="hljs-comment">// 写入管道</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[<span class="hljs-number">1</span>], msg, <span class="hljs-built_in">strlen</span>(msg)) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        wait(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>pipe()</code> 创建一个无名管道，<code>pipe_fd</code> 是一个包含两个文件描述符的数组，<code>pipe_fd[0]</code> 是读端，<code>pipe_fd[1]</code> 是写端。</p><p>在这个示例中没有使用 <code>dup2()</code> 重定向输入&#x2F;输出，而是直接使用文件描述符进行读写。你也可以通过 <code>dup2(pipe_fd[0], STDIN_FILENO)</code> 或 <code>dup2(pipe_fd[1], STDOUT_FILENO)</code> 来重定向标准输入&#x2F;输出。</p><p><strong>注意:当父进程fork()出子进程时，子进程会继承父进程的文件描述符。因此，子进程可以直接使用这些继承而来的文件描述符来读取或写入数据，从而与父进程进行通信。而无需使用<code>dup2()</code>来重定向输入&#x2F;输出。</strong></p><p>将管道的读端重定向到标准输入或将管道的写端重定向到标准输出是实现进程间通信的一种常见方式。这种方法可以实现多个进程之间的数据传输，而无需使用临时文件进行交换。</p><p>例如，如果一个进程需要从另一个进程中读取数据，可以通过将管道的读端重定向到标准输入来实现。这样，另一个进程输出的数据就会被发送到管道中，而第一个进程可以通过标准输入读取这些数据。</p><p>这种方法的好处在于，它提供了一种简单而高效的方式让不同的进程之间进行数据交换，而不需要创建临时文件或者复杂的通信协议。这对于实现诸如管道、重定向、过滤器等功能非常有用，同时也能够方便地实现进程间的通信和协作。</p><hr><h3 id="网络压力测试函数"><a href="#网络压力测试函数" class="headerlink" title="网络压力测试函数"></a>网络压力测试函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">benchcore</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">int</span> port, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *req)</span><br>&#123;<br>    <span class="hljs-type">int</span> rlen;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br>    <span class="hljs-type">int</span> s, i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br><br>    <span class="hljs-comment">/* 设置闹钟信号处理器 */</span><br>    sa.sa_handler = alarm_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br>    alarm(benchtime);<br><br>    rlen = <span class="hljs-built_in">strlen</span>(req);  <span class="hljs-comment">// 计算请求字符串的长度</span><br>nexttry:<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (timerexpired)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (failed &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">/* 通过信号纠正失败次数 */</span><br>                failed--;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 建立与主机的连接</span><br>        s = Socket(host, port);<br>        <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 发送请求到服务器</span><br>        <span class="hljs-keyword">if</span> (rlen != write(s, req, rlen))<br>        &#123;<br>            failed++;<br>            close(s);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果使用 HTTP/1.0，关闭写入端</span><br>        <span class="hljs-keyword">if</span> (http10 == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (shutdown(s, <span class="hljs-number">1</span>))<br>            &#123;<br>                failed++;<br>                close(s);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不强制关闭连接，读取服务器的响应数据</span><br>        <span class="hljs-keyword">if</span> (force == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 从套接字中读取所有可用的数据 */</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (timerexpired)<br>                    <span class="hljs-keyword">break</span>;<br><br>                i = read(s, buf, <span class="hljs-number">1500</span>);<br><br>                <span class="hljs-comment">/* 检查读取结果 */</span><br>                <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    failed++;<br>                    close(s);<br>                    <span class="hljs-keyword">goto</span> nexttry;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    bytes += i;  <span class="hljs-comment">// 记录读取的字节数</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭套接字连接</span><br>        <span class="hljs-keyword">if</span> (close(s))<br>        &#123;<br>            failed++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        speed++;  <span class="hljs-comment">// 成功请求次数计数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>benchcore</code> 函数的主要作用是对指定的主机和端口发送 HTTP 请求，并记录响应数据以进行性能测试。这是一个典型的网络压力测试函数。具体步骤如下：</p><ol><li><strong>设置信号处理器</strong>：<ul><li>使用 <code>sigaction</code> 设置闹钟信号处理器 <code>alarm_handler</code>，并启动定时器 <code>alarm(benchtime)</code> 来控制测试时间。</li></ul></li><li><strong>循环发送请求并处理响应</strong>：<ul><li>在 <code>while</code> 循环中不断向服务器发送请求，直到定时器到期 (<code>timerexpired</code> 为 <code>true</code>)。</li><li>调用 <code>Socket</code> 函数建立与服务器的连接，若连接失败，增加 <code>failed</code> 计数并继续下一次尝试。</li><li>使用 <code>write</code> 将请求发送到服务器，如果写入失败，增加 <code>failed</code> 计数并关闭套接字，继续下一次尝试。</li><li>如果使用 HTTP&#x2F;1.0 协议，通过 <code>shutdown</code> 关闭写入端。</li><li>如果 <code>force</code> 为 <code>0</code>，则读取服务器的响应数据并累计读取的字节数 <code>bytes</code>。</li><li>关闭套接字连接，若关闭失败，增加 <code>failed</code> 计数并继续下一次尝试。</li><li>每次成功处理一个请求后，增加 <code>speed</code> 计数。</li></ul></li></ol><p>通过这个函数，可以对服务器进行压力测试，统计在指定时间内成功处理的请求数 (<code>speed</code>) 和失败的请求数 (<code>failed</code>)，以及累计读取的字节数 (<code>bytes</code>)。</p><hr><h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p><code>bench</code> 函数的主要作用是执行基准测试，通过创建子进程并分发任务来模拟多个客户端对服务器的并发请求，并统计测试结果。具体步骤如下：</p><ol><li><strong>检查目标服务器的可用性</strong>：<ul><li>调用 <code>Socket</code> 函数尝试连接目标服务器，若连接失败则终止基准测试。</li></ul></li><li><strong>创建管道</strong>：<ul><li>使用 <code>pipe</code> 函数创建一个管道，用于子进程和父进程之间的通信。</li></ul></li><li><strong>分叉子进程</strong>：<ul><li>使用 <code>fork</code> 函数创建指定数量的子进程，并在子进程中执行任务。</li></ul></li><li><strong>子进程执行任务</strong>：<ul><li>每个子进程调用 <code>benchcore</code> 函数执行基准测试任务，并将结果写入管道。</li></ul></li><li><strong>父进程读取子进程的结果</strong>：<ul><li>父进程从管道中读取各个子进程执行任务的结果，并统计总体性能指标。</li></ul></li><li><strong>输出测试结果</strong>：<ul><li>输出基准测试的结果，包括请求速度、传输速率以及成功和失败的请求数量。</li></ul></li></ol><p>通过这个函数，可以模拟多个并发用户对服务器进行压力测试，并获取测试结果以评估服务器的性能表现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bench</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-number">0</span>;<br>    FILE *f;<br><br>    <span class="hljs-comment">/* 检查目标服务器的可用性 */</span><br>    i = Socket(proxyhost == <span class="hljs-literal">NULL</span> ? host : proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;\n连接服务器失败。终止基准测试。\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    close(i);<br><br>    <span class="hljs-comment">/* 创建管道 */</span><br>    <span class="hljs-keyword">if</span> (pipe(mypipe))<br>    &#123;<br>        perror(<span class="hljs-string">&quot;pipe failed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 分叉子进程 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; clients; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid &lt;= (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* 子进程或出错 */</span><br>            sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">/* 使子进程更快 */</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &lt; (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;forking worker no. %d 出现问题\n&quot;</span>, i);<br>        perror(<span class="hljs-string">&quot;fork failed.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == (<span class="hljs-type">pid_t</span>)<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 我是一个子进程 */</span><br>        <span class="hljs-keyword">if</span> (proxyhost == <span class="hljs-literal">NULL</span>)<br>            benchcore(host, proxyport, request);<br>        <span class="hljs-keyword">else</span><br>            benchcore(proxyhost, proxyport, request);<br><br>        <span class="hljs-comment">/* 将结果写入管道 */</span><br>        f = fdopen(mypipe[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;w&quot;</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;打开管道写入失败。&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        <span class="hljs-comment">/* fprintf(stderr,&quot;Child - %d %d\n&quot;,speed,failed); */</span><br>        <span class="hljs-built_in">fprintf</span>(f, <span class="hljs-string">&quot;%d %d %d\n&quot;</span>, speed, failed, bytes);<br>        fclose(f);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        f = fdopen(mypipe[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;r&quot;</span>);<br>        <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;打开管道读取失败。&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        &#125;<br>        setvbuf(f, <span class="hljs-literal">NULL</span>, _IONBF, <span class="hljs-number">0</span>);<br>        speed = <span class="hljs-number">0</span>;<br>        failed = <span class="hljs-number">0</span>;<br>        bytes = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            pid = <span class="hljs-built_in">fscanf</span>(f, <span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;i, &amp;j, &amp;k);<br>            <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;我们的一些子进程已经退出。\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            speed += i;<br>            failed += j;<br>            bytes += k;<br>            <span class="hljs-comment">/* fprintf(stderr,&quot;*Knock* %d %d read=%d\n&quot;,speed,failed,pid); */</span><br>            <span class="hljs-keyword">if</span> (--clients == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        fclose(f);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n速度=%d 页面/分钟，%d 字节/秒。\n请求数: %d 成功，%d 失败。\n&quot;</span>,<br>               (<span class="hljs-type">int</span>)((speed + failed) / (benchtime / <span class="hljs-number">60.0f</span>)),<br>               (<span class="hljs-type">int</span>)(bytes / (<span class="hljs-type">float</span>)benchtime),<br>               speed,<br>               failed);<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p><code>main</code> 函数是 Webbench 工具的主要入口点，负责解析命令行参数、构建 HTTP 请求、执行基准测试，并输出测试结果。具体步骤如下：</p><ol><li><strong>解析命令行参数</strong>：<ul><li>使用 <code>getopt_long</code> 函数解析命令行参数，支持短选项（如 <code>-f</code>, <code>-r</code>, <code>-t</code>）和长选项（如 <code>--help</code>, <code>--version</code>）。</li><li>根据解析结果设置相应的全局变量，如 <code>force</code>、<code>force_reload</code>、<code>benchtime</code> 等。</li></ul></li><li><strong>构建 HTTP 请求</strong>：<ul><li>调用 <code>build_request</code> 函数根据用户提供的 URL 构建相应的 HTTP 请求，包括请求方法、协议版本等信息。</li></ul></li><li><strong>执行基准测试</strong>：<ul><li>调用 <code>bench</code> 函数执行基准测试，该函数会模拟多个并发客户端向目标服务器发起请求</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> opt = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> options_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> *tmp = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果没有提供任何参数，则显示用法信息并返回</span><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    &#123;<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 解析命令行参数</span><br>    <span class="hljs-keyword">while</span> ((opt = getopt_long(argc, argv, <span class="hljs-string">&quot;912Vfrt:p:c:?h&quot;</span>, long_options, &amp;options_index)) != EOF)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (opt)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>            force = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>            force_reload = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:<br>            http10 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>            http10 = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>            http10 = <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;V&#x27;</span>:<br>            <span class="hljs-built_in">printf</span>(PROGRAM_VERSION <span class="hljs-string">&quot;\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>            benchtime = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:<br>            <span class="hljs-comment">/* 代理服务器解析 server:port */</span><br>            tmp = <span class="hljs-built_in">strrchr</span>(optarg, <span class="hljs-string">&#x27;:&#x27;</span>);<br>            proxyhost = optarg;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp == optarg)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;错误的选项 --proxy %s: 缺少主机名。\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tmp == optarg + <span class="hljs-built_in">strlen</span>(optarg) - <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;错误的选项 --proxy %s: 缺少端口号。\n&quot;</span>, optarg);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            &#125;<br>            *tmp = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            proxyport = atoi(tmp + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>            usage();<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>            clients = atoi(optarg);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有提供 URL，则显示错误信息并返回</span><br>    <span class="hljs-keyword">if</span> (optind == argc)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;webbench: 缺少 URL！\n&quot;</span>);<br>        usage();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置默认客户端数量和测试时长</span><br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">0</span>)<br>        clients = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (benchtime == <span class="hljs-number">0</span>)<br>        benchtime = <span class="hljs-number">60</span>;<br><br>    <span class="hljs-comment">// 版权声明</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Webbench - 简单的 Web 基准测试 &quot;</span> PROGRAM_VERSION <span class="hljs-string">&quot;\n&quot;</span><br>                    <span class="hljs-string">&quot;版权所有 (C) Radim Kolar 1997-2004, GPL 开源软件。\n&quot;</span>);<br><br>    <span class="hljs-comment">// 构建 HTTP 请求</span><br>    build_request(argv[optind]);<br><br>    <span class="hljs-comment">// 打印基准测试信息</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n正在进行基准测试: &quot;</span>);<br>    <span class="hljs-keyword">switch</span> (method)<br>    &#123;<br>    <span class="hljs-keyword">case</span> METHOD_GET:<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;GET&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_OPTIONS:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OPTIONS&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_HEAD:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HEAD&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> METHOD_TRACE:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;TRACE&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %s&quot;</span>, argv[optind]);<br>    <span class="hljs-keyword">switch</span> (http10)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; (使用 HTTP/0.9)&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; (使用 HTTP/1.1)&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (clients == <span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1 个客户端&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 个客户端&quot;</span>, clients);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 运行 %d 秒&quot;</span>, benchtime);<br>    <span class="hljs-keyword">if</span> (force)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 提前关闭套接字&quot;</span>);<br>    <span class="hljs-keyword">if</span> (proxyhost != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 通过代理服务器 %s:%d&quot;</span>, proxyhost, proxyport);<br>    <span class="hljs-keyword">if</span> (force_reload)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, 强制重新加载&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.\n&quot;</span>);<br><br>    <span class="hljs-comment">// 执行基准测试</span><br>    <span class="hljs-keyword">return</span> bench();<br>&#125;<br></code></pre></td></tr></table></figure><p><em><strong>完！</strong></em></p><hr>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx时间管理与定时器</title>
    <link href="/2023/03/07/Nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/03/07/Nginx%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx数据结构"><a href="#nginx数据结构" class="headerlink" title="nginx数据结构"></a>nginx数据结构</h1><p><img src="https://s2.loli.net/2024/05/25/qrI7kPjaR5mlwKu.png" alt="20210709173511720"></p><h3 id="整型数据类型ngx-int-t"><a href="#整型数据类型ngx-int-t" class="headerlink" title="整型数据类型ngx_int_t"></a>整型数据类型ngx_int_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_int_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uintptr_t</span>       <span class="hljs-type">ngx_uint_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">intptr_t</span>        <span class="hljs-type">ngx_flag_t</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库 <code>stdint.h</code> 中定义的整数类型，它们用于存储指针值。它们的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-type">long</span>   <span class="hljs-type">intptr_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">uintptr_t</span>;<br></code></pre></td></tr></table></figure><ol><li><ul><li>**<code>intptr_t</code>**：这是一个有符号整数类型，能够存储一个指针。它的大小与指针相同，可以安全地存储和操作指针值。</li><li>**<code>uintptr_t</code>**：这是一个无符号整数类型，能够存储一个指针。与 <code>intptr_t</code> 类似，它的大小也与指针相同。</li></ul></li></ol><h4 id="基础巩固"><a href="#基础巩固" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><p><strong>什么是有符号整数类型和无符号整数类型？</strong></p><blockquote><h4 id="有符号整数类型"><a href="#有符号整数类型" class="headerlink" title="有符号整数类型"></a>有符号整数类型</h4><p>有符号整数类型（Signed Integer Type）是可以表示正数、负数和零的整数类型。它的最高位通常用作符号位（0 表示正，1 表示负）。在 C 语言中，常见的有符号整数类型包括 <code>int</code>、<code>short</code>、<code>long</code> 等。</p><p>例如，在一个 8 位（1 字节）的有符号整数中：</p><ul><li>最高位是符号位。</li><li>值范围是从 -128 到 127。</li></ul><p>二进制表示：</p><ul><li><code>01111111</code> (127)</li><li><code>10000000</code> (-128)</li></ul><h4 id="无符号整数类型"><a href="#无符号整数类型" class="headerlink" title="无符号整数类型"></a>无符号整数类型</h4><p>无符号整数类型（Unsigned Integer Type）只能表示非负整数（正数和零）。所有位都用于表示数值，因此可以表示更大的正数范围。常见的无符号整数类型包括 <code>unsigned int</code>、<code>unsigned short</code>、<code>unsigned long</code> 等。</p><p>例如，在一个 8 位（1 字节）的无符号整数中：</p><ul><li>没有符号位，所有位都用于表示数值。</li><li>值范围是从 0 到 255。</li></ul><p>二进制表示：</p><ul><li><code>00000000</code> (0)</li><li><code>11111111</code> (255)</li></ul></blockquote><p><strong>为什么是<code>intptr_t</code>和uintptr_t 而不是  int ？</strong></p><p>对于 C 语言的实现，<code>intptr_t</code> 和 <code>uintptr_t</code> 是定义为与平台的指针大小相同的有符号和无符号整数类型。这意味着在 32 位平台上，它们通常是 32 位整数，而在 64 位平台上，它们通常是 64 位整数。</p><p>这种类型的定义是为了确保在不同平台上具有相同的大小，从而使得代码在不同平台上具有可移植性</p><p><strong>整数类型与指针的关系？</strong></p><blockquote><ul><li><strong>指针类型</strong>：指针类型用于存储内存地址，表示变量或数据在内存中的位置。指针的大小取决于系统架构（例如，32 位系统上的指针为 4 字节，64 位系统上的指针为 8 字节）。</li><li><strong>整数类型与指针</strong>：在某些情况下，可以使用整数类型来存储或操作指针值。例如，<code>intptr_t</code> 和 <code>uintptr_t</code> 是标准库中定义的类型，用于存储可以容纳指针值的有符号和无符号整数。这在需要将指针转化为整数或将整数转化为指针的操作中很有用。</li></ul></blockquote><p><strong>整数类型在不同的系统架构（如 32 位和 64 位）有何区别？</strong></p><blockquote><h4 id="32-位系统"><a href="#32-位系统" class="headerlink" title="32 位系统"></a>32 位系统</h4><ul><li><strong>整数类型</strong>：典型地，<code>int</code> 为 4 字节，<code>long</code> 为 4 字节，<code>pointer</code> 为 4 字节。</li><li><strong>指针类型</strong>：指针占用 4 字节，能够表示的地址范围是 0 到 2^32 - 1（4 GB）。</li></ul><h4 id="64-位系统"><a href="#64-位系统" class="headerlink" title="64 位系统"></a>64 位系统</h4><ul><li><strong>整数类型</strong>：<code>int</code> 仍然通常为 4 字节，<code>long</code> 和 <code>pointer</code> 为 8 字节。</li><li><strong>指针类型</strong>：指针占用 8 字节，能够表示的地址范围是 0 到 2^64 - 1（16 EB）。</li></ul></blockquote><h3 id="字符串数据类型ngx-str-t"><a href="#字符串数据类型ngx-str-t" class="headerlink" title="字符串数据类型ngx_str_t"></a>字符串数据类型ngx_str_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">size_t</span>      len;    <span class="hljs-comment">/* 字符串的长度 */</span><br>    u_char     *data;   <span class="hljs-comment">/* 指向字符串的第一个字符 */</span><br>&#125; <span class="hljs-type">ngx_str_t</span>;<br></code></pre></td></tr></table></figure><h4 id="结构体成员"><a href="#结构体成员" class="headerlink" title="结构体成员"></a>结构体成员</h4><ul><li><strong><code>size_t len</code></strong>: 这是一个无符号整数类型，用于存储字符串的长度。<code>size_t</code> 类型通常用于表示对象的大小或数组的长度，它的大小依赖于具体的系统架构（在32位系统上通常是4字节，在64位系统上通常是8字节）。</li><li><strong><code>u_char *data</code></strong>: 这是一个指向字符串第一个字符的指针。<code>u_char</code> 通常是 <code>unsigned char</code> 的别名，表示无符号字符类型。这种类型保证了字符的值在 0 到 255 之间。</li></ul><h4 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h4><p><strong>为什么这里要附加一个字符串长度【len】相比较于传统string的优点？</strong></p><p>其实这种字符串处理方式在高性能场景下非常有用，尤其是在需要频繁处理字符串的网络服务器中，例如，再看redis的字符串设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> __<span class="hljs-title">attribute__</span> ((__<span class="hljs-title">packed__</span>)) <span class="hljs-title">sdshdr8</span> &#123;</span><br>    <span class="hljs-comment">//被使用的长度</span><br>    <span class="hljs-type">uint8_t</span> len; <span class="hljs-comment">/* used */</span><br>    <span class="hljs-comment">//除去头跟空终止符分配的空间</span><br>    <span class="hljs-type">uint8_t</span> alloc; <span class="hljs-comment">/* excluding the header and null terminator */</span><br>    <span class="hljs-comment">//标识字符，3位用于类型，5位未使用</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> flags; <span class="hljs-comment">/* 3 lsb of type, 5 unused bits */</span><br>    <span class="hljs-comment">//使用存储字符串的地方</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br></code></pre></td></tr></table></figure><p>它不依赖于以 <code>&#39;\0&#39;</code> 结尾来标识字符串的结束，而是明确地记录了字符串的长度。这种设计有几个优势：</p><ol><li><strong>性能优化</strong>：操作字符串时不需要遍历整个字符串寻找 <code>&#39;\0&#39;</code>，可以直接通过长度进行操作。</li><li><strong>支持二进制数据</strong>：能够处理包含 <code>&#39;\0&#39;</code> 字节的字符串或二进制数据，因为长度是显式存储的。</li><li><strong>更好的安全性</strong>：避免了因缺少字符串结束符导致的缓冲区溢出等安全问题。</li></ol><h5 id="基础巩固-1"><a href="#基础巩固-1" class="headerlink" title="基础巩固"></a>基础巩固</h5><p><strong>是否熟悉以下数据类型？</strong></p><blockquote><p><strong><code>size_t</code></strong> 是一种无符号整数类型，用于表示对象的大小或数组的长度。它的具体大小取决于系统架构，在 32 位系统上通常是 4 字节，在 64 位系统上通常是 8 字节。</p><p>**<code>unsigned int</code>**：无符号整型，在大多数平台上为 4 字节。</p><p>**<code>unsigned long</code>**：无符号长整型，在 32 位系统上通常为 4 字节，在 64 位系统上通常为 8 字节。</p><p><strong><code>u_char</code></strong> 通常是 <code>unsigned char</code> 的别名，用于表示无符号字符类型。它可以存储 0 到 255 之间的整数。大多数情况下，<code>uint8_t</code> 和 <code>unsigned char</code> 可以互换使用。</p><p><strong><code>uint8_t</code></strong> 是一种标准整数类型，主要优势在于它的跨平台一致性。无论是在 32 位系统还是 64 位系统上，<code>uint8_t</code> 总是表示 8 位无符号整数</p><p>**<code>uint16_t</code>**：表示 16 位无符号整数，取值范围为 0 到 65535。它保证在所有平台上都是 16 位，因此非常适合用于需要明确双字节大小的场合，如某些文件格式和协议字段等。</p><p>**<code>unsigned short</code>**：在许多平台上，<code>unsigned short</code> 通常是 16 位无符号整数，取值范围也是 0 到 65535。</p><p>**<code>uint_least16_t</code>**：确保至少有 16 位的无符号整数类型。</p><p>**<code>uint_fast16_t</code>**：确保至少有 16 位且运算速度最快的无符号整数类型。</p></blockquote><h3 id="内存池数据类型ngx-pool-s"><a href="#内存池数据类型ngx-pool-s" class="headerlink" title="内存池数据类型ngx_pool_s"></a>内存池数据类型ngx_pool_s</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">int</span> size = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 分配内存空间的大小</span><br><span class="hljs-comment">// 分配内存空间</span><br>ptr = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>.......<br><span class="hljs-built_in">free</span>(ptr);<br></code></pre></td></tr></table></figure><p>当我们使用malloc为程序申请内存时，会无法避免的出现<a href="https://www.cnblogs.com/zhaoyl/p/3820852.html">内存碎片</a>问题。</p><p><img src="https://s2.loli.net/2024/05/25/sk9HIyUFvebqcP8.png" alt="内存碎片"></p><p>这对于长时间运行的系统或者需要高性能的系统是致命的。</p><blockquote><ol><li><strong>内存浪费</strong>: 内存碎片导致一些内存无法被有效利用，即使整体上有足够的可用内存，但无法分配给大块连续的内存请求。这种情况下，系统实际可用内存会减少，造成内存资源的浪费。</li><li><strong>性能下降</strong>: 内存碎片可能导致内存分配效率下降。当请求大块连续内存时，系统需要搜索并合并碎片化的内存块，这可能会增加内存分配的开销和时间。此外，内存碎片也可能导致页面置换算法的性能下降，因为系统需要更频繁地进行页面换入换出操作。</li><li><strong>内存泄漏</strong>: 内存碎片可能导致内存泄漏问题的难以发现和排查。即使系统中存在大量的可用内存，但如果这些内存被分散成了小块碎片，而且这些碎片被长期占用而未被释放，就会导致整体内存资源的浪费和不足。</li><li><strong>系统稳定性降低</strong>: 当内存碎片达到一定程度时，可能会导致系统出现内存耗尽的情况，从而导致系统崩溃或者运行异常。特别是在长时间运行的系统中，内存碎片可能会逐渐积累，最终导致系统的稳定性降低。</li></ol></blockquote><p>解决方案之一就是使用<strong>内存池</strong>，这里推荐大家一个手写<a href="https://zhuanlan.zhihu.com/p/435427939">内存池项目</a> </p><p>简短的来说，内存池通过预先分配一定大小的内存块，并按需分配和释放这些内存块，以减少内存碎片的产生。</p><p>现在再回到Nginx的内存池上：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 文件 core/ngx_palloc.h */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span>            <span class="hljs-title">ngx_pool_t</span>;</span><br><span class="hljs-comment">//指向以 void *data 作为参数并且没有返回值的函数的指针。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_pool_cleanup_pt)</span><span class="hljs-params">(<span class="hljs-type">void</span> *data)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span>  <span class="hljs-title">ngx_pool_cleanup_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_cleanup_s</span> &#123;</span><br>    ngx_pool_cleanup_pt   handler;  <span class="hljs-comment">// 清理函数指针，用于在释放内存时执行清理操作</span><br>    <span class="hljs-type">void</span>                 *data;     <span class="hljs-comment">// 清理函数的参数</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *next;     <span class="hljs-comment">// 指向下一个清理结构体的指针，构成清理链表</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span>  <span class="hljs-title">ngx_pool_large_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_large_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *next;     <span class="hljs-comment">// 指向下一个大块内存结构体的指针，构成大块内存链表</span><br>    <span class="hljs-type">void</span>                 *alloc;    <span class="hljs-comment">// 分配的大块内存的指针</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    u_char               *last;     <span class="hljs-comment">// 当前内存分配的结束位置，下一段可分配内存的起始位置</span><br>    u_char               *end;      <span class="hljs-comment">// 内存池的结束位置</span><br>    <span class="hljs-type">ngx_pool_t</span>           *next;     <span class="hljs-comment">// 指向下一个内存池的指针</span><br>    <span class="hljs-type">ngx_uint_t</span>            failed;   <span class="hljs-comment">// 记录内存池内存分配失败的次数</span><br>&#125; <span class="hljs-type">ngx_pool_data_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_pool_s</span> &#123;</span><br>    <span class="hljs-type">ngx_pool_data_t</span>       d;        <span class="hljs-comment">// 内存池的数据块，包括可分配内存的起始位置、结束位置和下一个内存池的指针等信息</span><br>    <span class="hljs-type">size_t</span>                max;      <span class="hljs-comment">// 内存池数据块的最大值</span><br>    <span class="hljs-type">ngx_pool_t</span>           *current;  <span class="hljs-comment">// 指向当前内存池的指针</span><br>    <span class="hljs-type">ngx_chain_t</span>          *chain;    <span class="hljs-comment">// 指向一个数据链表的指针</span><br>    <span class="hljs-type">ngx_pool_large_t</span>     *large;    <span class="hljs-comment">// 指向一个大块内存链表的指针</span><br>    <span class="hljs-type">ngx_pool_cleanup_t</span>   *cleanup;  <span class="hljs-comment">// 指向内存池清理结构体的指针，用于执行内存清理操作</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_fd_t</span>              fd;       <span class="hljs-comment">// 文件描述符</span><br>    u_char               *name;     <span class="hljs-comment">// 文件名</span><br>    <span class="hljs-type">ngx_log_t</span>            *<span class="hljs-built_in">log</span>;      <span class="hljs-comment">// 内存分配相关的日志信息</span><br>&#125; <span class="hljs-type">ngx_pool_cleanup_file_t</span>;<br><br></code></pre></td></tr></table></figure><p>内存池各组件结构之间的关系：</p><p><img src="https://s2.loli.net/2024/05/25/wdyTRUqcJVDAibK.webp" alt="nginx内存池">其中这里的ngx_pool_cleanup_pt是一个比较好的设计，通过定义这种类型的函数指针，可以将不同的清理函数关联到内存池中，以便在内存池销毁时调用。比如说：处理内存池销毁时需要执行的清理任务。例如，关闭打开的文件，释放分配的资源等。</p><p>关于内存池相关的函数，可能以后会具体开一章讲解。这里先附上执行流程图</p><p><img src="https://s2.loli.net/2024/05/25/V9XjNOhx6avRmez.webp" alt="nginx内存池函数流程"></p><p>这里说一个在内存池设计中，常见的方法：以特定对齐方式分配内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//调用 posix_memalign 函数，该函数会尝试以特定的对齐方式 alignment 分配指定大小 size 的内存块，并将分配的内存地址存储在 p 中。</span><br>posix_memalign(&amp;p, alignment, size)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/qtUulxvAwfbhRz2.webp" alt="内存对齐"></p><blockquote><p>在内存中我们一般读取数据不是按内存来读取，一般都是按内存块来读取。</p><p>未对齐的情况下，当需要访问int类型的数据时，需要CPU访问2次内存块（内存块1和内存块2）</p><p>对齐的情况下，当访问int类型的数据时，只需要CPU访问1次内存块（内存块2）即可</p><p>是一种空间换时间的做法 </p></blockquote><h3 id="缓冲区数据类型ngx-buf-s"><a href="#缓冲区数据类型ngx-buf-s" class="headerlink" title="缓冲区数据类型ngx_buf_s"></a>缓冲区数据类型ngx_buf_s</h3><p><img src="https://s2.loli.net/2024/05/25/x5qdZ1vDyGVt37J.png" alt="nginx缓冲区"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *            <span class="hljs-type">ngx_buf_tag_t</span>;  <span class="hljs-comment">// 缓冲区标签类型，用于标识缓冲区的特定类型</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span>  <span class="hljs-title">ngx_buf_t</span>;</span>  <span class="hljs-comment">// Nginx 缓冲区结构体</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_buf_s</span> &#123;</span><br>    u_char          *pos;            <span class="hljs-comment">// 缓冲区数据在内存的起始位置</span><br>    u_char          *last;           <span class="hljs-comment">// 缓冲区数据在内存的结束位置</span><br>    <span class="hljs-type">off_t</span>            file_pos;       <span class="hljs-comment">// 文件读取偏移量</span><br>    <span class="hljs-type">off_t</span>            file_last;      <span class="hljs-comment">// 文件读取结束位置</span><br><br>    u_char          *start;          <span class="hljs-comment">/* 缓冲区的起始地址 */</span><br>    u_char          *end;            <span class="hljs-comment">/* 缓冲区的结束地址 */</span><br>    <span class="hljs-type">ngx_buf_tag_t</span>    tag;            <span class="hljs-comment">// 缓冲区的标签</span><br>    <span class="hljs-type">ngx_file_t</span>      *file;           <span class="hljs-comment">// 缓冲区关联的文件对象</span><br>    <span class="hljs-type">ngx_buf_t</span>       *shadow;         <span class="hljs-comment">// 当前缓冲区的影子缓冲区</span><br>    <span class="hljs-type">unsigned</span>         temporary:<span class="hljs-number">1</span>;    <span class="hljs-comment">// 缓冲区数据可以被修改的标志</span><br>    <span class="hljs-type">unsigned</span>         memory:<span class="hljs-number">1</span>;       <span class="hljs-comment">// 缓冲区数据在内存中的标志，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         mmap:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区数据是通过 mmap 映射的，且不可修改</span><br>    <span class="hljs-type">unsigned</span>         recycled:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否已经被回收</span><br>    <span class="hljs-type">unsigned</span>         in_file:<span class="hljs-number">1</span>;      <span class="hljs-comment">// 缓冲区的数据是否在文件中</span><br>    <span class="hljs-type">unsigned</span>         flush:<span class="hljs-number">1</span>;        <span class="hljs-comment">// 缓冲区是否需要刷新</span><br>    <span class="hljs-type">unsigned</span>         sync:<span class="hljs-number">1</span>;         <span class="hljs-comment">// 缓冲区是否需要同步</span><br>    <span class="hljs-type">unsigned</span>         last_buf:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否为最后一个缓冲区</span><br>    <span class="hljs-type">unsigned</span>         last_in_chain:<span class="hljs-number">1</span>; <span class="hljs-comment">// 缓冲区是否是链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         last_shadow:<span class="hljs-number">1</span>;   <span class="hljs-comment">// 缓冲区是否是影子缓冲区链表中的最后一个</span><br>    <span class="hljs-type">unsigned</span>         temp_file:<span class="hljs-number">1</span>;     <span class="hljs-comment">// 缓冲区是否是临时文件</span><br>    <span class="hljs-comment">/* STUB */</span> <span class="hljs-type">int</span>   num;             <span class="hljs-comment">// 缓冲区编号（占位符）</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;               <span class="hljs-comment">// 缓冲区指针</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next;              <span class="hljs-comment">// 下一个链表节点指针</span><br>&#125; <span class="hljs-type">ngx_chain_t</span>;                        <span class="hljs-comment">// Nginx 链表节点结构体</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_int_t</span>    num;                <span class="hljs-comment">// 缓冲区数量</span><br>    <span class="hljs-type">size_t</span>       size;               <span class="hljs-comment">// 缓冲区大小</span><br>&#125; <span class="hljs-type">ngx_bufs_t</span>;                        <span class="hljs-comment">// 缓冲区参数结构体</span><br><br></code></pre></td></tr></table></figure><p>其中，ngx_chain_t 数据类型是与缓冲区类型 ngx_buf_t 相关的链表结构，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_chain_s</span> &#123;</span><br>    <span class="hljs-type">ngx_buf_t</span>    *buf;  <span class="hljs-comment">/* 指向当前缓冲区 */</span><br>    <span class="hljs-type">ngx_chain_t</span>  *next; <span class="hljs-comment">/* 指向下一个chain，形成chain链表 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/xl8P7vMTdfLkWJO.png" alt="chain链表"></p><h3 id="动态数组数据结构ngx-array-t"><a href="#动态数组数据结构ngx-array-t" class="headerlink" title="动态数组数据结构ngx_array_t"></a>动态数组数据结构ngx_array_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>        *elts;  <span class="hljs-comment">/* 指向数组数据区域的首地址 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nelts; <span class="hljs-comment">/* 数组实际数据的个数 */</span><br>    <span class="hljs-type">size_t</span>       size;  <span class="hljs-comment">/* 单个元素所占据的字节大小 */</span><br>    <span class="hljs-type">ngx_uint_t</span>   nalloc;<span class="hljs-comment">/* 数组容量 */</span><br>    <span class="hljs-type">ngx_pool_t</span>  *pool;  <span class="hljs-comment">/* 数组对象所在的内存池 */</span><br>&#125; <span class="hljs-type">ngx_array_t</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/A1FD3mMUQvSaGCi.png" alt="动态数组"></p><p>整个动态数组的创建，使用，销毁过程中都是基于上文的内存池数据类型进行的。</p><h4 id="设计优点-1"><a href="#设计优点-1" class="headerlink" title="设计优点"></a>设计优点</h4><p>1，<strong>动态扩容</strong></p><ul><li><code>ngx_array_t</code> 是动态分配内存的，它的大小可以根据需要自动增长，而普通的数组在定义时就需要确定大小，无法动态改变大小。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">ngx_array_push(<span class="hljs-type">ngx_array_t</span> *a)<br>&#123;<br>    <span class="hljs-type">void</span>        *elt, *new;<br>    <span class="hljs-type">size_t</span>       size;<br>    <span class="hljs-type">ngx_pool_t</span>  *p;<br>    <br>    <span class="hljs-comment">//函数会检查数组是否已满（即已存储的元素个数 nelts 是否等于数组的容量 nalloc）。如果数组已满，则需要进行扩容操作：</span><br>    <span class="hljs-keyword">if</span> (a-&gt;nelts == a-&gt;nalloc) &#123;<br><br>        <span class="hljs-comment">//计算当前数组的总大小（size = a-&gt;size * a-&gt;nalloc）</span><br>        size = a-&gt;size * a-&gt;nalloc;<br><br>        p = a-&gt;pool;<br>        <br>        <span class="hljs-comment">//检查内存池是否有足够的空间用于扩容，如果内存池的末尾可以容纳新的数组分配，并且内存池的末尾加上新的数组分配大小不会超出内存池的结束位置，则在内存池的末尾直接分配新的数组空间。</span><br>        <span class="hljs-keyword">if</span> ((u_char *) a-&gt;elts + size == p-&gt;d.last<br>            &amp;&amp; p-&gt;d.last + a-&gt;size &lt;= p-&gt;d.end)<br>        &#123;<br>            p-&gt;d.last += a-&gt;size;<br>            a-&gt;nalloc++;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果内存池无法容纳新的数组分配，则需要重新分配一个新的数组空间，大小是当前数组大小的两倍，并将原数组数据复制到新数组中。</span><br>            new = ngx_palloc(p, <span class="hljs-number">2</span> * size);<br>            <span class="hljs-keyword">if</span> (new == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            ngx_memcpy(new, a-&gt;elts, size);<br>            a-&gt;elts = new;<br>            a-&gt;nalloc *= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//最后，将新元素添加到数组末尾，并更新已存储的元素个数 nelts。</span><br>    elt = (u_char *) a-&gt;elts + a-&gt;size * a-&gt;nelts;<br>    a-&gt;nelts++;<br><br>    <span class="hljs-keyword">return</span> elt;<br>&#125;<br></code></pre></td></tr></table></figure><p>2，<strong>内存管理</strong></p><ul><li><code>ngx_array_t</code> 使用内存池进行内存分配，而不是直接调用系统的 <code>malloc()</code> 函数，这样可以减少内存碎片的产生，提高内存管理的效率。可以在内存池的生命周期内进行动态的内存分配和释放，而普通的数组需要手动管理内存的分配和释放。</li></ul><p>3，<strong>数组元数据</strong></p><ul><li><code>ngx_array_t</code> 中的 <code>nelts</code> 表示当前数组中实际存储的元素个数，<code>nalloc</code> 表示数组的容量（即分配的内存空间可以容纳的元素个数），通过这两个值可以确定数组的使用情况，从而进行动态的内存管理。</li></ul><h4 id="扩展视野"><a href="#扩展视野" class="headerlink" title="扩展视野"></a>扩展视野</h4><p>类似的自动扩容设计在redis上的动态字符串(sds)也有出现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sdshdr</span> &#123;</span><br>    <span class="hljs-comment">//记录buf数组中已使用字节的数量</span><br>    <span class="hljs-comment">//等于SDS所保存字符串的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-comment">//记录buf数组中未使用字节的数量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">free</span>;<br><br>    <span class="hljs-comment">//char数组，用于保存字符串</span><br>    <span class="hljs-type">char</span> buf[];<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2024/05/25/F7UquTgPlARjeX5.png" alt="sds"></p><p>自动扩容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c">sds _sdsMakeRoomFor(sds s, <span class="hljs-type">size_t</span> addlen, <span class="hljs-type">int</span> greedy) &#123;<br>    <span class="hljs-type">void</span> *sh, *newsh; <span class="hljs-comment">// 分别为原始字符串头部和新字符串头部的指针</span><br>    <span class="hljs-type">size_t</span> avail = sdsavail(s); <span class="hljs-comment">// 可用空间大小</span><br>    <span class="hljs-type">size_t</span> len, newlen, reqlen; <span class="hljs-comment">// 分别为字符串当前长度、新长度、所需长度</span><br>    <span class="hljs-type">char</span> type, oldtype = s[<span class="hljs-number">-1</span>] &amp; SDS_TYPE_MASK; <span class="hljs-comment">// 分别为新类型和旧类型</span><br>    <span class="hljs-type">int</span> hdrlen; <span class="hljs-comment">// 头部长度</span><br>    <span class="hljs-type">size_t</span> usable; <span class="hljs-comment">// 实际可用空间大小</span><br><br>    <span class="hljs-comment">/* Return ASAP if there is enough space left. */</span><br>    <span class="hljs-keyword">if</span> (avail &gt;= addlen) <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 如果可用空间大于等于所需空间，则直接返回原字符串</span><br><br>    len = sdslen(s); <span class="hljs-comment">// 获取当前字符串长度</span><br>    sh = (<span class="hljs-type">char</span>*)s-sdsHdrSize(oldtype); <span class="hljs-comment">// 计算原字符串头部位置</span><br>    reqlen = newlen = (len+addlen); <span class="hljs-comment">// 计算所需长度为当前长度加上新增长度</span><br>    assert(newlen &gt; len);   <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (greedy == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC) <span class="hljs-comment">// 如果新长度小于最大预分配长度，则将新长度翻倍</span><br>            newlen *= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span><br>            newlen += SDS_MAX_PREALLOC; <span class="hljs-comment">// 否则直接增加最大预分配长度</span><br>    &#125;<br><br>    type = sdsReqType(newlen); <span class="hljs-comment">// 获取新类型</span><br><br>    <span class="hljs-comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span><br><span class="hljs-comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span><br><span class="hljs-comment">     * at every appending operation. */</span><br>    <span class="hljs-keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8; <span class="hljs-comment">// 如果新类型为 5，则改为 8，因为 5 类型无法记录空闲空间</span><br><br>    hdrlen = sdsHdrSize(type); <span class="hljs-comment">// 计算新头部长度</span><br>    assert(hdrlen + newlen + <span class="hljs-number">1</span> &gt; reqlen);  <span class="hljs-comment">/* Catch size_t overflow */</span> <span class="hljs-comment">// 检查 size_t 溢出</span><br><br>    <span class="hljs-keyword">if</span> (oldtype==type) &#123; <span class="hljs-comment">// 如果新旧类型相同</span><br>        newsh = s_realloc_usable(sh, hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 重新分配空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* Since the header size changes, need to move the string forward,</span><br><span class="hljs-comment">         * and can&#x27;t use realloc */</span><br>        newsh = s_malloc_usable(hdrlen+newlen+<span class="hljs-number">1</span>, &amp;usable); <span class="hljs-comment">// 分配新空间</span><br>        <span class="hljs-keyword">if</span> (newsh == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分配失败则返回空指针</span><br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">char</span>*)newsh+hdrlen, s, len+<span class="hljs-number">1</span>); <span class="hljs-comment">// 将原字符串拷贝到新空间</span><br>        s_free(sh); <span class="hljs-comment">// 释放原空间</span><br>        s = (<span class="hljs-type">char</span>*)newsh+hdrlen; <span class="hljs-comment">// 更新字符串指针位置</span><br>        s[<span class="hljs-number">-1</span>] = type; <span class="hljs-comment">// 更新新类型</span><br>        sdssetlen(s, len); <span class="hljs-comment">// 更新字符串长度</span><br>    &#125;<br>    usable = usable-hdrlen<span class="hljs-number">-1</span>; <span class="hljs-comment">// 计算实际可用空间</span><br>    <span class="hljs-keyword">if</span> (usable &gt; sdsTypeMaxSize(type)) <span class="hljs-comment">// 如果实际可用空间大于类型最大限制，则设置为类型最大限制</span><br>        usable = sdsTypeMaxSize(type);<br>    sdssetalloc(s, usable); <span class="hljs-comment">// 设置字符串实际分配空间大小</span><br>    <span class="hljs-keyword">return</span> s; <span class="hljs-comment">// 返回更新后的字符串</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="链表数据结构-ngx-list-t"><a href="#链表数据结构-ngx-list-t" class="headerlink" title="链表数据结构 ngx_list_t"></a>链表数据结构 ngx_list_t</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_list_part_s，并将其别名定义为 ngx_list_part_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span>  <span class="hljs-title">ngx_list_part_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_list_part_s。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_list_part_s</span> &#123;</span><br>    <span class="hljs-type">void</span>             *elts;   <span class="hljs-comment">// 指向元素的指针，每个元素的类型未指定。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nelts;  <span class="hljs-comment">// 当前存储的元素个数。</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *next;   <span class="hljs-comment">// 指向下一个链表部分的指针。</span><br>&#125;;<br><br><span class="hljs-comment">// 定义一个链表结构 ngx_list_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_list_part_t</span>  *last;    <span class="hljs-comment">// 指向链表的最后一个部分的指针。</span><br>    <span class="hljs-type">ngx_list_part_t</span>   part;    <span class="hljs-comment">// 链表的第一个部分，包含元素和指向下一个部分的指针。</span><br>    <span class="hljs-type">size_t</span>            size;    <span class="hljs-comment">// 每个元素的大小。</span><br>    <span class="hljs-type">ngx_uint_t</span>        nalloc;  <span class="hljs-comment">// 每个部分可以存储的元素个数。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;    <span class="hljs-comment">// 指向内存池的指针，用于分配链表部分的内存。</span><br>&#125; <span class="hljs-type">ngx_list_t</span>;<br></code></pre></td></tr></table></figure><p>链表数据结构如下图所示：</p><p><img src="https://s2.loli.net/2024/05/25/ADgYxOuqIMfl2nJ.png" alt="nginx链表"></p><p>链表主要函数:</p><p><img src="https://s2.loli.net/2024/05/25/ZbEYmN4V7nW9cJH.png" alt="image-20240524181000980"></p><p>需要注意的是：由于链表的内存分配是基于内存池，所有内存的销毁由内存池进行，即链表没有销毁操作。</p><p>其中主要是的内存分配函数就是*<em>ngx_palloc(ngx_pool_t <em>pool, size_t size)</em></em></p><h4 id="基础巩固-2"><a href="#基础巩固-2" class="headerlink" title="基础巩固"></a><strong>基础巩固</strong></h4><h5 id="什么是static？"><a href="#什么是static？" class="headerlink" title="什么是static？"></a>什么是static？</h5><h4 id="1-static-变量"><a href="#1-static-变量" class="headerlink" title="1.  static 变量"></a>1.  static 变量</h4><ul><li><p><strong>在函数内</strong>：</p><ul><li>当 <code>static</code> 变量在函数内部声明时，它是一个局部变量，但与普通局部变量不同的是，它的生命周期是整个程序运行期间。它只在第一次执行到声明语句时初始化，以后即使函数多次调用也不会重新初始化，并且其值在函数调用之间保持不变。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只在第一次调用时初始化</span><br>    count++;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, count);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>在文件作用域内</strong>：</p><ul><li>当 <code>static</code> 变量在文件的顶层（即不在任何函数内）声明时，它的作用域仅限于该文件。它不能被其他文件访问，即使在其他文件中有相同名字的变量也不会冲突。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> global_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只能在该文件中访问</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-static-函数"><a href="#2-static-函数" class="headerlink" title="2. static 函数"></a>2. <code>static</code> 函数</h4><ul><li><p>在文件作用域内：</p><ul><li>当 <code>static</code> 函数在文件中定义时，它的作用域也仅限于该文件。其他文件不能调用这个函数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">helper_function</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 只能在该文件中调用</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="什么是inline"><a href="#什么是inline" class="headerlink" title="什么是inline?"></a>什么是inline?</h5><h4 id="1-inline-函数"><a href="#1-inline-函数" class="headerlink" title="1. inline 函数"></a>1. <code>inline</code> 函数</h4><ul><li><p>在函数声明前使用 <code>inline</code>：</p><ul><li><code>inline</code> 关键字用于建议编译器在调用函数时将函数体内联展开，而不是进行正常的函数调用。这样可以减少函数调用的开销，尤其是在小函数和频繁调用的情况下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>需要注意的是，<code>inline</code> 只是一个建议，编译器可能会忽略它，特别是当函数体太大或者包含复杂的逻辑时。</li></ul></li></ul><h4 id="2-inline-和多重定义"><a href="#2-inline-和多重定义" class="headerlink" title="2. inline 和多重定义"></a>2. <code>inline</code> 和多重定义</h4><ul><li><p>在头文件中定义 <code>inline</code> 函数：</p><ul><li>当 <code>inline</code> 函数在头文件中定义并在多个源文件中包含时，通常不会导致重复定义错误，因为每个源文件的 <code>inline</code> 函数都被认为是独立的。编译器会处理这种情况以避免链接错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// header.h</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="队列链表结构ngx-queue-t"><a href="#队列链表结构ngx-queue-t" class="headerlink" title="队列链表结构ngx_queue_t"></a>队列链表结构ngx_queue_t</h3><p><img src="https://s2.loli.net/2024/05/25/jXQoYbiV8NpS7s1.png" alt="队列链表"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义一个结构体类型 ngx_queue_s，并将其别名定义为 ngx_queue_t。</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span>  <span class="hljs-title">ngx_queue_t</span>;</span><br><br><span class="hljs-comment">// 定义结构体 ngx_queue_s，用于实现双向循环链表。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_queue_s</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span>  *prev; <span class="hljs-comment">// 指向前一个队列节点的指针</span><br>    <span class="hljs-type">ngx_queue_t</span>  *next; <span class="hljs-comment">// 指向下一个队列节点的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过观察ngx_queue_s结构体可以看出与我们普通的双向链表的区别在于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 定义双向链表节点结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">prev</span>;</span>  <span class="hljs-comment">// 指向前一个节点的指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一个节点的指针</span><br>&#125; Node;<br></code></pre></td></tr></table></figure><p>1.这里的双向链表中的节点是没有数据区的，只有两个指向节点的指针</p><p>2.同样队列链表时选择不使用内存池管理</p><p>个人认为这样的设计主要从这几各方面考虑：</p><ol><li><strong>节省内存</strong>：在某些情况下，队列节点本身并不需要携带数据，而只需包含指向数据的指针。如果每个节点都分配一定大小的数据区域，将会造成内存浪费。通过不为节点分配数据区域，可以节省内存，并使得队列更加轻量级。</li><li><strong>减少数据拷贝</strong>：通过在节点中存储指向数据的指针，而不是存储数据本身，可以减少数据在内存中的拷贝次数。这对于处理大量数据或频繁操作数据的场景下，能够提高性能和效率。</li><li><strong>灵活性</strong>：将数据存储在节点外部，允许队列节点更通用。这样设计使得节点可以存储不同类型的数据，从而提高了队列的灵活性。这样的设计适用于 Nginx 中很多情况下需要处理各种类型数据的场景。</li><li>内存池适用于大量的、相对固定大小的对象分配，例如 HTTP 请求和响应的内存管理。但对于一些特殊的数据结构，如队列链表，其大小不固定，每个节点的内存消耗可能不同，因此直接使用内存池可能不够灵活。</li></ol><p>当然，在使用时这种节点通常与实际数据结构结合使用，通过嵌入 <code>ngx_queue_t</code> 结构体来实现链表操作。例如，一个实际的数据结构可能如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_queue_t</span> <span class="hljs-built_in">queue</span>; <span class="hljs-comment">// 嵌入 ngx_queue_t 用于链表操作</span><br>    <span class="hljs-type">int</span> data;          <span class="hljs-comment">// 实际数据</span><br>&#125; <span class="hljs-type">my_data_t</span>;<br><br></code></pre></td></tr></table></figure><h3 id="哈希表结构ngx-hash-t"><a href="#哈希表结构ngx-hash-t" class="headerlink" title="哈希表结构ngx_hash_t"></a>哈希表结构ngx_hash_t</h3><h4 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表?"></a>什么是哈希表?</h4><p>哈希表（Hash Table）是一种用于实现关联数组（键值对存储）的数据结构。它利用哈希函数将键映射到表中的位置，从而实现快速的数据存取。哈希表支持高效的插入、删除和查找操作，通常时间复杂度为O(1)。</p><p><strong>哈希表的基本概念</strong></p><ol><li><strong>键（Key）和值（Value）</strong>：哈希表通过键来存储和检索相应的值。</li><li><strong>哈希函数（Hash Function）</strong>：将键转换为哈希值（通常是一个整数），然后用这个哈希值确定在表中的位置。</li><li><strong>哈希冲突（Hash Collision）</strong>：不同的键可能会映射到同一个位置，这种情况称为冲突。哈希表需要处理冲突以确保每个键值对都能被正确存储和访问。</li></ol><p><strong>哈希表的结构</strong></p><p>哈希表通常由一个数组和一个哈希函数组成。数组的每个位置称为一个桶（bucket）。</p><p><strong>哈希冲突解决方法</strong></p><ol><li><strong>链地址法（Chaining）</strong>：每个桶中存储一个链表，所有映射到同一桶的元素都放入这个链表中。</li><li><strong>开放地址法（Open Addressing）</strong>：当冲突发生时，寻找下一个空桶来存储元素。常见的探查方式包括线性探查、二次探查和双重哈希。</li></ol><p><img src="https://s2.loli.net/2024/05/25/6STaUCZkpLjY1IR.png" alt="hashtab"></p><p>接着我们来看nginx是如何设计哈希表的。</p><p><img src="https://s2.loli.net/2024/05/25/ezxEjR6AU8utkWT.jpg" alt="img"></p><p>可以看出nginx的哈希表是由三层结构组成而来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在哈希表中的值，可以是任何类型。</span><br>    u_short           len;       <span class="hljs-comment">// name字段的长度。</span><br>    u_char            name[<span class="hljs-number">1</span>];   <span class="hljs-comment">// 键的第一个字符，后续的字符在分配时动态决定，这是一个灵活数组成员。</span><br>&#125; <span class="hljs-type">ngx_hash_elt_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_elt_t</span>  **buckets;   <span class="hljs-comment">// 指向哈希表桶数组的指针，每个桶是一个链表的头节点。</span><br>    <span class="hljs-type">ngx_uint_t</span>        size;      <span class="hljs-comment">// 哈希表中桶的数量。</span><br>&#125; <span class="hljs-type">ngx_hash_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>        hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 指向存储在通配符哈希表中的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_wildcard_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_str_t</span>         key;       <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_uint_t</span>        key_hash;  <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">void</span>             *value;     <span class="hljs-comment">// 与键关联的值，可以是任何类型。</span><br>&#125; <span class="hljs-type">ngx_hash_key_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">ngx_uint_t</span> <span class="hljs-params">(*ngx_hash_key_pt)</span> <span class="hljs-params">(u_char *data, <span class="hljs-type">size_t</span> len)</span>;  <span class="hljs-comment">// 函数指针类型，指向一个哈希函数，该函数接受一个字符数组（键）和其长度作为参数，返回一个无符号整数类型的哈希值。</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>            hash;      <span class="hljs-comment">// 嵌入的ngx_hash_t结构，用于存储哈希表。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_head;   <span class="hljs-comment">// 指向通配符哈希表的头部。</span><br>    <span class="hljs-type">ngx_hash_wildcard_t</span>  *wc_tail;   <span class="hljs-comment">// 指向通配符哈希表的尾部。</span><br>&#125; <span class="hljs-type">ngx_hash_combined_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_hash_t</span>       *hash;         <span class="hljs-comment">// 指向一个ngx_hash_t结构的指针，用于存储初始化后的哈希表。</span><br>    ngx_hash_key_pt   key;          <span class="hljs-comment">// 指向一个哈希函数的指针，用于计算键的哈希值。</span><br><br>    <span class="hljs-type">ngx_uint_t</span>        max_size;     <span class="hljs-comment">// 哈希表允许的最大键数量。</span><br>    <span class="hljs-type">ngx_uint_t</span>        bucket_size;  <span class="hljs-comment">// 每个桶的大小。</span><br><br>    <span class="hljs-type">char</span>             *name;         <span class="hljs-comment">// 哈希表的名称，用于调试或日志记录。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;         <span class="hljs-comment">// 指向一个内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;    <span class="hljs-comment">// 指向一个临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br>&#125; <span class="hljs-type">ngx_hash_init_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hsize;              <span class="hljs-comment">// 哈希表的大小，即桶的数量。</span><br><br>    <span class="hljs-type">ngx_pool_t</span>       *pool;               <span class="hljs-comment">// 内存池，用于分配哈希表所需的内存。</span><br>    <span class="hljs-type">ngx_pool_t</span>       *temp_pool;          <span class="hljs-comment">// 临时内存池，用于在哈希表初始化过程中分配临时内存。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       keys;               <span class="hljs-comment">// 存储普通键的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *keys_hash;          <span class="hljs-comment">// 指向哈希表中的普通键数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_head;        <span class="hljs-comment">// 存储DNS通配符键（头部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_head_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（头部）数组。</span><br><br>    <span class="hljs-type">ngx_array_t</span>       dns_wc_tail;        <span class="hljs-comment">// 存储DNS通配符键（尾部）的数组。</span><br>    <span class="hljs-type">ngx_array_t</span>      *dns_wc_tail_hash;   <span class="hljs-comment">// 指向哈希表中的DNS通配符键（尾部）数组。</span><br>&#125; <span class="hljs-type">ngx_hash_keys_arrays_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span>  <span class="hljs-title">ngx_table_elt_t</span>;</span>  <span class="hljs-comment">// 前向声明结构类型ngx_table_elt_t。</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_table_elt_s</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>        hash;           <span class="hljs-comment">// 键的哈希值。</span><br>    <span class="hljs-type">ngx_str_t</span>         key;            <span class="hljs-comment">// 键，字符串类型。</span><br>    <span class="hljs-type">ngx_str_t</span>         value;          <span class="hljs-comment">// 与键关联的值，字符串类型。</span><br>    u_char           *lowcase_key;    <span class="hljs-comment">// 存储小写形式的键，用于不区分大小写的查找。</span><br>    <span class="hljs-type">ngx_table_elt_t</span>  *next;           <span class="hljs-comment">// 指向下一个元素的指针，形成链表，用于处理哈希冲突。</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：Nginx 的哈希表设计主要是为了高效地存储和查找键值对。</p><h4 id="初始化操作"><a href="#初始化操作" class="headerlink" title="初始化操作:"></a>初始化操作:</h4><p>hash 初始化由 ngx_hash_init() 函数完成，其 names 参数是 ngx_hash_key_t 结构的数组，即键-值对 &lt;key,value&gt; 数组，nelts 表示该数组元素的个数。该函数初始化的结果就是将 names 数组保存的键-值对&lt;key,value&gt;，通过 hash 的方式将其存入相应的一个或多个 hash 桶(即代码中的 buckets )中。hash 桶里面存放的是 ngx_hash_elt_t 结构的指针(hash元素指针)，该指针指向一个基本连续的数据区。该数据区中存放的是经 hash 之后的键-值对&lt;key’,value’&gt;，即 ngx_hash_elt_t 结构中的字段 &lt;name,value&gt;。每一个这样的数据区存放的键-值对&lt;key’,value’&gt;可以是一个或多个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NGX_HASH_ELT_SIZE(name)                                               \</span><br><span class="hljs-meta">    (sizeof(void *) + ngx_align((name)-&gt;key.len + 2, sizeof(void *)))</span><br><br><span class="hljs-comment">/* 初始化hash结构函数 */</span><br><span class="hljs-comment">/* 参数hinit是hash表初始化结构指针；</span><br><span class="hljs-comment"> * name是指向待添加在hash表结构的元素数组；</span><br><span class="hljs-comment"> * nelts是待添加元素数组中元素的个数；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_hash_init</span><span class="hljs-params">(<span class="hljs-type">ngx_hash_init_t</span> *hinit, <span class="hljs-type">ngx_hash_key_t</span> *names, <span class="hljs-type">ngx_uint_t</span> nelts)</span><br>&#123;<br>    u_char          *elts;<br>    <span class="hljs-type">size_t</span>           len;<br>    u_short         *test;<br>    <span class="hljs-type">ngx_uint_t</span>       i, n, key, size, start, bucket_size;<br>    <span class="hljs-type">ngx_hash_elt_t</span>  *elt, **buckets;<br><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-comment">/* 若每个桶bucket的内存空间不足以存储一个关键字元素，则出错返回</span><br><span class="hljs-comment">         * 这里考虑到了每个bucket桶最后的null指针所需的空间，即该语句中的sizeof(void *)，</span><br><span class="hljs-comment">         * 该指针可作为查找过程中的结束标记</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (hinit-&gt;bucket_size &lt; NGX_HASH_ELT_SIZE(&amp;names[n]) + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *))<br>        &#123;<br>            ngx_log_error(NGX_LOG_EMERG, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;could not build the %s, you should &quot;</span><br>                          <span class="hljs-string">&quot;increase %s_bucket_size: %i&quot;</span>,<br>                          hinit-&gt;name, hinit-&gt;name, hinit-&gt;bucket_size);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 临时分配sizeof(u_short)*max_size的test空间，即test数组总共有max_size个元素，即最大bucket的数量，</span><br><span class="hljs-comment">     * 每个元素会累计落到相应hash表位置的关键字长度，</span><br><span class="hljs-comment">     * 当大于256字节，即u_short所表示的字节大小，</span><br><span class="hljs-comment">     * 则表示bucket较少</span><br><span class="hljs-comment">     */</span><br>    test = ngx_alloc(hinit-&gt;max_size * <span class="hljs-keyword">sizeof</span>(u_short), hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>);<br>    <span class="hljs-keyword">if</span> (test == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">/* 每个bucket桶实际容纳的数据大小，</span><br><span class="hljs-comment">     * 由于每个bucket的末尾结束标志是null，</span><br><span class="hljs-comment">     * 所以bucket实际容纳的数据大小必须减去一个指针所占的内存大小</span><br><span class="hljs-comment">     */</span><br>    bucket_size = hinit-&gt;bucket_size - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br><br>    <span class="hljs-comment">/* 估计hash表最少bucket数量；</span><br><span class="hljs-comment">     * 每个关键字元素需要的内存空间是 NGX_HASH_ELT_SIZE(&amp;name[n])，至少需要占用两个指针的大小即2*sizeof(void *)</span><br><span class="hljs-comment">     * 这样来估计hash表所需的最小bucket数量</span><br><span class="hljs-comment">     * 因为关键字元素内存越小，则每个bucket所容纳的关键字元素就越多</span><br><span class="hljs-comment">     * 那么hash表的bucket所需的数量就越少，但至少需要一个bucket</span><br><span class="hljs-comment">     */</span><br>    start = nelts / (bucket_size / (<span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)));<br>    start = start ? start : <span class="hljs-number">1</span>;<br><br>    <br>    <span class="hljs-keyword">if</span> (hinit-&gt;max_size &gt; <span class="hljs-number">10000</span> &amp;&amp; nelts &amp;&amp; hinit-&gt;max_size / nelts &lt; <span class="hljs-number">100</span>) &#123;<br>        start = hinit-&gt;max_size - <span class="hljs-number">1000</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 以前面估算的最小bucket数量start，通过测试数组test估算hash表容纳 nelts个关键字元素所需的bucket数量</span><br><span class="hljs-comment">     * 根据需求适当扩充bucket的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (size = start; size &lt;= hinit-&gt;max_size; size++) &#123;<br><br>        ngx_memzero(test, size * <span class="hljs-keyword">sizeof</span>(u_short));<br><br>        <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>            <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/* 根据关键字元素的hash值计算存在到测试数组test对应的位置中，即计算bucket在hash表中的编号key,key取值为0～size-1 */</span><br>            key = names[n].key_hash % size;<br>            test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %ui %ui \&quot;%V\&quot;&quot;</span>,<br>                          size, key, test[key], &amp;names[n].key);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>            <span class="hljs-comment">/* test数组中对应的内存大于每个桶bucket最大内存，则需扩充bucket的数量</span><br><span class="hljs-comment">             * 即在start的基础上继续增加size的值</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (test[key] &gt; (u_short) bucket_size) &#123;<br>                <span class="hljs-keyword">goto</span> next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/* 若size个bucket桶可以容纳name数组的所有关键字元素，则表示找到合适的bucket数量大小即为size */</span><br>        <span class="hljs-keyword">goto</span> found;<br><br>    next:<br><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    ngx_log_error(NGX_LOG_WARN, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                  <span class="hljs-string">&quot;could not build optimal %s, you should increase &quot;</span><br>                  <span class="hljs-string">&quot;either %s_max_size: %i or %s_bucket_size: %i; &quot;</span><br>                  <span class="hljs-string">&quot;ignoring %s_bucket_size&quot;</span>,<br>                  hinit-&gt;name, hinit-&gt;name, hinit-&gt;max_size,<br>                  hinit-&gt;name, hinit-&gt;bucket_size, hinit-&gt;name);<br><br>found:<br><br>    <span class="hljs-comment">/* 到此已经找到合适的bucket数量，即为size</span><br><span class="hljs-comment">     * 重新初始化test数组元素，初始值为一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *);<br>    &#125;<br><br>    <span class="hljs-comment">/* 计算每个bucket中关键字所占的空间，即每个bucket实际所容纳数据的大小，</span><br><span class="hljs-comment">     * 必须注意的是：test[i]中还有一个指针大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* 根据hash值计算出关键字放在对应的test[key]中，即test[key]的大小增加一个关键字元素的大小 */</span><br>        key = names[n].key_hash % size;<br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* 调整成对齐到cacheline的大小，并记录所有元素的总长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        test[i] = (u_short) (ngx_align(test[i], ngx_cacheline_size));<br><br>        len += test[i];<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 向内存池申请bucket元素所占的内存空间，</span><br><span class="hljs-comment">     * 注意：若前面没有申请hash表头结构，则在这里将和ngx_hash_wildcard_t一起申请</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>        hinit-&gt;hash = ngx_pcalloc(hinit-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>)<br>                                             + size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (hinit-&gt;hash == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">/* 计算buckets的起始位置 */</span><br>        buckets = (<span class="hljs-type">ngx_hash_elt_t</span> **)<br>                      ((u_char *) hinit-&gt;hash + <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_wildcard_t</span>));<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        buckets = ngx_pcalloc(hinit-&gt;pool, size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_hash_elt_t</span> *));<br>        <span class="hljs-keyword">if</span> (buckets == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_free(test);<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 分配elts，对齐到cacheline大小 */</span><br>    elts = ngx_palloc(hinit-&gt;pool, len + ngx_cacheline_size);<br>    <span class="hljs-keyword">if</span> (elts == <span class="hljs-literal">NULL</span>) &#123;<br>        ngx_free(test);<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    elts = ngx_align_ptr(elts, ngx_cacheline_size);<br><br>    <span class="hljs-comment">/* 将buckets数组与相应的elts对应起来，即设置每个bucket对应实际数据的地址 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (test[i] == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        buckets[i] = (<span class="hljs-type">ngx_hash_elt_t</span> *) elts;<br>        elts += test[i];<br><br>    &#125;<br><br>    <span class="hljs-comment">/* 清空test数组，以便用来累计实际数据的长度，这里不计算结尾指针的长度 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        test[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 依次向各个bucket中填充实际数据 */</span><br>    <span class="hljs-keyword">for</span> (n = <span class="hljs-number">0</span>; n &lt; nelts; n++) &#123;<br>        <span class="hljs-keyword">if</span> (names[n].key.data == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        key = names[n].key_hash % size;<br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[key] + test[key]);<br><br>        elt-&gt;value = names[n].value;<br>        elt-&gt;len = (u_short) names[n].key.len;<br><br>        ngx_strlow(elt-&gt;name, names[n].key.data, names[n].key.len);<br><br>        <span class="hljs-comment">/* test[key]记录当前bucket内容的填充位置，即下一次填充的起始位置 */</span><br>        test[key] = (u_short) (test[key] + NGX_HASH_ELT_SIZE(&amp;names[n]));<br>    &#125;<br><br>    <span class="hljs-comment">/* 设置bucket结束位置的null指针 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buckets[i] == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ((u_char *) buckets[i] + test[i]);<br><br>        elt-&gt;value = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    ngx_free(test);<br><br>    hinit-&gt;hash-&gt;buckets = buckets;<br>    hinit-&gt;hash-&gt;size = size;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-type">ngx_str_t</span>   val;<br>        <span class="hljs-type">ngx_uint_t</span>  key;<br><br>        elt = buckets[i];<br><br>        <span class="hljs-keyword">if</span> (elt == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: NULL&quot;</span>, i);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (elt-&gt;value) &#123;<br>            val.len = elt-&gt;len;<br>            val.data = &amp;elt-&gt;name[<span class="hljs-number">0</span>];<br><br>            key = hinit-&gt;key(val.data, val.len);<br><br>            ngx_log_error(NGX_LOG_ALERT, hinit-&gt;pool-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                          <span class="hljs-string">&quot;%ui: %p \&quot;%V\&quot; %ui&quot;</span>, i, elt, &amp;val, key);<br><br>            elt = (<span class="hljs-type">ngx_hash_elt_t</span> *) ngx_align_ptr(&amp;elt-&gt;name[<span class="hljs-number">0</span>] + elt-&gt;len,<br>                                                   <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *));<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查找操作—-ngx-hash-find"><a href="#查找操作—-ngx-hash-find" class="headerlink" title="查找操作—-&gt;ngx_hash_find"></a>查找操作—-&gt;ngx_hash_find</h4><img src="https://s2.loli.net/2024/05/25/gt5cvWXzsrhHKYm.png" alt="image-20240525123018812" style="zoom: 33%;" /><p><strong>处理链表</strong>：在哈希表中，哈希桶可能是通过链表实现的。在遍历链表时，需要确保从正确的位置开始访问下一个元素。由于每个元素的长度不固定（因为键的长度不同），所以不能简单地使用固定的偏移量来访问下一个元素，而需要进行对齐操作以确保指针的正确位置。</p><p>其中注意：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_align_ptr(p, a)                                                   \</span><br><span class="hljs-meta">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</span><br></code></pre></td></tr></table></figure><blockquote><p>宏的实现逻辑如下：</p><p>将指针 p 转换为 uintptr_t 类型，以获取指针的无符号整数表示。<br>将对齐方式 a 减 1，得到比对齐方式小一个单位的值。<br>将指针加上 a - 1 的值，相当于向上取整到最近的对齐倍数。<br>使用按位与操作符 &amp; 将结果与 ~(a - 1) 进行按位与运算，将低位的偏移部分清零，从而实现对齐到指定的对齐方式。<br>最后将结果转换回 u_char * 类型，并返回对齐后的指针。</p></blockquote><h3 id="红黑树结构-ngx-rbtree-t"><a href="#红黑树结构-ngx-rbtree-t" class="headerlink" title="红黑树结构 ngx_rbtree_t"></a>红黑树结构 ngx_rbtree_t</h3><p><strong>附上红黑树的四条规则：</strong></p><ul><li>必须为二叉搜索树（左&lt;根&lt;右）</li><li>根和叶子结点都是黑色</li><li>不存在连续的两个红色结点</li><li>任意到根节点路径上的黑色结点数目相同</li></ul><p><strong>红黑树删除结点流程：</strong></p><p><img src="https://s2.loli.net/2024/05/25/wt4UXuV2s6z7v51.png" alt="image-20240525151542705"></p><h5 id="红黑树结构"><a href="#红黑树结构" class="headerlink" title="红黑树结构"></a>红黑树结构</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span>  <span class="hljs-title">ngx_rbtree_node_t</span>;</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_node_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_key_t</span>       key;     <span class="hljs-comment">/* 节点的键值 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *left;    <span class="hljs-comment">/* 节点的左孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *right;   <span class="hljs-comment">/* 节点的右孩子 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *parent;  <span class="hljs-comment">/* 节点的父亲 */</span><br>    u_char                 color;   <span class="hljs-comment">/* 节点的颜色 */</span><br>    u_char                 data;    <span class="hljs-comment">/* */</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span>  <span class="hljs-title">ngx_rbtree_t</span>;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*ngx_rbtree_insert_pt)</span> <span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *root,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span>;<br><br><span class="hljs-comment">/* 红黑树结构 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_rbtree_s</span> &#123;</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *root;    <span class="hljs-comment">/* 指向树的根节点 */</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>     *sentinel;<span class="hljs-comment">/* 指向树的叶子节点NIL */</span><br>    ngx_rbtree_insert_pt   insert;  <span class="hljs-comment">/* 添加元素节点的函数指针，解决具有相同键值，但不同颜色节点的冲突问题；</span><br><span class="hljs-comment">                                     * 该函数指针决定新节点的行为是新增还是替换原始某个节点*/</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="红黑树的操作"><a href="#红黑树的操作" class="headerlink" title="红黑树的操作"></a>红黑树的操作</h4><h5 id="初始化操作-1"><a href="#初始化操作-1" class="headerlink" title="初始化操作"></a>初始化操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 给节点着色，1表示红色，0表示黑色  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_red(node)               ((node)-&gt;color = 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_black(node)             ((node)-&gt;color = 0)</span><br><span class="hljs-comment">/* 判断节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_red(node)            ((node)-&gt;color)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_is_black(node)          (!ngx_rbt_is_red(node))</span><br><span class="hljs-comment">/* 复制某个节点的颜色 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbt_copy_color(n1, n2)      (n1-&gt;color = n2-&gt;color)</span><br><br><span class="hljs-comment">/* 节点着黑色的宏定义 */</span><br><span class="hljs-comment">/* a sentinel must be black */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_sentinel_init(node)  ngx_rbt_black(node)</span><br><br><span class="hljs-comment">/* 初始化红黑树，即为空的红黑树 */</span><br><span class="hljs-comment">/* tree 是指向红黑树的指针，</span><br><span class="hljs-comment"> * s 是红黑树的一个NIL节点，</span><br><span class="hljs-comment"> * i 表示函数指针，决定节点是新增还是替换</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_rbtree_init(tree, s, i)                                           \</span><br><span class="hljs-meta">    ngx_rbtree_sentinel_init(s);                                              \</span><br><span class="hljs-meta">    (tree)-&gt;root = s;                                                         \</span><br><span class="hljs-meta">    (tree)-&gt;sentinel = s;                                                     \</span><br><span class="hljs-meta">    (tree)-&gt;insert = i</span><br><br></code></pre></td></tr></table></figure><h5 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h5><p>同平衡二叉树(AVL)的旋转逻辑相同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 左旋转操作 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_left_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;right;<span class="hljs-comment">/* temp为node节点的右孩子 */</span><br>    node-&gt;right = temp-&gt;left;<span class="hljs-comment">/* 设置node节点的右孩子为temp的左孩子 */</span><br><br>    <span class="hljs-keyword">if</span> (temp-&gt;left != sentinel) &#123;<br>        temp-&gt;left-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>        node-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    temp-&gt;left = node;<br>    node-&gt;parent = temp;<br>&#125;<br><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_right_rotate</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> **root, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *temp;<br><br>    temp = node-&gt;left;<br>    node-&gt;left = temp-&gt;right;<br><br>    <span class="hljs-keyword">if</span> (temp-&gt;right != sentinel) &#123;<br>        temp-&gt;right-&gt;parent = node;<br>    &#125;<br><br>    temp-&gt;parent = node-&gt;parent;<br><br>    <span class="hljs-keyword">if</span> (node == *root) &#123;<br>        *root = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>        node-&gt;parent-&gt;right = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node-&gt;parent-&gt;left = temp;<br>    &#125;<br><br>    temp-&gt;right = node;<br>    node-&gt;parent = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 获取红黑树键值最小的节点 */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">ngx_rbtree_node_t</span> *<br><span class="hljs-title function_">ngx_rbtree_min</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *node, <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (node-&gt;left != sentinel) &#123;<br>        node = node-&gt;left;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">/* 插入节点 */</span><br><span class="hljs-comment">/* 插入节点的步骤：</span><br><span class="hljs-comment"> * 1、首先按照二叉查找树的插入操作插入新节点；</span><br><span class="hljs-comment"> * 2、然后把新节点着色为红色（避免破坏红黑树性质5）；</span><br><span class="hljs-comment"> * 3、为维持红黑树的性质，调整红黑树的节点（着色并旋转），使其满足红黑树的性质；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *temp, *sentinel;<br><br>    <span class="hljs-comment">/* a binary tree insert */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 若红黑树为空，则比较简单，把新节点作为根节点，</span><br><span class="hljs-comment">     * 并初始化该节点使其满足红黑树性质</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (*root == sentinel) &#123;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;left = sentinel;<br>        node-&gt;right = sentinel;<br>        ngx_rbt_black(node);<br>        *root = node;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若红黑树不为空，则按照二叉查找树的插入操作进行</span><br><span class="hljs-comment">     * 该操作由函数指针提供</span><br><span class="hljs-comment">     */</span><br>    tree-&gt;insert(*root, node, sentinel);<br><br>    <span class="hljs-comment">/* re-balance tree */</span><br><br>    <span class="hljs-comment">/* 调整红黑树，使其满足性质，</span><br><span class="hljs-comment">     * 其实这里只是破坏了性质4：若一个节点是红色，则孩子节点都为黑色；</span><br><span class="hljs-comment">     * 若破坏了性质4，则新节点 node 及其父亲节点 node-&gt;parent 都为红色；</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (node != *root &amp;&amp; ngx_rbt_is_red(node-&gt;parent)) &#123;<br><br>        <span class="hljs-comment">/* 若node的父亲节点是其祖父节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (node-&gt;parent == node-&gt;parent-&gt;parent-&gt;left) &#123;<br>            temp = node-&gt;parent-&gt;parent-&gt;right;<span class="hljs-comment">/* temp节点为node的叔叔节点 */</span><br><br>            <span class="hljs-comment">/* case1：node的叔叔节点是红色 */</span><br>            <span class="hljs-comment">/* 此时，node的父亲及叔叔节点都为红色；</span><br><span class="hljs-comment">             * 解决办法：将node的父亲及叔叔节点着色为黑色，将node祖父节点着色为红色；</span><br><span class="hljs-comment">             * 然后沿着祖父节点向上判断是否会破会红黑树的性质；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* case2：node的叔叔节点是黑色且node是父亲节点的右孩子 */</span><br>                <span class="hljs-comment">/* 则此时，以node父亲节点进行左旋转，使case2转变为case3；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;right) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_left_rotate(root, sentinel, node);<br>                &#125;<br><br>                <span class="hljs-comment">/* case3：node的叔叔节点是黑色且node是父亲节点的左孩子 */</span><br>                <span class="hljs-comment">/* 首先，将node的父亲节点着色为黑色，祖父节点着色为红色；</span><br><span class="hljs-comment">                 * 然后以祖父节点进行一次右旋转；</span><br><span class="hljs-comment">                 */</span><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 若node的父亲节点是其祖父节点的右孩子 */</span><br>            <span class="hljs-comment">/* 这里跟上面的情况是对称的，就不再进行讲解了</span><br><span class="hljs-comment">             */</span><br>            temp = node-&gt;parent-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(temp)) &#123;<br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_black(temp);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                node = node-&gt;parent-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                    node = node-&gt;parent;<br>                    ngx_rbtree_right_rotate(root, sentinel, node);<br>                &#125;<br><br>                ngx_rbt_black(node-&gt;parent);<br>                ngx_rbt_red(node-&gt;parent-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, node-&gt;parent-&gt;parent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根节点必须为黑色 */</span><br>    ngx_rbt_black(*root);<br>&#125;<br><br><span class="hljs-comment">/* 这里只是将节点插入到红黑树中，并没有判断是否满足红黑树的性质；</span><br><span class="hljs-comment"> * 类似于二叉查找树的插入操作，这个函数为红黑树插入操作的函数指针；</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/* 判断node节点键值与temp节点键值的大小，以决定node插入到temp节点的左子树还是右子树 */</span><br>        p = (node-&gt;key &lt; temp-&gt;key) ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    <span class="hljs-comment">/* 初始化node节点，并着色为红色 */</span><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_insert_timer_value</span><span class="hljs-params">(<span class="hljs-type">ngx_rbtree_node_t</span> *temp, <span class="hljs-type">ngx_rbtree_node_t</span> *node,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *sentinel)</span><br>&#123;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **p;<br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Timer values</span><br><span class="hljs-comment">         * 1) are spread in small range, usually several minutes,</span><br><span class="hljs-comment">         * 2) and overflow each 49 days, if milliseconds are stored in 32 bits.</span><br><span class="hljs-comment">         * The comparison takes into account that overflow.</span><br><span class="hljs-comment">         */</span><br><br>        <span class="hljs-comment">/*  node-&gt;key &lt; temp-&gt;key */</span><br><br>        p = ((<span class="hljs-type">ngx_rbtree_key_int_t</span>) (node-&gt;key - temp-&gt;key) &lt; <span class="hljs-number">0</span>)<br>            ? &amp;temp-&gt;left : &amp;temp-&gt;right;<br><br>        <span class="hljs-keyword">if</span> (*p == sentinel) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        temp = *p;<br>    &#125;<br><br>    *p = node;<br>    node-&gt;parent = temp;<br>    node-&gt;left = sentinel;<br>    node-&gt;right = sentinel;<br>    ngx_rbt_red(node);<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 删除节点 */</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_rbtree_delete</span><span class="hljs-params">(ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span> *tree,</span><br><span class="hljs-params">    <span class="hljs-type">ngx_rbtree_node_t</span> *node)</span><br>&#123;<br>    <span class="hljs-type">ngx_uint_t</span>           red;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  **root, *sentinel, *subst, *temp, *w;<br><br>    <span class="hljs-comment">/* a binary tree delete */</span><br><br>    root = (<span class="hljs-type">ngx_rbtree_node_t</span> **) &amp;tree-&gt;root;<br>    sentinel = tree-&gt;sentinel;<br><br>    <span class="hljs-comment">/* 下面是获取temp节点值，temp保存的节点是准备替换节点node ；</span><br><span class="hljs-comment">     * subst是保存要被替换的节点的后继节点；</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">/* case1：若node节点没有左孩子（这里包含了存在或不存在右孩子的情况）*/</span><br>    <span class="hljs-keyword">if</span> (node-&gt;left == sentinel) &#123;<br>        temp = node-&gt;right;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node-&gt;right == sentinel) &#123;<span class="hljs-comment">/* case2：node节点存在左孩子，但是不存在右孩子 */</span><br>        temp = node-&gt;left;<br>        subst = node;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case3：node节点既有左孩子，又有右孩子 */</span><br>        subst = ngx_rbtree_min(node-&gt;right, sentinel);<span class="hljs-comment">/* 获取node节点的后续节点 */</span><br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            temp = subst-&gt;left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp = subst-&gt;right;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若被替换的节点subst是根节点，则temp直接替换subst称为根节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == *root) &#123;<br>        *root = temp;<br>        ngx_rbt_black(temp);<br><br>        <span class="hljs-comment">/* DEBUG stuff */</span><br>        node-&gt;left = <span class="hljs-literal">NULL</span>;<br>        node-&gt;right = <span class="hljs-literal">NULL</span>;<br>        node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>        node-&gt;key = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* red记录subst节点的颜色 */</span><br>    red = ngx_rbt_is_red(subst);<br><br>    <span class="hljs-comment">/* temp节点替换subst 节点 */</span><br>    <span class="hljs-keyword">if</span> (subst == subst-&gt;parent-&gt;left) &#123;<br>        subst-&gt;parent-&gt;left = temp;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        subst-&gt;parent-&gt;right = temp;<br>    &#125;<br><br>    <span class="hljs-comment">/* 根据subst是否为node节点进行处理 */</span><br>    <span class="hljs-keyword">if</span> (subst == node) &#123;<br><br>        temp-&gt;parent = subst-&gt;parent;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;parent == node) &#123;<br>            temp-&gt;parent = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            temp-&gt;parent = subst-&gt;parent;<br>        &#125;<br><br>        <span class="hljs-comment">/* 复制node节点属性 */</span><br>        subst-&gt;left = node-&gt;left;<br>        subst-&gt;right = node-&gt;right;<br>        subst-&gt;parent = node-&gt;parent;<br>        ngx_rbt_copy_color(subst, node);<br><br>        <span class="hljs-keyword">if</span> (node == *root) &#123;<br>            *root = subst;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (node == node-&gt;parent-&gt;left) &#123;<br>                node-&gt;parent-&gt;left = subst;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;parent-&gt;right = subst;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;left != sentinel) &#123;<br>            subst-&gt;left-&gt;parent = subst;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (subst-&gt;right != sentinel) &#123;<br>            subst-&gt;right-&gt;parent = subst;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* DEBUG stuff */</span><br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = <span class="hljs-literal">NULL</span>;<br>    node-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    node-&gt;key = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (red) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 下面开始是调整红黑树的性质 */</span><br>    <span class="hljs-comment">/* a delete fixup */</span><br><br>    <span class="hljs-comment">/* 根据temp节点进行处理 ，若temp不是根节点且为黑色 */</span><br>    <span class="hljs-keyword">while</span> (temp != *root &amp;&amp; ngx_rbt_is_black(temp)) &#123;<br><br>        <span class="hljs-comment">/* 若temp是其父亲节点的左孩子 */</span><br>        <span class="hljs-keyword">if</span> (temp == temp-&gt;parent-&gt;left) &#123;<br>            w = temp-&gt;parent-&gt;right;<span class="hljs-comment">/* w为temp的兄弟节点 */</span><br><br>            <span class="hljs-comment">/* case A：temp兄弟节点为红色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点及temp父亲节点的颜色；</span><br><span class="hljs-comment">             * 2、对temp父亲节的做一次左旋转，此时，temp的兄弟节点是旋转之前w的某个子节点，该子节点颜色为黑色；</span><br><span class="hljs-comment">             * 3、此时，case A已经转换为case B、case C 或 case D；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;right;<br>            &#125;<br><br>            <span class="hljs-comment">/* case B：temp的兄弟节点w是黑色，且w的两个子节点都是黑色 */</span><br>            <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">             * 1、改变w节点的颜色；</span><br><span class="hljs-comment">             * 2、把temp的父亲节点作为新的temp节点；</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* case C：temp的兄弟节点是黑色，且w的左孩子是红色，右孩子是黑色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将改变w及其左孩子的颜色；</span><br><span class="hljs-comment">                 * 2、对w节点进行一次右旋转；</span><br><span class="hljs-comment">                 * 3、此时，temp新的兄弟节点w有着一个红色右孩子的黑色节点，转为case D；</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;right)) &#123;<br>                    ngx_rbt_black(w-&gt;left);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_right_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;right;<br>                &#125;<br><br>                <span class="hljs-comment">/* case D：temp的兄弟节点w为黑色，且w的右孩子为红色 */</span><br>                <span class="hljs-comment">/* 解决办法：</span><br><span class="hljs-comment">                 * 1、将w节点设置为temp父亲节点的颜色，temp父亲节点设置为黑色；</span><br><span class="hljs-comment">                 * 2、w的右孩子设置为黑色；</span><br><span class="hljs-comment">                 * 3、对temp的父亲节点做一次左旋转；</span><br><span class="hljs-comment">                 * 4、最后把根节点root设置为temp节点；*/</span><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;right);<br>                ngx_rbtree_left_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 这里针对的是temp节点为其父亲节点的左孩子的情况 */</span><br>            w = temp-&gt;parent-&gt;left;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_red(w)) &#123;<br>                ngx_rbt_black(w);<br>                ngx_rbt_red(temp-&gt;parent);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                w = temp-&gt;parent-&gt;left;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left) &amp;&amp; ngx_rbt_is_black(w-&gt;right)) &#123;<br>                ngx_rbt_red(w);<br>                temp = temp-&gt;parent;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ngx_rbt_is_black(w-&gt;left)) &#123;<br>                    ngx_rbt_black(w-&gt;right);<br>                    ngx_rbt_red(w);<br>                    ngx_rbtree_left_rotate(root, sentinel, w);<br>                    w = temp-&gt;parent-&gt;left;<br>                &#125;<br><br>                ngx_rbt_copy_color(w, temp-&gt;parent);<br>                ngx_rbt_black(temp-&gt;parent);<br>                ngx_rbt_black(w-&gt;left);<br>                ngx_rbtree_right_rotate(root, sentinel, temp-&gt;parent);<br>                temp = *root;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ngx_rbt_black(temp);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理层</title>
    <link href="/2023/02/20/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2023/02/20/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><p>个人以为该章的重点在于<strong>了解计算机在物理层中的数据通信过程</strong>和<strong>信道复用技术</strong>，故其他部分只是一笔带过，具体需要时可翻书复习。</p><h2 id="1-数据通信模型"><a href="#1-数据通信模型" class="headerlink" title="1.数据通信模型"></a>1.数据通信模型</h2><p><img src="https://pic2.zhimg.com/v2-516e211258fd86bd27c4ea0f211f2d1f_1440w.jpg" alt="img"></p><h3 id="常用术语："><a href="#常用术语：" class="headerlink" title="常用术语："></a>常用术语：</h3><ol><li>信道：</li></ol><p>信道（Channel）是指在通信系统中用于传输信息的介质或路径。它可以是物理媒介（如电缆、光纤）或无线媒介（如空气中的无线电波）。信道承载着数据、声音、图像等信息，将其从发送方传输到接收方。</p><p>信道可以是单向的（只支持单向传输），也可以是双向的（同时支持双向传输）。在单向信道中，信息只能从发送方流向接收方，而在双向信道中，信息可以在两个方向上进行传输。</p><p>信道根据传输方式和特性的不同可以分为模拟信道和数字信道：</p><ol><li>模拟信道（Analog Channel）：模拟信道传输的是连续的模拟信号。它的传输特点受到噪声、衰减和失真等因素的影响，需要采取衰减补偿、均衡和滤波等技术来保证信号的质量。</li><li>数字信道（Digital Channel）：数字信道传输的是离散的数字信号，在信道中通过调制和解调技术将数字信号转换为模拟信号进行传输。数字信道具有较强的抗干扰能力和误码纠正能力，可以提供更可靠的数据传输。</li></ol><p>在通信系统中，为了提高信道的可靠性和传输效率，常常会采用多路复用、编码调制、差错检测纠正等技术来进行信道管理和优化。通过合理设计和优化信道，可以实现高质量的信息传输和通信服务。</p><p>2.带宽：</p><p>带宽（Bandwidth）是指在特定的信号传输系统或通信信道中，能够传输的最高数据率或频率范围。在数字通信中，带宽通常用于表示信号或通道能够传输的频率范围。</p><p>在模拟信号中，带宽是指一个信号的频率范围，通常以赫兹（Hz）作为单位。例如，对于音频信号而言，常见的带宽范围是20 Hz到20 kHz。这意味着音频信号中包含的频率范围从20 Hz到20 kHz，超过或低于这个范围的频率将无法被传输。</p><p>在数字通信中，带宽表示单位时间内可以传输的数据量。通常以比特每秒（bps）或千比特每秒（Kbps）、兆比特每秒（Mbps）等单位来表示。带宽越高，表示在单位时间内可以传输更多的数据，从而提高了数据传输速率。</p><p>需要注意的是，带宽并不等同于数据传输速率。带宽是指信号传输的频率范围或信道的能力，而数据传输速率取决于信号调制、编码和其他因素，可能会受到实际传输环境和设备性能的影响。</p><p>3.码元：</p><p>码元（Symbol）是指数字通信中表示信息的最基本、不可分割的单位。在数字通信系统中，信息经过编码处理后被转换成一系列离散的符号或信号，这些离散的符号即为码元。</p><p>码元可以是数字信号的离散取值，也可以是模拟信号的一组采样值。它代表了一定的信息量或符号，可以表示一位或多位的二进制数据。根据具体的编码方式和调制方法，码元可以有不同的取值和持续时间。</p><p>常用的二进制码元有两个取值：0和1，分别表示低电平和高电平、低功率和高功率、无振幅和有振幅等。除了二进制码元外，还存在多进制码元，如四进制（0、1、2、3）或八进制（0~7）等，在相同时间内传输更多的信息。</p><p>在数字通信系统中，通过调制技术将码元映射到特定的物理信号上，例如调幅（AM）、调频（FM）、调相（PM）等。接收端根据调制方式进行解调还原出码元，进而恢复出原始的信息数据。</p><p>码元的持续时间决定了系统的速率和带宽。如果一个码元的持续时间较短，意味着系统传输速率较高，但同时需要更宽的带宽来支持传输。因此，在设计数字通信系统时需要考虑码元的选择、调制方式和带宽等因素，以实现高效可靠的数据传输。</p><p>3.其他：</p><p>来自信源的信号常称为<strong>基带信号</strong>（即基本频带信号）。像计算机输出的代表各种文字图像文件的数据信号都属于基带信号。基带信号往往包含较多的低频分量，甚至有直流分而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号行调制（modulation）。</p><p>调制可分为两大类。一类是仅仅对基带信号的波形进行变换，使它能够与信道特性适应。变换后的信号仍然是基带信号。这类调制称为<strong>基带调制</strong>。由于这种基带调制是把数字信号转换为另一种形式的数字信号，因此大家更愿意把这种过程称为<strong>编码</strong>（coding）。另一类调制则需要使用<strong>载波</strong>（carrier）进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输。经过载波调制后的信号称为<strong>带通信号</strong>（即仅在一段频率范围内能够通过信道），而使用载波的调制称为<strong>带通调制</strong>。</p><h3 id="常见编码方式"><a href="#常见编码方式" class="headerlink" title="常见编码方式"></a>常见编码方式</h3><ol><li>不归零制</li><li>归零制</li><li>曼彻斯特编码</li><li>差分曼彻斯特编码</li></ol><h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><ol><li>调幅</li><li>调频</li><li>调相</li></ol><h2 id="2-信道"><a href="#2-信道" class="headerlink" title="2.信道"></a>2.信道</h2><p>在前面信道的术语阐述里，信道的物理实现可以是：双绞线，同轴电缆，光缆，无线电波等</p><p>在开启下面有关信道的内容时，请先容我提出一个关于快递系统问题：</p><p>小明，小红，小蓝分别从a,b,c地寄各自的快递x,y,z到A,B,C地,问如何用最少的资源，最短的时间将快递顺利送达？</p><p><strong>答案是显而易见的：</strong></p><p><strong>最少的资源实现方法：在a,b,c之间，A，B，C之间各建立一个分拣中心，统一收发快递。快递车只需负责送往两地分拣中心即可</strong></p><p><strong>最短的时间实现方法：要么快递车一次性多装点货物要么提高快递车的速度要么同时增加快递车的数量。</strong></p><h2 id="3-信道的复用技术："><a href="#3-信道的复用技术：" class="headerlink" title="3.信道的复用技术："></a>3.信道的复用技术：</h2><p>为什么要信道复用？</p><p>信道复用是指在有限的信道资源中，通过合理的方式同时传输多个通信信号。这样做的目的是为了提高信道的利用效率和容量，实现多用户同时进行通信而不相互干扰。</p><p>与信道有关的联系是，信道是传输通信信号的媒介，它可以是电缆、光纤或者无线传输介质。每个信道都有一定的带宽，表征了信道能够传输的最高频率范围。而信道复用则是在这个有限的频率范围内有效地分配和共享资源。</p><p>信道复用的好处主要体现在以下几个方面：</p><ol><li>提高信道利用效率：通过信道复用，多个通信信号可以在同一个信道上同时传输，充分利用了信道资源，避免了资源的闲置浪费。</li><li>增加信道容量：由于信道复用可以将多个通信信号同时传输，因此可以提高信道的容量，使得更多的用户或设备可以同时进行通信。</li><li>减少成本：信道资源是宝贵且有限的，通过信道复用可以节省新建信道的成本，提高网络的经济效益。</li></ol><p>信道复用的种类有哪些？</p><p>信道复用可以采用不同的复用技术，常见的技术包括频分复用（Frequency Division Multiplexing，FDM）、时分复用（Time Division Multiplexing，TDM）和码分复用（Code Division Multiplexing，CDM）等。这些技术通过将信道分割成不同的子信道或时间片，并为每个用户或设备分配相应的资源，实现多个通信信号在同一个信道上同时传输</p><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>一条100m宽马路一次只能通行一辆10m宽的快递车，倘若有10个收货人，第10名肯定得急死也降低了公路的使用率。有什么办法可以改善呢？假如我们用栅栏从中将马路分成10分，一次性不就可以通行10辆车了！</p><p>频分复用（Frequency Division Multiplexing，FDM）是一种将多个信号通过调制不同的载波频率在一个信道中传输的技术。其基本原理是将一段频率范围划分成若干个子频带，每个传输用户占据单独的一个或多个子频带，不同符号从不同的子频带中传输，通过将多个子信号叠加在同一信道中传输，完成多路信号的传输。</p><p>在FDM系统中，每个用户所使用的带宽都是固定不变的，因此不会互相干扰。目前应用广泛的有线电视、广播和移动通信等系统中采用了FDM技术。FDM技术具有传输速率高、带宽利用率高以及接收灵敏度高等优点，但也存在传输容量固定、系统复杂度高、对信噪比要求高以及频率分配受到限制等缺点。</p><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>前面谈到频分复用，但考虑这样的极端情况：100个子信道中只有1个信道在传输数据或者100的带宽资源被分成10000份。这两种情况下不仅导致信道利用率下降还会导致每个用户在单位时间内可以传输的数据量也就相应降低了，从而导致单位时间内传输的数据量减少。有没有一种方法解决呢？</p><p>时分复用（Time Division Multiplexing，TDM）是一种信道复用技术，它将单个物理信道分成多个子信道，每个子信道只在特定的时间段内被分配给一个通信设备或用户进行传输。TDM 技术通常应用于数字通信系统中，可以有效地利用带宽资源，提高信道容量和利用效率。</p><p>在 TDM 中，物理信道按照时间分割成若干个时隙，每个时隙都是固定长度的时间片。不同的用户或设备按照轮流使用时隙的方式，即在不同的时间段内占用相同的时隙。这样，所有的用户或设备可以在同一个物理信道上进行同时传输，而不会相互干扰。</p><p>例如，假设有 4 个用户需要进行通信，每个用户需要传输的数据速率都为 10 Mbps，但只有一个 40 Mbps 的物理信道可供使用。如果使用时间分割复用技术，可以将物理信道分成 40 个时隙，每个时隙的时长为 1&#x2F;40 秒。然后将这 40 个时隙分配给不同的用户，让它们依次占用各自的时隙，如下图所示：</p><p>Copy Code</p><p><em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em>—- <em>10 Mbps</em> —-<em>|</em></p><p><em>|</em>&lt;—- <em>1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|<em>&lt;—- *1&#x2F;40 s* —-&gt;</em>|*</p><p><em>User 1 User 2 User 3 User 4</em></p><p>在这个例子中，每个用户只需要传输 10 Mbps 的数据，因此不同的用户只需要占用相应数量的时隙即可。当所有用户都在轮流使用时隙进行传输时，就可以实现多用户同时传输，而不会互相干扰，从而提高了信道的利用效率和容量。</p><p>需要注意的是，TDM 技术需要精确的时钟同步，在发送端和接收端都需要有严格的时序控制。这对于实现准确同步、协调多个用户的传输速率等方面提出了挑战，但是这些问题可以通过一些专门的技术手段来解决。</p><p>问题：</p><p><img src="https://pic1.zhimg.com/v2-38dee6ce266028cea9ccc95ebe54f872_1440w.jpg" alt="img"></p><h3 id="统计时分复用（进阶版时分复用）"><a href="#统计时分复用（进阶版时分复用）" class="headerlink" title="统计时分复用（进阶版时分复用）"></a>统计时分复用（进阶版时分复用）</h3><p>统计时分复用（Statistical Time Division Multiplexing，STDM）是一种基于时分复用（TDM）的数据传输技术，它在时分复用的基础上引入了动态分配的机制。</p><p>在传统的时分复用中，每个用户被分配一个固定的时间片段进行数据传输，无论这个时间片段内有无实际数据需要传输。这样可能导致带宽资源的浪费。而在统计时分复用中，分配给每个用户的时间片段不再是固定的，而是根据实际数据传输需求进行动态分配。</p><p>具体来说，统计时分复用的过程如下：</p><ol><li>收集用户的数据：系统根据用户发送数据的需求，收集各个用户的数据。</li><li>动态分配时间片段：根据用户的数据量和传输需求，系统动态地分配时间片段给每个用户。数据量较大的用户可以获得更多的时间片段，而数据量较小的用户则分配较少的时间片段。</li><li>数据传输：在各自分配到的时间片段内，用户将自己的数据通过时分复用的方式进行传输。由于时间片段是根据实际需求进行动态调整的，因此可以更好地利用带宽资源。</li></ol><p><img src="https://pica.zhimg.com/v2-394665827202f5d2b43ea2e161e709f6_1440w.jpg" alt="img"></p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用（Code Division Multiplexing，CDM）是一种用于多用户间同时使用同一频带传输数据的技术。与频分复用不同，码分复用采用了更为复杂的调制方式来实现多路信号的复用。</p><p>码分复用通过将每个用户的数据码序列进行编码，再将它们映射到不同的、周期性变化的码片上。每个码片都由一个伪随机码片序列（Pseudo-Random Noise Sequence，PRN序列）生成，是一段具有随机性质的比特序列。每个用户的编码器所使用的伪随机码片序列都是不同的，因此不同用户的码片之间互不干扰。由于码片之间具有正交性，因此不同用户的数据可以同时在同一频率带宽上传输，而不会相互干扰。</p><p>在接收端，接收器使用相同的伪随机码片序列对接收到的信号进行解码。由于每个码片都具有正交性质，因此只有接收器使用正确的伪随机码片序列进行解码时，才能够提取出该用户发送的数据。其他码片的数据则被解码后视为噪声而被滤除掉。</p><p>码分复用已经被广泛应用于移动通信、卫星通信以及军事通信等领域。它具有以下几个特点：</p><ol><li>码分复用的带宽利用率高，多路信号可以在同一频率带宽上进行传输。</li><li>码分复用具有优秀的抗干扰性能，因为每个用户的数据都被编码成具有随机性质的码片，相互之间不存在相关关系，因此即使是强烈的干扰也很难对其造成影响。</li><li>码分复用可以实现灵活的资源管理，根据用户需求动态地分配码片资源，提高了系统的效率和灵活性。</li></ol><p>以上就是码分复用的工作原理，它通过将多个用户的数据映射到不同的码片上，并通过使用相同的伪随机码片序列对数据进行解码，实现了多用户同时在同一频带宽上传输数据的目的。</p><p>码片序列的正交关系（数学公式）</p><p><img src="https://pic3.zhimg.com/v2-23da0729e5dcc9c2430f4feb956d72b2_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-4f4e68a70043b7ddb057e06a2fc2caff_1440w.jpg" alt="img"></p><p>CDMA工作原理：</p><p><img src="https://picx.zhimg.com/v2-e4c59ad9d8ed6d244d23e6e9cf92d4fd_1440w.jpg" alt="img"></p><h2 id="4-宽带接入技术"><a href="#4-宽带接入技术" class="headerlink" title="4.宽带接入技术"></a>4.宽带接入技术</h2><ol><li>ADSL<br>ADSL（Asymmetric Digital Subscriber Line）是一种基于普通电话线提供高速数据传输的技术，它采用数字信号复用技术，将语音和数据流分离在不同的频段上进行传输。ADSL的特点是上行和下行带宽不对称，支持高速上网和多媒体通信，但受到距离限制，信号衰减会导致传输速率下降。ADSL常用于家庭用户和小型企业的宽带接入。</li><li>HFC网<br>HFC（Hybrid Fiber Coaxial）是一种混合光纤同轴电缆网络结构，结合了光纤和同轴电缆的优点，具有高速信号传输和容量大的特点，适用于高密度住宅区和商业地区的大规模宽带接入。HFC通过将信号从中心办公室发送到周围的同轴电缆节点，再通过同轴电缆向用户终端传输，同时还可以提供电视信号等多种服务。</li><li>FTTx技术</li></ol><p>FTTx是一系列基于光纤的宽带接入技术，包括FTTH（Fiber to the Home）、FTTC（Fiber to the Curb）和FTTB（Fiber to the Building）等。FTTx技术的特点是光纤传输距离远、带宽大、干扰小、速率高，并且未来可升级性好，可以满足用户日益增长的带宽需求。其中，FTTH是将光纤直接引入用户家中的技术，提供最高的传输速率和质量，目前被认为是宽带接入的最佳技术。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx时间管理与定时器</title>
    <link href="/2023/02/18/Nginx%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2023/02/18/Nginx%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx时间管理与定时器"><a href="#Nginx时间管理与定时器" class="headerlink" title="Nginx时间管理与定时器"></a>Nginx时间管理与定时器</h1><h2 id="我眼中的是时间管理"><a href="#我眼中的是时间管理" class="headerlink" title="我眼中的是时间管理"></a>我眼中的是时间管理</h2><p>从系统调用函数直接获取当前时间</p><h2 id="我眼中的定时器"><a href="#我眼中的定时器" class="headerlink" title="我眼中的定时器"></a>我眼中的定时器</h2><ul><li>有一定数据结构组织起来【链表】</li><li>有回调处理函数</li></ul><h2 id="Nginx实现的时间管理"><a href="#Nginx实现的时间管理" class="headerlink" title="Nginx实现的时间管理"></a>Nginx实现的时间管理</h2><p><img src="https://s2.loli.net/2024/05/28/sSOeYAMayZW5tjn.png" alt="image-20240528103843360"></p><p><strong>Linux下操作时间的相关函数和结构体</strong></p><p><img src="https://s2.loli.net/2024/05/28/yM82u75C1UdKEkh.png" alt="20200923110542514"></p><ol><li><strong>结构体：</strong><ul><li><strong><code>struct tm</code>：</strong> 用于表示日期和时间的各个组成部分，包括秒、分、时、日、月、年等。</li><li><strong><code>struct timeval</code>：</strong> 用于表示时间间隔的结构体，包括秒和微秒。</li></ul></li><li><strong>函数：</strong><ul><li><strong><code>time_t time(time_t *t)</code>：</strong> 获取当前日历时间的秒数，返回自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来经过的秒数。</li><li><strong><code>int gettimeofday(struct timeval *tv, struct timezone *tz)</code>：</strong> 获取当前时间和时区信息，填充到 <code>struct timeval</code> 结构体和 <code>struct timezone</code> 结构体中。</li><li><strong><code>struct tm *localtime(const time_t *timep)</code>：</strong> 将日历时间转换为本地时间，返回指向 <code>struct tm</code> 结构体的指针。</li><li><strong><code>struct tm *gmtime(const time_t *timep)</code>：</strong> 将日历时间转换为格林尼治时间（UTC 时间），返回指向 <code>struct tm</code> 结构体的指针。</li><li><strong><code>time_t mktime(struct tm *tm)</code>：</strong> 将本地时间或格林尼治时间转换为日历时间，返回对应的日历时间秒数。</li><li><strong><code>char *asctime(const struct tm *tm)</code>：</strong> 将 <code>struct tm</code> 结构体表示的时间转换为字符串格式，并返回一个指向静态分配的字符串的指针。</li><li><strong><code>char *ctime(const time_t *timep)</code>：</strong> 将日历时间转换为字符串格式，并返回一个指向静态分配的字符串的指针。</li></ul></li></ol><h3 id="时间结构体"><a href="#时间结构体" class="headerlink" title="时间结构体"></a>时间结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">time_t</span>      sec;     <span class="hljs-comment">// 秒数</span><br>    <span class="hljs-type">ngx_uint_t</span>  msec;    <span class="hljs-comment">// 毫秒数</span><br>    <span class="hljs-type">ngx_int_t</span>   gmtoff;  <span class="hljs-comment">// GMT偏移量</span><br>&#125; <span class="hljs-type">ngx_time_t</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span>             <span class="hljs-title">ngx_tm_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">int</span> tm_sec;<span class="hljs-comment">/* Seconds.[0-60] (1 leap second) */</span><br>  <span class="hljs-type">int</span> tm_min;<span class="hljs-comment">/* Minutes.[0-59] */</span><br>  <span class="hljs-type">int</span> tm_hour;<span class="hljs-comment">/* Hours.[0-23] */</span><br>  <span class="hljs-type">int</span> tm_mday;<span class="hljs-comment">/* Day.[1-31] */</span><br>  <span class="hljs-type">int</span> tm_mon;<span class="hljs-comment">/* Month.[0-11] */</span><br>  <span class="hljs-type">int</span> tm_year;<span class="hljs-comment">/* Year- 1900.  */</span><br>  <span class="hljs-type">int</span> tm_wday;<span class="hljs-comment">/* Day of week.[0-6] */</span><br>  <span class="hljs-type">int</span> tm_yday;<span class="hljs-comment">/* Days in year.[0-365]*/</span><br>  <span class="hljs-type">int</span> tm_isdst;<span class="hljs-comment">/* DST.[-1/0/1]*/</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">ifdef</span>__USE_MISC</span><br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> tm_gmtoff;<span class="hljs-comment">/* Seconds east of UTC.  */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tm_zone;<span class="hljs-comment">/* Timezone abbreviation.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __tm_gmtoff;<span class="hljs-comment">/* Seconds east of UTC.  */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *__tm_zone;<span class="hljs-comment">/* Timezone abbreviation.  */</span><br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意差别：</p><ol><li><strong><code>struct tm</code> 结构体：</strong><ul><li><code>struct tm</code> 结构体是标准 C 库 <code>&lt;time.h&gt;</code> 中定义的，在很多 C 语言的标准库中都可以找到。</li><li>它用于表示日期和时间的各个组成部分，如年、月、日、时、分、秒等，并提供了一些其他与时间相关的信息，如周几、一年中的第几天、夏令时标志等。</li><li>它通常用于时间日期的转换和格式化，例如将时间戳转换为人类可读的日期时间格式，或者将日期时间格式解析为时间戳等操作。</li></ul></li><li><strong><code>ngx_tm_t</code> 结构体：</strong><ul><li><code>ngx_tm_t</code> 结构体是在 Nginx 源码中定义的，用于表示 Nginx 内部的时间信息。</li><li>它与标准的 <code>struct tm</code> 结构体类似，但通常只包含了时间的基本信息，如秒数、毫秒数等，并没有包含日期、周几、时区等额外信息。</li><li>它通常用于 Nginx 内部的时间操作，如计算时间差、时间戳的获取、时间的更新等。</li></ul></li></ol><p><strong><code>struct tm</code> 结构体更加通用，适用于标准 C 语言环境下的时间操作，而 <code>ngx_tm_t</code> 结构体则是针对 Nginx 内部的时间处理需求而设计的，更加简洁和高效。</strong></p><h4 id="全局时间缓存"><a href="#全局时间缓存" class="headerlink" title="全局时间缓存"></a>全局时间缓存</h4><p>用于存储当前时间及其不同格式的字符串表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_time_t</span>        cached_time[NGX_TIME_SLOTS];<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_time_t</span>  *ngx_cached_time;<br></code></pre></td></tr></table></figure><h4 id="简单科普一下GMT与ISO-8601"><a href="#简单科普一下GMT与ISO-8601" class="headerlink" title="简单科普一下GMT与ISO 8601"></a>简单科普一下GMT与ISO 8601</h4><h5 id="ISO-8601-时间格式"><a href="#ISO-8601-时间格式" class="headerlink" title="ISO 8601 时间格式"></a>ISO 8601 时间格式</h5><p><strong>ISO 8601</strong> 是国际标准化组织（ISO）发布的日期和时间表示法标准，旨在提供一种清晰、一致的方式来表示日期和时间。其主要特点和格式如下：</p><ol><li><p><strong>日期格式</strong>：</p><ul><li><code>YYYY-MM-DD</code>：四位数的年份，二位数的月份和日期。例如，2024年5月27日表示为 <code>2024-05-27</code>。</li></ul></li><li><p><strong>时间格式</strong>：</p><ul><li><code>hh:mm:ss</code>：二位数的小时、分钟和秒。例如，下午2点30分45秒表示为 <code>14:30:45</code>。</li></ul></li><li><p><strong>日期和时间的组合</strong>：</p><ul><li><code>YYYY-MM-DDThh:mm:ss</code>：日期和时间通过字母“T”连接。例如，2024年5月27日下午2点30分45秒表示为 <code>2024-05-27T14:30:45</code>。</li></ul></li><li><p><strong>时区表示</strong>：</p><ul><li><code>Z</code>：表示时间是以UTC（协调世界时）表示。例如，<code>2024-05-27T14:30:45Z</code>。</li><li><code>±hh:mm</code>：表示相对于UTC的偏移量。例如，东八区的时间可以表示为 <code>2024-05-</code></li></ul><p><img src="https://s2.loli.net/2024/05/28/Zj1BPSaDcnbWfiu.png" alt="下载"></p></li></ol><h5 id="什么是-GMT？"><a href="#什么是-GMT？" class="headerlink" title="什么是 GMT？"></a>什么是 GMT？</h5><p>GMT（Greenwich Mean Time，格林尼治标准时间）是指通过位于英国伦敦的皇家格林尼治天文台测定的时间。GMT 是全球统一的时间基准，用于定义世界各地的时间。它曾是国际标准时间，但现在更多使用的是 UTC（协调世界时），两者在日常使用中通常被认为是等价的。</p><h5 id="相对于-GMT-的偏移量"><a href="#相对于-GMT-的偏移量" class="headerlink" title="相对于 GMT 的偏移量"></a>相对于 GMT 的偏移量</h5><p>相对于 GMT 的偏移量（GMT offset）表示一个地区的本地时间与 GMT 之间的时差。偏移量通常以小时或分钟为单位，可以是正数也可以是负数。例如：</p><ul><li><strong>UTC+8</strong>：表示当地时间比 GMT 快 8 小时。这适用于像中国这样的国家。</li><li><strong>UTC-5</strong>：表示当地时间比 GMT 慢 5 小时。这适用于美国东部标准时间。</li></ul><h5 id="GMT-与-UTC"><a href="#GMT-与-UTC" class="headerlink" title="GMT 与 UTC"></a>GMT 与 UTC</h5><p><strong>GMT（格林尼治标准时间）</strong> 和 <strong>UTC（协调世界时）</strong> 通常被用来表示世界时间的标准，但二者略有不同：</p><ul><li><strong>GMT</strong>：格林尼治标准时间，是指通过位于英国伦敦的格林尼治天文台的时间。这是一种历史标准，通常被认为等同于UTC。</li><li><strong>UTC</strong>：协调世界时，是基于原子钟的时间标准，精度更高。UTC 是现代国际时间标准。</li></ul><h5 id="具体时间实例"><a href="#具体时间实例" class="headerlink" title="具体时间实例"></a>具体时间实例</h5><p>假设当前的 GMT 时间是 2024 年 5 月 27 日 12:00:00（中午 12 点）。</p><ul><li>在北京（UTC+8），当地时间是 2024 年 5 月 27 日 20:00:00（晚上 8 点）。</li><li>在纽约（UTC-5），当地时间是 2024 年 5 月 27 日 07:00:00（早上 7 点）。</li></ul><p><img src="https://s2.loli.net/2024/05/28/RiXWBKvckgdVPUt.jpg" alt="What is gmt time zone? - Yoors"></p><h4 id="全局缓存的时间字符串"><a href="#全局缓存的时间字符串" class="headerlink" title="全局缓存的时间字符串"></a><strong>全局缓存的时间字符串</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_err_log_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_log_time;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_http_log_iso8601;<br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ngx_str_t</span> ngx_cached_syslog_time;<br></code></pre></td></tr></table></figure><hr><h3 id="初始化时间缓存"><a href="#初始化时间缓存" class="headerlink" title="初始化时间缓存"></a>初始化时间缓存</h3><p> <strong><code>ngx_time_init</code> 的作用是初始化 Nginx 的时间缓存系统，为日志记录和时间格式化等操作提供预定义的时间格式。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_time_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 设置时间字符串的长度</span><br>    ngx_cached_err_log_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;1970/09/28 12:00:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置错误日志时间格式的字符串长度。</span><br>    ngx_cached_http_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Mon, 28 Sep 1970 06:00:00 GMT&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置HTTP头部时间格式的字符串长度。</span><br>    ngx_cached_http_log_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;28/Sep/1970:12:00:00 +0600&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置HTTP日志时间格式的字符串长度。</span><br>    ngx_cached_http_log_iso8601.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;1970-09-28T12:00:00+06:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置ISO 8601格式的时间字符串长度。</span><br>    ngx_cached_syslog_time.len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Sep 28 12:00:00&quot;</span>) - <span class="hljs-number">1</span>;<span class="hljs-comment">//设置系统日志时间格式的字符串长度。</span><br><br>    ngx_cached_time = &amp;cached_time[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 初始化全局时间缓存指针</span><br><br>    ngx_time_update(); <span class="hljs-comment">// 更新时间</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="更新时间缓存"><a href="#更新时间缓存" class="headerlink" title="更新时间缓存"></a>更新时间缓存</h4><p><strong><code>ngx_time_update</code> 函数用于更新 Nginx 的时间缓存。这个函数会获取当前的时间，将其转换为多种格式，并缓存起来，以便在日志记录和其他需要时间的地方高效使用。通过缓存时间，可以减少频繁调用系统时间获取函数的开销，提高系统性能。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_time_update</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    u_char          *p0, *p1, *p2, *p3, *p4;<br>    <span class="hljs-type">ngx_tm_t</span>         tm, gmt;<br>    <span class="hljs-type">time_t</span>           sec;<br>    <span class="hljs-type">ngx_uint_t</span>       msec;<br>    <span class="hljs-type">ngx_time_t</span>      *tp;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>   <span class="hljs-title">tv</span>;</span><br><br>    <span class="hljs-comment">// 尝试加锁，确保线程安全</span><br>    <span class="hljs-keyword">if</span> (!ngx_trylock(&amp;ngx_time_lock)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前时间</span><br>    ngx_gettimeofday(&amp;tv);<br><br>    sec = tv.tv_sec; <span class="hljs-comment">// 秒</span><br>    msec = tv.tv_usec / <span class="hljs-number">1000</span>; <span class="hljs-comment">// 毫秒</span><br><br>    ngx_current_msec = ngx_monotonic_time(sec, msec); <span class="hljs-comment">// 获取单调时间（毫秒）</span><br><br>    tp = &amp;cached_time[slot];<br><br>    <span class="hljs-comment">// 如果秒数没有变化，只更新毫秒值并解锁返回</span><br>    <span class="hljs-keyword">if</span> (tp-&gt;sec == sec) &#123;<br>        tp-&gt;msec = msec;<br>        ngx_unlock(&amp;ngx_time_lock);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新缓存槽位</span><br>    <span class="hljs-keyword">if</span> (slot == NGX_TIME_SLOTS - <span class="hljs-number">1</span>) &#123;<br>        slot = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        slot++;<br>    &#125;<br><br>    tp = &amp;cached_time[slot];<br><br>    tp-&gt;sec = sec; <span class="hljs-comment">// 更新秒</span><br>    tp-&gt;msec = msec; <span class="hljs-comment">// 更新毫秒</span><br><br>    <span class="hljs-comment">// 将时间转换为 GMT 时间</span><br>    ngx_gmtime(sec, &amp;gmt);<br><br>    <span class="hljs-comment">// 更新 HTTP 时间缓存</span><br>    p0 = &amp;cached_http_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p0, <span class="hljs-string">&quot;%s, %02d %s %4d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,<br>                       months[gmt.ngx_tm_mon - <span class="hljs-number">1</span>], gmt.ngx_tm_year,<br>                       gmt.ngx_tm_hour, gmt.ngx_tm_min, gmt.ngx_tm_sec);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_GETTIMEZONE)</span><br><br>    tp-&gt;gmtoff = ngx_gettimezone(); <span class="hljs-comment">// 获取时区偏移量</span><br>    ngx_gmtime(sec + tp-&gt;gmtoff * <span class="hljs-number">60</span>, &amp;tm); <span class="hljs-comment">// 计算本地时间</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (NGX_HAVE_GMTOFF)</span><br><br>    ngx_localtime(sec, &amp;tm); <span class="hljs-comment">// 获取本地时间</span><br>    cached_gmtoff = (<span class="hljs-type">ngx_int_t</span>) (tm.ngx_tm_gmtoff / <span class="hljs-number">60</span>);<br>    tp-&gt;gmtoff = cached_gmtoff; <span class="hljs-comment">// 更新时区偏移量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    ngx_localtime(sec, &amp;tm); <span class="hljs-comment">// 获取本地时间</span><br>    cached_gmtoff = ngx_timezone(tm.ngx_tm_isdst); <span class="hljs-comment">// 计算时区</span><br>    tp-&gt;gmtoff = cached_gmtoff; <span class="hljs-comment">// 更新时区偏移量</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 更新错误日志时间缓存</span><br>    p1 = &amp;cached_err_log_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p1, <span class="hljs-string">&quot;%4d/%02d/%02d %02d:%02d:%02d&quot;</span>,<br>                       tm.ngx_tm_year, tm.ngx_tm_mon,<br>                       tm.ngx_tm_mday, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec);<br><br>    <span class="hljs-comment">// 更新 HTTP 日志时间缓存</span><br>    p2 = &amp;cached_http_log_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p2, <span class="hljs-string">&quot;%02d/%s/%d:%02d:%02d:%02d %c%02i%02i&quot;</span>,<br>                       tm.ngx_tm_mday, months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       tm.ngx_tm_year, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec,<br>                       tp-&gt;gmtoff &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-string">&#x27;+&#x27;</span>,<br>                       ngx_abs(tp-&gt;gmtoff / <span class="hljs-number">60</span>), ngx_abs(tp-&gt;gmtoff % <span class="hljs-number">60</span>));<br><br>    <span class="hljs-comment">// 更新 ISO8601 格式的时间缓存</span><br>    p3 = &amp;cached_http_log_iso8601[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p3, <span class="hljs-string">&quot;%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i&quot;</span>,<br>                       tm.ngx_tm_year, tm.ngx_tm_mon,<br>                       tm.ngx_tm_mday, tm.ngx_tm_hour,<br>                       tm.ngx_tm_min, tm.ngx_tm_sec,<br>                       tp-&gt;gmtoff &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;-&#x27;</span> : <span class="hljs-string">&#x27;+&#x27;</span>,<br>                       ngx_abs(tp-&gt;gmtoff / <span class="hljs-number">60</span>), ngx_abs(tp-&gt;gmtoff % <span class="hljs-number">60</span>));<br><br>    <span class="hljs-comment">// 更新系统日志时间缓存</span><br>    p4 = &amp;cached_syslog_time[slot][<span class="hljs-number">0</span>];<br>    (<span class="hljs-type">void</span>) ngx_sprintf(p4, <span class="hljs-string">&quot;%s %2d %02d:%02d:%02d&quot;</span>,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>], tm.ngx_tm_mday,<br>                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);<br><br>    <span class="hljs-comment">// 内存屏障，确保写操作的顺序性</span><br>    ngx_memory_barrier();<br><br>    <span class="hljs-comment">// 更新全局时间缓存指针</span><br>    ngx_cached_time = tp;<br>    ngx_cached_http_time.data = p0;<br>    ngx_cached_err_log_time.data = p1;<br>    ngx_cached_http_log_time.data = p2;<br>    ngx_cached_http_log_iso8601.data = p3;<br>    ngx_cached_syslog_time.data = p4;<br><br>    <span class="hljs-comment">// 解锁</span><br>    ngx_unlock(&amp;ngx_time_lock);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="格式化转换"><a href="#格式化转换" class="headerlink" title="格式化转换"></a>格式化转换</h5><p><strong><code>ngx_gmtime</code> 函数的作用是将一个 <code>time_t</code> 类型的时间值转换为一个 <code>ngx_tm_t</code> 结构体，该结构体包含人类可读的时间信息（例如年、月、日、小时、分钟和秒）。该函数类似于标准库中的 <code>gmtime</code> 函数，但进行了专门的实现和优化，以满足 Nginx 的特定需求。</strong></p><blockquote><p><code>time_t</code> 是一种在标准 C 库中定义的类型，用于表示日历时间。通常，它表示从 1970 年 1 月 1 日 00:00:00 UTC（称为 Unix 纪元）以来经过的秒数。具体的实现可以是一个整数或一个浮点数，取决于平台。</p></blockquote><blockquote><p>在 Nginx 中，<code>time_t</code> 通常用于存储秒级精度的时间戳。<code>ngx_time_t</code> 是一个自定义的时间结构体，扩展了 <code>time_t</code> 的功能，以包含毫秒和 GMT 偏移量等信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_gmtime</span><span class="hljs-params">(<span class="hljs-type">time_t</span> t, <span class="hljs-type">ngx_tm_t</span> *tp)</span> &#123;<br>    <span class="hljs-type">ngx_int_t</span>   yday;<br>    <span class="hljs-type">ngx_uint_t</span>  sec, min, hour, mday, mon, year, wday, days, leap;<br><br>    <span class="hljs-comment">// 该计算仅适用于正的 time_t 值</span><br>    <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) &#123;<br>        t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    days = t / <span class="hljs-number">86400</span>; <span class="hljs-comment">// 计算总天数</span><br>    sec = t % <span class="hljs-number">86400</span>;  <span class="hljs-comment">// 计算一天中的秒数</span><br><br>    <span class="hljs-comment">// 支持的最大日期为9999年12月31日23:59:59</span><br>    <span class="hljs-keyword">if</span> (days &gt; <span class="hljs-number">2932896</span>) &#123;<br>        days = <span class="hljs-number">2932896</span>;<br>        sec = <span class="hljs-number">86399</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1970年1月1日是星期四</span><br>    wday = (<span class="hljs-number">4</span> + days) % <span class="hljs-number">7</span>;<br><br>    hour = sec / <span class="hljs-number">3600</span>; <span class="hljs-comment">// 计算小时</span><br>    sec %= <span class="hljs-number">3600</span>;<br>    min = sec / <span class="hljs-number">60</span>;    <span class="hljs-comment">// 计算分钟</span><br>    sec %= <span class="hljs-number">60</span>;         <span class="hljs-comment">// 计算秒</span><br><br>    <span class="hljs-comment">// 基于高斯公式的算法，详见 src/core/ngx_parse_time.c</span><br>    days = days - (<span class="hljs-number">31</span> + <span class="hljs-number">28</span>) + <span class="hljs-number">719527</span>; <span class="hljs-comment">// 自公元前1年3月1日以来的天数</span><br><br>    <span class="hljs-comment">// 计算年份，公式中调整了2天以处理某些年份的3月1日</span><br>    year = (days + <span class="hljs-number">2</span>) * <span class="hljs-number">400</span> / (<span class="hljs-number">365</span> * <span class="hljs-number">400</span> + <span class="hljs-number">100</span> - <span class="hljs-number">4</span> + <span class="hljs-number">1</span>);<br><br>    yday = days - (<span class="hljs-number">365</span> * year + year / <span class="hljs-number">4</span> - year / <span class="hljs-number">100</span> + year / <span class="hljs-number">400</span>);<br><br>    <span class="hljs-comment">// 处理负的 yday 值（闰年）</span><br>    <span class="hljs-keyword">if</span> (yday &lt; <span class="hljs-number">0</span>) &#123;<br>        leap = (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) &amp;&amp; (year % <span class="hljs-number">100</span> || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>));<br>        yday = <span class="hljs-number">365</span> + leap + yday;<br>        year--;<br>    &#125;<br><br>    <span class="hljs-comment">// 将 yday 映射到月份的经验公式</span><br>    mon = (yday + <span class="hljs-number">31</span>) * <span class="hljs-number">10</span> / <span class="hljs-number">306</span>;<br><br>    <span class="hljs-comment">// 计算月之前的天数的高斯公式</span><br>    mday = yday - (<span class="hljs-number">367</span> * mon / <span class="hljs-number">12</span> - <span class="hljs-number">30</span>) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (yday &gt;= <span class="hljs-number">306</span>) &#123;<br>        year++;<br>        mon -= <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">// Win32 SYSTEMTIME 没有 yday</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mon += <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// Win32 SYSTEMTIME 没有 yday</span><br>    &#125;<br><br>    <span class="hljs-comment">// 设置 tp 结构体的各个字段</span><br>    tp-&gt;ngx_tm_sec = (<span class="hljs-type">ngx_tm_sec_t</span>) sec;<br>    tp-&gt;ngx_tm_min = (<span class="hljs-type">ngx_tm_min_t</span>) min;<br>    tp-&gt;ngx_tm_hour = (<span class="hljs-type">ngx_tm_hour_t</span>) hour;<br>    tp-&gt;ngx_tm_mday = (<span class="hljs-type">ngx_tm_mday_t</span>) mday;<br>    tp-&gt;ngx_tm_mon = (<span class="hljs-type">ngx_tm_mon_t</span>) mon;<br>    tp-&gt;ngx_tm_year = (<span class="hljs-type">ngx_tm_year_t</span>) year;<br>    tp-&gt;ngx_tm_wday = (<span class="hljs-type">ngx_tm_wday_t</span>) wday;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置预定时间点"><a href="#设置预定时间点" class="headerlink" title="设置预定时间点"></a>设置预定时间点</h3><p>计算下一个特定时间点的时间戳。给定一个时间戳 <code>when</code>，函数根据当前时间计算出下一个 <code>when</code> 所表示的时分秒时间，然后转换为时间戳。如果下一个时间点比当前时间晚，则返回该时间点的时间戳；否则，将日期加一，再次尝试计算下一个时间点的时间戳，直到计算成功或者达到某种错误条件。</p><p>它通常用于需要在特定时间执行某些任务的情况下，例如定时任务、定时器等场景。在这些场景中，我们可能需要计算下一个执行时间点，以便安排下一次的任务执行。</p><ul><li><strong>定时任务调度器：</strong> 在一个定时任务调度器中，可能会有很多任务需要在特定的时间点执行，这时就可以使用这个函数来计算下一个执行时间点。</li><li><strong>定时器：</strong> 在网络编程中，有时候需要设置定时器来执行一些操作，比如超时处理、定时发送心跳等，这时就可以使用这个函数来计算下一个超时时间点。</li><li><strong>计划任务管理器：</strong> 在系统中可能会有一些计划任务需要按照预定的时间执行，这时就可以使用这个函数来计算下一个执行时间点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">time_t</span><br><span class="hljs-title function_">ngx_next_time</span><span class="hljs-params">(<span class="hljs-type">time_t</span> when)</span><br>&#123;<br>    <span class="hljs-type">time_t</span>     now, next;   <span class="hljs-comment">// 当前时间和下一个时间</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span>  <span class="hljs-title">tm</span>;</span>          <span class="hljs-comment">// 结构体 tm 用于存储时间的分解部分</span><br><br>    now = ngx_time();       <span class="hljs-comment">// 获取当前时间</span><br><br>    ngx_libc_localtime(now, &amp;tm);  <span class="hljs-comment">// 将当前时间转换为本地时间，存储在结构体 tm 中</span><br><br>    <span class="hljs-comment">// 计算下一个时间的小时、分钟和秒</span><br>    tm.tm_hour = (<span class="hljs-type">int</span>) (when / <span class="hljs-number">3600</span>);<br>    when %= <span class="hljs-number">3600</span>;<br>    tm.tm_min = (<span class="hljs-type">int</span>) (when / <span class="hljs-number">60</span>);<br>    tm.tm_sec = (<span class="hljs-type">int</span>) (when % <span class="hljs-number">60</span>);<br><br>    <span class="hljs-comment">// 将结构体 tm 转换为 time_t 类型的时间，即计算下一个时间的时间戳</span><br>    next = mktime(&amp;tm);<br><br>    <span class="hljs-comment">// 如果 mktime() 返回 -1，表示转换失败，返回 -1 表示错误</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个时间大于当前时间，则返回下一个时间</span><br>    <span class="hljs-keyword">if</span> (next - now &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果下一个时间小于或等于当前时间，说明已经过了今天的设定时间，需要设定为明天的设定时间</span><br>    tm.tm_mday++;   <span class="hljs-comment">// 将日期加 1</span><br><br>    <span class="hljs-comment">/* mktime() should normalize a date (Jan 32, etc) */</span><br>    <span class="hljs-comment">// 再次尝试计算下一个时间</span><br>    next = mktime(&amp;tm);<br><br>    <span class="hljs-comment">// 如果计算成功，返回下一个时间的时间戳，否则返回 -1 表示错误</span><br>    <span class="hljs-keyword">if</span> (next != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 返回 -1 表示错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="转换为-HTTP-时间格式和-Cookie-时间格式"><a href="#转换为-HTTP-时间格式和-Cookie-时间格式" class="headerlink" title="转换为 HTTP 时间格式和 Cookie 时间格式"></a>转换为 HTTP 时间格式和 Cookie 时间格式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<br><span class="hljs-title function_">ngx_http_time</span><span class="hljs-params">(u_char *buf, <span class="hljs-type">time_t</span> t)</span><br>&#123;<br>    <span class="hljs-type">ngx_tm_t</span>  tm;<br><br>    ngx_gmtime(t, &amp;tm); <span class="hljs-comment">// 将时间戳转换为格林尼治时间</span><br><br>    <span class="hljs-comment">// 将格林尼治时间格式化为 HTTP 时间格式，并写入缓冲区 buf 中</span><br>    <span class="hljs-keyword">return</span> ngx_sprintf(buf, <span class="hljs-string">&quot;%s, %02d %s %4d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[tm.ngx_tm_wday],<br>                       tm.ngx_tm_mday,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       tm.ngx_tm_year,<br>                       tm.ngx_tm_hour,<br>                       tm.ngx_tm_min,<br>                       tm.ngx_tm_sec);<br>&#125;<br><br>u_char *<br><span class="hljs-title function_">ngx_http_cookie_time</span><span class="hljs-params">(u_char *buf, <span class="hljs-type">time_t</span> t)</span><br>&#123;<br>    <span class="hljs-type">ngx_tm_t</span>  tm;<br><br>    ngx_gmtime(t, &amp;tm); <span class="hljs-comment">// 将时间戳转换为格林尼治时间</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Netscape 3.x does not understand 4-digit years at all and</span><br><span class="hljs-comment">     * 2-digit years more than &quot;37&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 根据规范格式化为 Cookie 时间格式，并写入缓冲区 buf 中</span><br>    <span class="hljs-keyword">return</span> ngx_sprintf(buf,<br>                       (tm.ngx_tm_year &gt; <span class="hljs-number">2037</span>) ?<br>                                         <span class="hljs-string">&quot;%s, %02d-%s-%d %02d:%02d:%02d GMT&quot;</span>:<br>                                         <span class="hljs-string">&quot;%s, %02d-%s-%02d %02d:%02d:%02d GMT&quot;</span>,<br>                       week[tm.ngx_tm_wday],<br>                       tm.ngx_tm_mday,<br>                       months[tm.ngx_tm_mon - <span class="hljs-number">1</span>],<br>                       (tm.ngx_tm_year &gt; <span class="hljs-number">2037</span>) ? tm.ngx_tm_year:<br>                                                 tm.ngx_tm_year % <span class="hljs-number">100</span>,<br>                       tm.ngx_tm_hour,<br>                       tm.ngx_tm_min,<br>                       tm.ngx_tm_sec);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_time()           ngx_cached_time-&gt;sec</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ngx_timeofday()      (ngx_time_t *) ngx_cached_time</span><br></code></pre></td></tr></table></figure><h2 id="Nginx定时器事件"><a href="#Nginx定时器事件" class="headerlink" title="Nginx定时器事件"></a>Nginx定时器事件</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Nginx 定时器事件是 Nginx 服务器中用于管理和处理事件的一种机制，用于实现异步、非阻塞的事件驱动模型。定时器事件主要用于处理与时间相关的事件，如超时事件、定时任务等。</p><p>在 Nginx 中，定时器事件通常用于以下几个方面：</p><ol><li><strong>超时处理</strong>：Nginx 服务器需要处理各种网络请求，如客户端的连接请求、HTTP 请求等。为了避免请求处理时间过长导致资源浪费或性能下降，Nginx 使用定时器事件来管理请求的超时时间，一旦超时，即可将相应的请求标记为超时状态，然后进行相应的处理。</li><li><strong>定时任务</strong>：Nginx 可以执行一些周期性的定时任务，如定时清理日志、定时刷新缓存等。这些定时任务通常也是通过定时器事件来实现的，通过设置一定的时间间隔，定期执行相应的任务。</li><li><strong>事件调度</strong>：定时器事件还用于管理和调度事件的执行顺序。在异步事件处理模型中，事件的触发和执行通常是异步的，而定时器事件可以确保事件按照预定的顺序进行执行，从而保证系统的稳定性和可靠性。</li></ol><p><img src="https://s2.loli.net/2024/05/28/nq19v5TPZf4LNXh.png" alt="image-20240528113151022"></p><h3 id="定时器数据结构"><a href="#定时器数据结构" class="headerlink" title="定时器数据结构"></a>定时器数据结构</h3><p>保存事件的结构体ngx_event_t 中有三个关于时间管理的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_event_s</span>&#123;</span><br>    ...<br>    <span class="hljs-comment">/* 标志位，为1表示当前事件已超时 */</span>  <br>    <span class="hljs-type">unsigned</span>         timedout:<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">/* 标志位，为1表示当前事件存在于由红黑树维护的定时器中 */</span>  <br>    <span class="hljs-type">unsigned</span>         timer_set:<span class="hljs-number">1</span>;  <br>    <span class="hljs-comment">/* 由红黑树维护的定时器 */</span>  <br>    <span class="hljs-type">ngx_rbtree_node_t</span>   timer; <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>Nginx 设置两个关于定时器的全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 所有定时器事件组成的红黑树 */</span><br>ngx_thread_volatile <span class="hljs-type">ngx_rbtree_t</span>  ngx_event_timer_rbtree;<br><span class="hljs-comment">/* 红黑树的哨兵节点 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">ngx_rbtree_node_t</span>          ngx_event_timer_sentinel;<br></code></pre></td></tr></table></figure><h3 id="初始化事件定时器"><a href="#初始化事件定时器" class="headerlink" title="初始化事件定时器"></a>初始化事件定时器</h3><p>初始化事件定时器，它使用红黑树作为底层数据结构来管理定时事件。函数通过调用 <code>ngx_rbtree_init</code> 初始化了一个红黑树 <code>ngx_event_timer_rbtree</code>，并指定了哨兵节点 <code>ngx_event_timer_sentinel</code>，以及用于比较的插入函数 <code>ngx_rbtree_insert_timer_value</code>。初始化成功后返回状态码 <code>NGX_OK</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 初始化事件定时器，使用红黑树作为底层数据结构。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     log: 日志对象指针，用于记录初始化过程中的日志信息。</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     NGX_OK: 初始化成功。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_int_t</span> <span class="hljs-title function_">ngx_event_timer_init</span><span class="hljs-params">(<span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 使用 ngx_rbtree_init 函数初始化红黑树 ngx_event_timer_rbtree，</span><br>    <span class="hljs-comment">// 第一个参数为红黑树的根节点，第二个参数为红黑树的哨兵节点，</span><br>    <span class="hljs-comment">// 第三个参数为插入时用于比较的函数指针 ngx_rbtree_insert_timer_value。</span><br>    ngx_rbtree_init(&amp;ngx_event_timer_rbtree, &amp;ngx_event_timer_sentinel,<br>                    ngx_rbtree_insert_timer_value);<br><br>    <span class="hljs-keyword">return</span> NGX_OK;  <span class="hljs-comment">// 返回初始化成功的状态码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加定时器事件"><a href="#添加定时器事件" class="headerlink" title="添加定时器事件"></a>添加定时器事件</h3><p>向事件定时器中添加指定事件，并设置事件的定时器时间。首先，计算了事件定时器的时间戳，然后判断事件的定时器是否已经设置，如果已经设置，则检查新旧定时器值之间的差异是否小于 <code>NGX_TIMER_LAZY_DELAY</code> 毫秒，如果是，则不添加新的定时器，直接返回，以减少红黑树操作的次数。如果差异超过了阈值，则先从红黑树中删除旧的定时器，然后设置事件的定时器时间，并将事件的定时器插入到红黑树中。最后，设置事件的定时器已被设置标志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 向事件定时器中添加指定事件，并设置定时器时间。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     ev: 待添加的事件指针。</span><br><span class="hljs-comment"> *     timer: 定时器的时间，以毫秒为单位。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_add_timer</span><span class="hljs-params">(<span class="hljs-type">ngx_event_t</span> *ev, <span class="hljs-type">ngx_msec_t</span> timer)</span><br>&#123;<br>    <span class="hljs-type">ngx_msec_t</span>      key;<br>    <span class="hljs-type">ngx_msec_int_t</span>  diff;<br><br>    <span class="hljs-comment">// 计算定时器的时间戳</span><br>    key = ngx_current_msec + timer;<br><br>    <span class="hljs-comment">// 如果事件的定时器已经设置，则检查新旧定时器值之间的差异是否小于 NGX_TIMER_LAZY_DELAY 毫秒，</span><br>    <span class="hljs-comment">// 如果是，则不添加新的定时器，直接返回，这样可以减少红黑树操作的次数，提高性能。</span><br>    <span class="hljs-keyword">if</span> (ev-&gt;timer_set) &#123;<br><br>        diff = (<span class="hljs-type">ngx_msec_int_t</span>) (key - ev-&gt;timer.key);<br><br>        <span class="hljs-keyword">if</span> (ngx_abs(diff) &lt; NGX_TIMER_LAZY_DELAY) &#123;<br>            <span class="hljs-comment">// 调试日志记录定时器更新情况。</span><br>            ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;event timer: %d, old: %M, new: %M&quot;</span>,<br>                           ngx_event_ident(ev-&gt;data), ev-&gt;timer.key, key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 从红黑树中删除旧的定时器。</span><br>        ngx_del_timer(ev);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置事件的定时器时间。</span><br>    ev-&gt;timer.key = key;<br><br>    <span class="hljs-comment">// 调试日志记录定时器添加情况。</span><br>    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                   <span class="hljs-string">&quot;event timer add: %d: %M:%M&quot;</span>,<br>                   ngx_event_ident(ev-&gt;data), timer, ev-&gt;timer.key);<br><br>    <span class="hljs-comment">// 将事件的定时器插入到红黑树中。</span><br>    ngx_rbtree_insert(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br>    <span class="hljs-comment">// 设置事件的定时器已被设置标志位。</span><br>    ev-&gt;timer_set = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除定时器事件"><a href="#删除定时器事件" class="headerlink" title="删除定时器事件"></a>删除定时器事件</h3><p>从事件定时器中移除指定的事件，并清除事件相关的定时器数据。首先，通过调试日志记录了被删除的事件的标识符和定时器键值。然后，通过调用 <code>ngx_rbtree_delete</code> 函数从红黑树中删除了事件的定时器。最后，如果编译时启用了调试模式（<code>NGX_DEBUG</code> 宏定义），则清空了事件的定时器节点的左、右、父节点，用于调试目的。最后，将事件的 <code>timer_set</code> 标志位设置为 0，表示事件的定时器已被移除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 从事件定时器中移除指定的事件，并清除事件相关的定时器数据。</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     ev: 待移除的事件指针。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_del_timer</span><span class="hljs-params">(<span class="hljs-type">ngx_event_t</span> *ev)</span><br>&#123;<br>    <span class="hljs-comment">// 记录调试日志，包括事件标识符和定时器键值。</span><br>    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                   <span class="hljs-string">&quot;event timer del: %d: %M&quot;</span>,<br>                   ngx_event_ident(ev-&gt;data), ev-&gt;timer.key);<br><br>    <span class="hljs-comment">// 从红黑树中删除事件的定时器。</span><br>    ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>    <span class="hljs-comment">// 清空事件的定时器节点的左、右、父节点，用于调试。</span><br>    ev-&gt;timer.left = <span class="hljs-literal">NULL</span>;<br>    ev-&gt;timer.right = <span class="hljs-literal">NULL</span>;<br>    ev-&gt;timer.parent = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 标记事件的定时器已被移除。</span><br>    ev-&gt;timer_set = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找最近定时器时间"><a href="#查找最近定时器时间" class="headerlink" title="查找最近定时器时间"></a>查找最近定时器时间</h3><p>查找事件定时器中最近的定时器时间。如果事件定时器为空，则返回无限大的定时器时间。否则，遍历红黑树找到最小的定时器节点，计算最近的定时器时间，并返回该时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 查找事件定时器中最近的定时器时间。</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     返回值为事件定时器中最近的定时器时间，以毫秒为单位。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">ngx_msec_t</span> <span class="hljs-title function_">ngx_event_find_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">ngx_msec_int_t</span>      timer;<br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *node, *root, *sentinel;<br><br>    <span class="hljs-comment">// 如果事件定时器为空，则返回无限大的定时器时间。</span><br>    <span class="hljs-keyword">if</span> (ngx_event_timer_rbtree.root == &amp;ngx_event_timer_sentinel) &#123;<br>        <span class="hljs-keyword">return</span> NGX_TIMER_INFINITE;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取事件定时器的根节点和哨兵节点。</span><br>    root = ngx_event_timer_rbtree.root;<br>    sentinel = ngx_event_timer_rbtree.sentinel;<br><br>    <span class="hljs-comment">// 查找事件定时器中最小的定时器节点。</span><br>    node = ngx_rbtree_min(root, sentinel);<br><br>    <span class="hljs-comment">// 计算最近的定时器时间。</span><br>    timer = (<span class="hljs-type">ngx_msec_int_t</span>) (node-&gt;key - ngx_current_msec);<br><br>    <span class="hljs-comment">// 返回最近的定时器时间，如果定时器时间小于等于0，则返回0。</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">ngx_msec_t</span>) (timer &gt; <span class="hljs-number">0</span> ? timer : <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理已经过期的事件定时器"><a href="#处理已经过期的事件定时器" class="headerlink" title="处理已经过期的事件定时器"></a>处理已经过期的事件定时器</h3><p>处理已经过期的事件定时器。它会遍历事件定时器红黑树，找到所有已经过期的事件定时器，并调用相应的事件处理函数来处理这些已经过期的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 处理已经过期的事件定时器。</span><br><span class="hljs-comment"> * 该函数会遍历事件定时器红黑树，处理所有已经过期的事件定时器。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ngx_event_expire_timers</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">ngx_event_t</span>        *ev;        <span class="hljs-comment">// 指向已经过期的事件</span><br>    <span class="hljs-type">ngx_rbtree_node_t</span>  *node, *root, *sentinel;  <span class="hljs-comment">// 用于遍历红黑树的节点指针</span><br><br>    sentinel = ngx_event_timer_rbtree.sentinel;  <span class="hljs-comment">// 获取红黑树的哨兵节点</span><br><br>    <span class="hljs-keyword">for</span> ( ;; ) &#123;<br>        root = ngx_event_timer_rbtree.root;  <span class="hljs-comment">// 获取红黑树的根节点</span><br><br>        <span class="hljs-comment">// 如果根节点是哨兵节点，表示事件定时器为空，直接返回</span><br>        <span class="hljs-keyword">if</span> (root == sentinel) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 查找红黑树中最小的定时器节点</span><br>        node = ngx_rbtree_min(root, sentinel);<br><br>        <span class="hljs-comment">// 如果最小节点的定时器时间大于当前时间，表示没有事件定时器过期，直接返回</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">ngx_msec_int_t</span>) (node-&gt;key - ngx_current_msec) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取对应的事件对象</span><br>        ev = ngx_rbtree_data(node, <span class="hljs-type">ngx_event_t</span>, timer);<br><br>        <span class="hljs-comment">// 打印调试日志，表示该事件定时器已经过期</span><br>        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ev-&gt;<span class="hljs-built_in">log</span>, <span class="hljs-number">0</span>,<br>                       <span class="hljs-string">&quot;event timer del: %d: %M&quot;</span>,<br>                       ngx_event_ident(ev-&gt;data), ev-&gt;timer.key);<br><br>        <span class="hljs-comment">// 从红黑树中删除该事件定时器</span><br>        ngx_rbtree_delete(&amp;ngx_event_timer_rbtree, &amp;ev-&gt;timer);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>        <span class="hljs-comment">// 清空定时器节点的左右子节点和父节点指针（仅在调试模式下有效）</span><br>        ev-&gt;timer.left = <span class="hljs-literal">NULL</span>;<br>        ev-&gt;timer.right = <span class="hljs-literal">NULL</span>;<br>        ev-&gt;timer.parent = <span class="hljs-literal">NULL</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// 将事件的 timer_set 标志位清零，表示该事件的定时器已经被删除</span><br>        ev-&gt;timer_set = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 设置事件的 timedout 标志位为1，表示该事件已经超时</span><br>        ev-&gt;timedout = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// 调用事件的 handler 处理函数，处理超时事件</span><br>        ev-&gt;handler(ev);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>利用缓存尽量减少调用系统函数以提高系统性能</li><li>Linux下的时间相关处理与程序在不同时区内运行的准确性</li><li>时间格式的转换</li></ul><p>限于篇幅限制，定时器事件执行与Nginx事件模块将会在下一篇中介绍。</p><hr>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx日志系统</title>
    <link href="/2023/02/10/Nginx%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/02/10/Nginx%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="我眼里的日志系统："><a href="#我眼里的日志系统：" class="headerlink" title="我眼里的日志系统："></a>我眼里的日志系统：</h2><p>发生异常—-&gt;将异常信息写入日志文件——&gt;退出</p><h2 id="Nginx实现的日志系统"><a href="#Nginx实现的日志系统" class="headerlink" title="Nginx实现的日志系统"></a>Nginx实现的日志系统</h2><p><img src="https://s2.loli.net/2024/05/27/L1OfGAd982xwKpQ.png" alt="image-20240527210455690"></p><h3 id="专门的日志数据结构"><a href="#专门的日志数据结构" class="headerlink" title="专门的日志数据结构"></a>专门的日志数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_log_s</span> &#123;</span><br>    <span class="hljs-type">ngx_uint_t</span>           log_level;            <span class="hljs-comment">// 日志级别，用于控制日志的详细程度（例如，DEBUG、INFO、ERROR 等）</span><br>    <span class="hljs-type">ngx_open_file_t</span>     *file;                 <span class="hljs-comment">// 指向打开文件的指针，表示日志输出的目标文件</span><br>    <span class="hljs-type">ngx_atomic_uint_t</span>    connection;           <span class="hljs-comment">// 记录当前连接数，使用原子类型以保证多线程环境下的安全性</span><br>    <span class="hljs-type">time_t</span>               disk_full_time;       <span class="hljs-comment">// 上次磁盘满时间，用于记录磁盘满的时间戳</span><br>    ngx_log_handler_pt   handler;              <span class="hljs-comment">// 自定义日志处理函数指针，用于特殊日志处理</span><br>    <span class="hljs-type">void</span>                *data;                 <span class="hljs-comment">// 任意类型的指针，可以存放与日志相关的附加数据</span><br>    ngx_log_writer_pt    writer;               <span class="hljs-comment">// 自定义日志写入函数指针，用于特殊日志写入方式</span><br>    <span class="hljs-type">void</span>                *wdata;                <span class="hljs-comment">// 任意类型的指针，可以存放与日志写入相关的附加数据</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 我们将 &quot;action&quot; 声明为 &quot;char *&quot; 类型，因为动作通常是静态字符串，</span><br><span class="hljs-comment">     * 如果使用 &quot;u_char *&quot; 类型，我们需要经常覆盖其类型。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">char</span>                *action;               <span class="hljs-comment">// 描述当前操作的字符串（例如，&quot;reading client request&quot;）</span><br>    <span class="hljs-type">ngx_log_t</span>           *next;                 <span class="hljs-comment">// 指向下一个日志对象的指针，用于支持链式日志记录</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Nginx的文件描述"><a href="#Nginx的文件描述" class="headerlink" title="Nginx的文件描述"></a>Nginx的文件描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ngx_open_file_s</span> &#123;</span><br>    <span class="hljs-type">ngx_fd_t</span>              fd;       <span class="hljs-comment">// 文件描述符</span><br>    <span class="hljs-type">ngx_str_t</span>             name;     <span class="hljs-comment">// 文件名</span><br><br>    <span class="hljs-type">void</span>                (*flush)(<span class="hljs-type">ngx_open_file_t</span> *file, <span class="hljs-type">ngx_log_t</span> *<span class="hljs-built_in">log</span>);  <span class="hljs-comment">// 刷新文件缓冲区函数指针</span><br>    <span class="hljs-type">void</span>                 *data;     <span class="hljs-comment">// 指向用户自定义数据的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="将错误日志进行分类—-等级数组"><a href="#将错误日志进行分类—-等级数组" class="headerlink" title="将错误日志进行分类—&gt;等级数组"></a>将错误日志进行分类—&gt;等级数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span> err_levels[] = &#123;<br>    ngx_null_string,<br>    ngx_string(<span class="hljs-string">&quot;emerg&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;alert&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;crit&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;error&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;warn&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;notice&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;info&quot;</span>),<br>    ngx_string(<span class="hljs-string">&quot;debug&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="初始化日志文件"><a href="#初始化日志文件" class="headerlink" title="初始化日志文件"></a>初始化日志文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_log_t</span> * <span class="hljs-title function_">ngx_log_init</span><span class="hljs-params">(u_char *prefix, u_char *error_log)</span><br>&#123;<br>    u_char  *p, *name;<br>    <span class="hljs-type">size_t</span>   nlen, plen;<br><br>    <span class="hljs-comment">// 初始化全局的 ngx_log 结构</span><br>    ngx_log.file = &amp;ngx_log_file;<br>    ngx_log.log_level = NGX_LOG_NOTICE;  <span class="hljs-comment">// 将默认日志级别设置为 NOTICE</span><br><br>    <span class="hljs-comment">// 如果未提供错误日志路径，则使用默认错误日志路径</span><br>    <span class="hljs-keyword">if</span> (error_log == <span class="hljs-literal">NULL</span>) &#123;<br>        error_log = (u_char *) NGX_ERROR_LOG_PATH;<br>    &#125;<br><br>    name = error_log;  <span class="hljs-comment">// 将提供的错误日志路径赋给 name</span><br>    nlen = ngx_strlen(name);  <span class="hljs-comment">// 获取错误日志路径的长度</span><br><br>    <span class="hljs-comment">// 如果错误日志路径为空，则使用标准错误输出（stderr）</span><br>    <span class="hljs-keyword">if</span> (nlen == <span class="hljs-number">0</span>) &#123;<br>        ngx_log_file.fd = ngx_stderr;<br>        <span class="hljs-keyword">return</span> &amp;ngx_log;<br>    &#125;<br><br>    p = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 如果错误日志路径不是绝对路径，则需要拼接前缀</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;:&#x27;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-keyword">if</span> (prefix) &#123;<br>            plen = ngx_strlen(prefix);  <span class="hljs-comment">// 计算前缀的长度</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> NGX_PREFIX</span><br>            prefix = (u_char *) NGX_PREFIX;<br>            plen = ngx_strlen(prefix);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>            plen = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (plen) &#123;<br>            name = <span class="hljs-built_in">malloc</span>(plen + nlen + <span class="hljs-number">2</span>);  <span class="hljs-comment">// 分配存储路径的内存空间</span><br>            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>            &#125;<br><br>            p = ngx_cpymem(name, prefix, plen);  <span class="hljs-comment">// 将前缀拷贝到路径中</span><br><br>            <span class="hljs-keyword">if</span> (!ngx_path_separator(*(p - <span class="hljs-number">1</span>))) &#123;  <span class="hljs-comment">// 如果前缀末尾没有路径分隔符，则添加</span><br>                *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>            &#125;<br><br>            ngx_cpystrn(p, error_log, nlen + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 将错误日志路径拷贝到路径末尾</span><br><br>            p = name;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 打开错误日志文件</span><br>    ngx_log_file.fd = ngx_open_file(name, NGX_FILE_APPEND,<br>                                    NGX_FILE_CREATE_OR_OPEN,<br>                                    NGX_FILE_DEFAULT_ACCESS);<br><br>    <span class="hljs-comment">// 如果打开文件失败，则输出错误日志到标准错误输出（stderr）</span><br>    <span class="hljs-keyword">if</span> (ngx_log_file.fd == NGX_INVALID_FILE) &#123;<br>        ngx_log_stderr(ngx_errno,<br>                       <span class="hljs-string">&quot;[alert] could not open error log file: &quot;</span><br>                       ngx_open_file_n <span class="hljs-string">&quot; \&quot;%s\&quot; failed&quot;</span>, name);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>        ngx_event_log(ngx_errno,<br>                       <span class="hljs-string">&quot;could not open error log file: &quot;</span><br>                       ngx_open_file_n <span class="hljs-string">&quot; \&quot;%s\&quot; failed&quot;</span>, name);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        ngx_log_file.fd = ngx_stderr;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放分配的内存</span><br>    <span class="hljs-keyword">if</span> (p) &#123;<br>        ngx_free(p);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;ngx_log;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置日志文件配置项"><a href="#设置日志文件配置项" class="headerlink" title="设置日志文件配置项"></a>设置日志文件配置项</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<br><span class="hljs-title function_">ngx_log_set_log</span><span class="hljs-params">(<span class="hljs-type">ngx_conf_t</span> *cf, <span class="hljs-type">ngx_log_t</span> **head)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>          *new_log;           <span class="hljs-comment">// 新日志结构体</span><br>    <span class="hljs-type">ngx_str_t</span>          *value, name;      <span class="hljs-comment">// 配置项值和名称</span><br>    <span class="hljs-type">ngx_syslog_peer_t</span>  *peer;            <span class="hljs-comment">// syslog 配置结构体</span><br><br>    <span class="hljs-comment">// 如果当前日志链表已存在且日志级别为0，表示已存在一个未指定级别的日志结构</span><br>    <span class="hljs-keyword">if</span> (*head != <span class="hljs-literal">NULL</span> &amp;&amp; (*head)-&gt;log_level == <span class="hljs-number">0</span>) &#123;<br>        new_log = *head;  <span class="hljs-comment">// 直接使用现有的日志结构</span><br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则，创建一个新的日志结构</span><br>        new_log = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_t</span>));<br>        <span class="hljs-keyword">if</span> (new_log == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果当前日志链表为空，则将新日志结构设置为链表的头部</span><br>        <span class="hljs-keyword">if</span> (*head == <span class="hljs-literal">NULL</span>) &#123;<br>            *head = new_log;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取配置项参数值</span><br>    value = cf-&gt;args-&gt;elts;<br><br>    <span class="hljs-comment">// 如果配置为输出到标准错误输出</span><br>    <span class="hljs-keyword">if</span> (ngx_strcmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;stderr&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        ngx_str_null(&amp;name);  <span class="hljs-comment">// 清空日志文件名</span><br>        cf-&gt;cycle-&gt;log_use_stderr = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记使用标准错误输出</span><br><br>        <span class="hljs-comment">// 打开标准错误输出文件</span><br>        new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;name);<br>        <span class="hljs-keyword">if</span> (new_log-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>    <span class="hljs-comment">// 如果配置为输出到内存</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_strncmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;memory:&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_DEBUG)</span><br>        <span class="hljs-type">size_t</span>                 size, needed;  <span class="hljs-comment">// 缓冲区大小及所需大小</span><br>        <span class="hljs-type">ngx_pool_cleanup_t</span>    *cln;          <span class="hljs-comment">// 清理回调结构体</span><br>        <span class="hljs-type">ngx_log_memory_buf_t</span>  *buf;         <span class="hljs-comment">// 内存日志缓冲区</span><br><br>        <span class="hljs-comment">// 去除&quot;memory:&quot;前缀</span><br>        value[<span class="hljs-number">1</span>].len -= <span class="hljs-number">7</span>;<br>        value[<span class="hljs-number">1</span>].data += <span class="hljs-number">7</span>;<br><br>        <span class="hljs-comment">// 计算所需的缓冲区大小</span><br>        needed = <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;MEMLOG  :&quot;</span> NGX_LINEFEED)<br>                 + cf-&gt;conf_file-&gt;file.name.len<br>                 + NGX_SIZE_T_LEN<br>                 + NGX_INT_T_LEN<br>                 + NGX_MAX_ERROR_STR;<br><br>        <span class="hljs-comment">// 解析配置的缓冲区大小</span><br>        size = ngx_parse_size(&amp;value[<span class="hljs-number">1</span>]);<br><br>        <span class="hljs-comment">// 如果解析失败或缓冲区太小，则返回错误</span><br>        <span class="hljs-keyword">if</span> (size == (<span class="hljs-type">size_t</span>) NGX_ERROR || size &lt; needed) &#123;<br>            ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="hljs-number">0</span>,<br>                               <span class="hljs-string">&quot;invalid buffer size \&quot;%V\&quot;&quot;</span>, &amp;value[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 分配内存日志缓冲区</span><br>        buf = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_memory_buf_t</span>));<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 分配缓冲区内存</span><br>        buf-&gt;start = ngx_pnalloc(cf-&gt;pool, size);<br>        <span class="hljs-keyword">if</span> (buf-&gt;start == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        buf-&gt;end = buf-&gt;start + size;<br><br>        <span class="hljs-comment">// 初始化缓冲区，记录日志文件名及行号</span><br>        buf-&gt;pos = ngx_slprintf(buf-&gt;start, buf-&gt;end, <span class="hljs-string">&quot;MEMLOG %uz %V:%ui%N&quot;</span>,<br>                                size, &amp;cf-&gt;conf_file-&gt;file.name,<br>                                cf-&gt;conf_file-&gt;line);<br><br>        <span class="hljs-comment">// 填充剩余空间为 &#x27; &#x27;</span><br>        ngx_memset(buf-&gt;pos, <span class="hljs-string">&#x27; &#x27;</span>, buf-&gt;end - buf-&gt;pos);<br><br>        <span class="hljs-comment">// 设置清理回调，用于释放内存日志缓冲区</span><br>        cln = ngx_pool_cleanup_add(cf-&gt;pool, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (cln == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        cln-&gt;data = new_log;<br>        cln-&gt;handler = ngx_log_memory_cleanup;<br><br>        <span class="hljs-comment">// 设置日志写入函数和写入数据</span><br>        new_log-&gt;writer = ngx_log_memory_writer;<br>        new_log-&gt;wdata = buf;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        ngx_conf_log_error(NGX_LOG_EMERG, cf, <span class="hljs-number">0</span>,<br>                           <span class="hljs-string">&quot;nginx was built without debug support&quot;</span>);<br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 如果配置为输出到syslog</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ngx_strncmp(value[<span class="hljs-number">1</span>].data, <span class="hljs-string">&quot;syslog:&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 分配syslog配置结构体</span><br>        peer = ngx_pcalloc(cf-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_syslog_peer_t</span>));<br>        <span class="hljs-keyword">if</span> (peer == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 处理syslog配置</span><br>        <span class="hljs-keyword">if</span> (ngx_syslog_process_conf(cf, peer) != NGX_CONF_OK) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置日志写入函数和写入数据</span><br>        new_log-&gt;writer = ngx_syslog_writer;<br>        new_log-&gt;wdata = peer;<br><br>    <span class="hljs-comment">// 其他情况，输出到指定文件</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 打开指定文件</span><br>        new_log-&gt;file = ngx_conf_open_file(cf-&gt;cycle, &amp;value[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span> (new_log-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置日志级别</span><br>    <span class="hljs-keyword">if</span> (ngx_log_set_levels(cf, new_log) != NGX_CONF_OK) &#123;<br>        <span class="hljs-keyword">return</span> NGX_CONF_ERROR;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果日志链表不为空，则将新日志插入到链表中</span><br>    <span class="hljs-keyword">if</span> (*head != new_log) &#123;<br>        ngx_log_insert(*head, new_log);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_CONF_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="格式化错误信息"><a href="#格式化错误信息" class="headerlink" title="格式化错误信息"></a>格式化错误信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> ngx_cdecl<br><span class="hljs-title function_">ngx_log_abort</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p;<br>    va_list   args;<br>    u_char    errstr[NGX_MAX_CONF_ERRSTR];<br><br>    <span class="hljs-comment">//使用va_start宏开始对可变参数的处理，并调用ngx_vsnprintf函数将格式化字符串fmt和可变参数args写入errstr数组中，生成格式化的错误信息</span><br>    va_start(args, fmt);<br>    p = ngx_vsnprintf(errstr, <span class="hljs-keyword">sizeof</span>(errstr) - <span class="hljs-number">1</span>, fmt, args);<br>    va_end(args);<br>   <span class="hljs-comment">//将生成的错误信息以NGX_LOG_ALERT级别写入到nginx的日志中</span><br>    ngx_log_error(NGX_LOG_ALERT, ngx_cycle-&gt;<span class="hljs-built_in">log</span>, err,<br>                  <span class="hljs-string">&quot;%*s&quot;</span>, p - errstr, errstr);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="错误码err转换为对应的错误描述"><a href="#错误码err转换为对应的错误描述" class="headerlink" title="错误码err转换为对应的错误描述"></a>错误码err转换为对应的错误描述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<br><span class="hljs-title function_">ngx_log_errno</span><span class="hljs-params">(u_char *buf, u_char *last, <span class="hljs-type">ngx_err_t</span> err)</span><br>&#123;<br>    <span class="hljs-comment">//首先函数进行了边界检查，确保在向缓冲区写入前还有足够的空间。如果缓冲区的剩余空间不足50个字节，就会留出一个空间用于放置错误码，然后在缓冲区的末尾写入三个点号&quot;...&quot;，以表示截断了部分错误信息。</span><br>    <span class="hljs-keyword">if</span> (buf &gt; last - <span class="hljs-number">50</span>) &#123;<br>        <span class="hljs-comment">/* leave a space for an error code */</span><br><br>        buf = last - <span class="hljs-number">50</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        *buf++ = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_WIN32)</span><br>    buf = ngx_slprintf(buf, last, ((<span class="hljs-type">unsigned</span>) err &lt; <span class="hljs-number">0x80000000</span>)<br>                                       ? <span class="hljs-string">&quot; (%d: &quot;</span> : <span class="hljs-string">&quot; (%Xd: &quot;</span>, err);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    buf = ngx_slprintf(buf, last, <span class="hljs-string">&quot; (%d: &quot;</span>, err);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//调用ngx_strerror函数将错误码转换为对应的错误描述，并将描述信息追加到缓冲区中</span><br>    buf = ngx_strerror(err, buf, last - buf);<br><br>    <span class="hljs-keyword">if</span> (buf &lt; last) &#123;<br>        *buf++ = <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> buf;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常信息首先输入到缓冲区"><a href="#异常信息首先输入到缓冲区" class="headerlink" title="异常信息首先输入到缓冲区"></a>异常信息首先输入到缓冲区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char * ngx_cdecl<br><span class="hljs-title function_">ngx_slprintf</span><span class="hljs-params">(u_char *buf, u_char *last, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p;<br>    va_list   args;<br><br>    va_start(args, fmt);<br>    p = ngx_vslprintf(buf, last, fmt, args);<br>    va_end(args);<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="打开-新建日志文件并插入日志链表"><a href="#打开-新建日志文件并插入日志链表" class="headerlink" title="打开&#x2F;新建日志文件并插入日志链表"></a>打开&#x2F;新建日志文件并插入日志链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_log_open_default</span><span class="hljs-params">(<span class="hljs-type">ngx_cycle_t</span> *cycle)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>  *<span class="hljs-built_in">log</span>;<br><br>    <span class="hljs-keyword">if</span> (ngx_log_get_file_log(&amp;cycle-&gt;new_log) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_OK;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cycle-&gt;new_log.log_level != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* there are some error logs, but no files */</span><br><br>        <span class="hljs-built_in">log</span> = ngx_pcalloc(cycle-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_log_t</span>));<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span> == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> NGX_ERROR;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* no error logs at all */</span><br>        <span class="hljs-built_in">log</span> = &amp;cycle-&gt;new_log;<br>    &#125;<br><br>    <span class="hljs-built_in">log</span>-&gt;log_level = NGX_LOG_ERR;<br><br>    <span class="hljs-built_in">log</span>-&gt;file = ngx_conf_open_file(cycle, &amp;cycle-&gt;error_log);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>-&gt;file == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> NGX_ERROR;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span> != &amp;cycle-&gt;new_log) &#123;<br>        ngx_log_insert(&amp;cycle-&gt;new_log, <span class="hljs-built_in">log</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取日志文件"><a href="#获取日志文件" class="headerlink" title="获取日志文件"></a>获取日志文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ngx_log_t</span> *<br><span class="hljs-title function_">ngx_log_get_file_log</span><span class="hljs-params">(<span class="hljs-type">ngx_log_t</span> *head)</span><br>&#123;<br>    <span class="hljs-type">ngx_log_t</span>  *<span class="hljs-built_in">log</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">log</span> = head; <span class="hljs-built_in">log</span>; <span class="hljs-built_in">log</span> = <span class="hljs-built_in">log</span>-&gt;next) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">log</span>-&gt;file != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">log</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="刷入磁盘"><a href="#刷入磁盘" class="headerlink" title="刷入磁盘"></a>刷入磁盘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将文本写入标准错误流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_write_stderr</span><span class="hljs-params">(<span class="hljs-type">char</span> *text)</span><br>&#123;<br>    (<span class="hljs-type">void</span>) ngx_write_fd(ngx_stderr, text, ngx_strlen(text));<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 将文本写入标准输出流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">ngx_write_stdout</span><span class="hljs-params">(<span class="hljs-type">char</span> *text)</span><br>&#123;<br>    (<span class="hljs-type">void</span>) ngx_write_fd(ngx_stdout, text, ngx_strlen(text));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 在指定文件描述符上写入数据</span><br><span class="hljs-comment"> * 参数：</span><br><span class="hljs-comment"> *     - fd：文件描述符</span><br><span class="hljs-comment"> *     - buf：待写入数据的缓冲区指针</span><br><span class="hljs-comment"> *     - n：待写入数据的字节数</span><br><span class="hljs-comment"> * 返回值：</span><br><span class="hljs-comment"> *     成功：返回写入的字节数</span><br><span class="hljs-comment"> *     失败：返回-1，并设置errno为对应的错误码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> ngx_inline <span class="hljs-type">ssize_t</span><br><span class="hljs-title function_">ngx_write_fd</span><span class="hljs-params">(<span class="hljs-type">ngx_fd_t</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> write(fd, buf, n);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="输入到控制台的功能"><a href="#输入到控制台的功能" class="headerlink" title="输入到控制台的功能"></a>输入到控制台的功能</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> ngx_cdecl<br><span class="hljs-title function_">ngx_log_stderr</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt, ...)</span><br>&#123;<br>    u_char   *p, *last;   <span class="hljs-comment">// 指向错误信息字符串的指针</span><br>    va_list   args;       <span class="hljs-comment">// 可变参数列表</span><br>    u_char    errstr[NGX_MAX_ERROR_STR];  <span class="hljs-comment">// 错误信息缓冲区</span><br><br>    last = errstr + NGX_MAX_ERROR_STR;  <span class="hljs-comment">// 缓冲区的末尾位置</span><br>    p = ngx_cpymem(errstr, <span class="hljs-string">&quot;nginx: &quot;</span>, <span class="hljs-number">7</span>);  <span class="hljs-comment">// 将固定的前缀拷贝到缓冲区</span><br>    va_start(args, fmt);  <span class="hljs-comment">// 初始化可变参数列表</span><br>    p = ngx_vslprintf(p, last, fmt, args);  <span class="hljs-comment">// 将格式化字符串和参数格式化到缓冲区</span><br>    va_end(args);  <span class="hljs-comment">// 结束可变参数列表</span><br><br>    <span class="hljs-comment">// 如果有错误码，将错误码添加到错误信息中</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        p = ngx_log_errno(p, last, err);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果错误信息超出缓冲区末尾，截断字符串</span><br>    <span class="hljs-keyword">if</span> (p &gt; last - NGX_LINEFEED_SIZE) &#123;<br>        p = last - NGX_LINEFEED_SIZE;<br>    &#125;<br><br>    ngx_linefeed(p);  <span class="hljs-comment">// 添加换行符</span><br><br>    <span class="hljs-comment">// 将错误信息输出到标准错误流</span><br>    (<span class="hljs-type">void</span>) ngx_write_console(ngx_stderr, errstr, p - errstr);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Nginx有关错误宏定义"><a href="#Nginx有关错误宏定义" class="headerlink" title="Nginx有关错误宏定义"></a>Nginx有关错误宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _ASM_GENERIC_ERRNO_BASE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EPERM 1<span class="hljs-comment">/* Operation not permitted */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOENT 2<span class="hljs-comment">/* No such file or directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ESRCH 3<span class="hljs-comment">/* No such process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EINTR 4<span class="hljs-comment">/* Interrupted system call */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EIO 5<span class="hljs-comment">/* I/O error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENXIO 6<span class="hljs-comment">/* No such device or address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>E2BIG 7<span class="hljs-comment">/* Argument list too long */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOEXEC 8<span class="hljs-comment">/* Exec format error */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EBADF 9<span class="hljs-comment">/* Bad file number */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ECHILD10<span class="hljs-comment">/* No child processes */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EAGAIN11<span class="hljs-comment">/* Try again */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOMEM12<span class="hljs-comment">/* Out of memory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EACCES13<span class="hljs-comment">/* Permission denied */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EFAULT14<span class="hljs-comment">/* Bad address */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTBLK15<span class="hljs-comment">/* Block device required */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EBUSY16<span class="hljs-comment">/* Device or resource busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EEXIST17<span class="hljs-comment">/* File exists */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EXDEV18<span class="hljs-comment">/* Cross-device link */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENODEV19<span class="hljs-comment">/* No such device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTDIR20<span class="hljs-comment">/* Not a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EISDIR21<span class="hljs-comment">/* Is a directory */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EINVAL22<span class="hljs-comment">/* Invalid argument */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENFILE23<span class="hljs-comment">/* File table overflow */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EMFILE24<span class="hljs-comment">/* Too many open files */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOTTY25<span class="hljs-comment">/* Not a typewriter */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ETXTBSY26<span class="hljs-comment">/* Text file busy */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EFBIG27<span class="hljs-comment">/* File too large */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ENOSPC28<span class="hljs-comment">/* No space left on device */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ESPIPE29<span class="hljs-comment">/* Illegal seek */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EROFS30<span class="hljs-comment">/* Read-only file system */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EMLINK31<span class="hljs-comment">/* Too many links */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EPIPE32<span class="hljs-comment">/* Broken pipe */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>EDOM33<span class="hljs-comment">/* Math argument out of domain of func */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>ERANGE34<span class="hljs-comment">/* Math result not representable */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="Nginx处理错误字符串"><a href="#Nginx处理错误字符串" class="headerlink" title="Nginx处理错误字符串"></a>Nginx处理错误字符串</h2><p>选择不同的方法来获取错误信息并将其复制到指定的缓冲区中。</p><ol><li>第一部分使用了<code>strerrordesc_np</code>函数，该函数在glibc 2.32中引入。它是异步信号安全的，可以直接使用它来获取系统错误信息，而无需复制错误消息。如果系统支持这个函数，就直接调用它获取错误信息。如果不支持，则使用预定义的<code>ngx_unknown_error</code>。</li><li>第二部分处理了不支持<code>strerrordesc_np</code>的情况，主要是为了兼容之前的版本。它首先初始化了一个错误消息列表，存储了系统中可能的错误消息。然后通过<code>strerror</code>函数获取每个错误码对应的错误消息，并将其存储在动态分配的内存中。这样，在需要获取错误信息时，就可以根据错误码直接在列表中查找对应的错误消息了。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span>   ngx_unknown_error = ngx_string(<span class="hljs-string">&quot;Unknown error&quot;</span>);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_HAVE_STRERRORDESC_NP)</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * strerrordesc_np()函数是在glibc 2.32中引入的，是异步信号安全的。</span><br><span class="hljs-comment"> * 这使得可以直接使用它，而不需要复制错误消息。</span><br><span class="hljs-comment"> */</span><br><br>u_char *<br><span class="hljs-title function_">ngx_strerror</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, u_char *errstr, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">size_t</span>       len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>  *msg;<br><br>    msg = strerrordesc_np(err);<br><br>    <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>) &#123;<br>        msg = (<span class="hljs-type">char</span> *) ngx_unknown_error.data;<br>        len = ngx_unknown_error.len;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        len = ngx_strlen(msg);<br>    &#125;<br><br>    size = ngx_min(size, len);<br><br>    <span class="hljs-keyword">return</span> ngx_cpymem(errstr, msg, size);<br>&#125;<br><br><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_strerror_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> NGX_OK;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * strerror()消息被复制，原因是：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1) strerror()和strerror_r()函数不是异步信号安全的，</span><br><span class="hljs-comment"> *    因此不能在信号处理程序中使用；</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2) 可以使用直接的sys_errlist[]数组来替代这些函数，</span><br><span class="hljs-comment"> *    但Linux链接器会警告其使用：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * warning: `sys_errlist&#x27; is deprecated; use `strerror&#x27; or `strerror_r&#x27; instead</span><br><span class="hljs-comment"> * warning: `sys_nerr&#x27; is deprecated; use `strerror&#x27; or `strerror_r&#x27; instead</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *    这会导致错误的bug报告。</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">ngx_str_t</span>  *ngx_sys_errlist;<br><span class="hljs-type">static</span> <span class="hljs-type">ngx_err_t</span>   ngx_first_error;<br><span class="hljs-type">static</span> <span class="hljs-type">ngx_err_t</span>   ngx_last_error;<br><br>u_char *<br><span class="hljs-title function_">ngx_strerror</span><span class="hljs-params">(<span class="hljs-type">ngx_err_t</span> err, u_char *errstr, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>    <span class="hljs-type">ngx_str_t</span>  *msg;<br><br>    <span class="hljs-keyword">if</span> (err &gt;= ngx_first_error &amp;&amp; err &lt; ngx_last_error) &#123;<br>        msg = &amp;ngx_sys_errlist[err - ngx_first_error];<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        msg = &amp;ngx_unknown_error;<br>    &#125;<br><br>    size = ngx_min(size, msg-&gt;len);<br><br>    <span class="hljs-keyword">return</span> ngx_cpymem(errstr, msg-&gt;data, size);<br>&#125;<br><br><span class="hljs-type">ngx_int_t</span><br><span class="hljs-title function_">ngx_strerror_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span>       *msg;<br>    u_char     *p;<br>    <span class="hljs-type">size_t</span>      len;<br>    <span class="hljs-type">ngx_err_t</span>   err;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (NGX_SYS_NERR)</span><br>    ngx_first_error = <span class="hljs-number">0</span>;<br>    ngx_last_error = NGX_SYS_NERR;<br><br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> (EPERM &gt; 1000 &amp;&amp; EPERM &lt; 0x7fffffff - 1000)</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果错误数未知，并且EPERM错误代码有很大但合理的值，</span><br><span class="hljs-comment">     * 则根据strerror()返回的错误消息从EPERM开始猜测可能的错误代码。</span><br><span class="hljs-comment">     * 特别是，这包括GNU/Hurd，其错误从0x40000001开始。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-keyword">for</span> (err = EPERM; err &gt; EPERM - <span class="hljs-number">1000</span>; err--) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_first_error = err;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (err = EPERM; err &lt; EPERM + <span class="hljs-number">1000</span>; err++) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_last_error = err + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 如果错误数未知，则根据strerror()返回的错误消息猜测错误数。</span><br><span class="hljs-comment">     */</span><br><br>    ngx_first_error = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (err = <span class="hljs-number">0</span>; err &lt; <span class="hljs-number">1000</span>; err++) &#123;<br>        ngx_set_errno(<span class="hljs-number">0</span>);<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (errno == EINVAL<br>            || msg == <span class="hljs-literal">NULL</span><br>            || <span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">&quot;Unknown error&quot;</span>, <span class="hljs-number">13</span>) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ngx_last_error = err + <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ngx_strerror()在此阶段尚不准备工作，因此使用malloc()，</span><br><span class="hljs-comment">     * 并使用strerror()记录可能的错误。</span><br><span class="hljs-comment">     */</span><br><br>    len = (ngx_last_error - ngx_first_error) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">ngx_str_t</span>);<br><br>    ngx_sys_errlist = <span class="hljs-built_in">malloc</span>(len);<br>    <span class="hljs-keyword">if</span> (ngx_sys_errlist == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">goto</span> failed;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (err = ngx_first_error; err &lt; ngx_last_error; err++) &#123;<br>        msg = strerror(err);<br><br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">NULL</span>) &#123;<br>            ngx_sys_errlist[err - ngx_first_error] = ngx_unknown_error;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        len = ngx_strlen(msg);<br><br>        p = <span class="hljs-built_in">malloc</span>(len);<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">goto</span> failed;<br>        &#125;<br><br>        ngx_memcpy(p, msg, len);<br>        ngx_sys_errlist[err - ngx_first_error].len = len;<br>        ngx_sys_errlist[err - ngx_first_error].data = p;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NGX_OK;<br><br>failed:<br><br>    err = errno;<br>    ngx_log_stderr(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;malloc(%uz) failed (%d: %s)&quot;</span>, len, err, strerror(err));<br><br>    <span class="hljs-keyword">return</span> NGX_ERROR;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>封装专门的日志和文件数据结构</li><li>分类异常信息</li><li>先读入缓冲区后刷入磁盘</li><li>日志链表设计以及日志配置设计</li><li>格式化输入输出</li><li>刷入磁盘</li></ol>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2023/02/10/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2023/02/10/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><h2 id="1-数据链路层"><a href="#1-数据链路层" class="headerlink" title="1.数据链路层"></a>1.数据链路层</h2><p>就像上一节物理层所总结的那样，物理层通过各种传输介质（例如光纤、铜线等）实现了数据的物理传输。</p><p>而链路层处理的是相邻节点之间的数据传输问题，它利用物理层提供的物理介质提供了面向连接的通信，确保数据帧在相邻节点之间可靠传输。</p><p><em>想象一辆货车在运输货物的过程中，可以将其比作计算机网络中的数据传输过程。在这个类比中：</em></p><p><em>物理层就好比货车所使用的公路系统，它负责实际的物理传输。就像货车需要依靠公路系统才能将货物从一个地方运送到另一个地方一样。</em></p><p><em>链路层可以比作货车司机，负责将货物从一个地点运送到另一个地点，并与其他司机协调交接。</em></p><p><em>网络层就相当于货物的发货单，它规定了货物的最终目的地，并指示货车司机如何到达目的地。</em></p><h2 id="2-链路层所提供的服务？"><a href="#2-链路层所提供的服务？" class="headerlink" title="2.链路层所提供的服务？"></a>2.链路层所提供的服务？</h2><p>尽管任一链路层的基本服务都是将数据报通过单一通信链路从一个结点移动到相邻结 点，但所提供的服务细节能够随着链路层协议的不同而变化 链路层协议能够提供的可能服务包括:</p><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1,封装成帧"></a><strong>1,封装成帧</strong></h3><p>在链路层，数据被封装成帧以便在物理介质上传输。这个过程大致可以分为以下几个步骤：</p><p>1，添加帧起始标志：在开始传输数据之前，发送端会向数据包添加帧起始标志，以告知接收端一个新的帧即将到来。</p><p>2，加入地址信息：在大多数情况下，在以太网中，目标 MAC 地址和源 MAC 地址会被添加到帧的首部，这样接收端就能知道帧的目的地和发送源。</p><p>3，加入长度&#x2F;类型：在以太网中，接下来的字段包含了表示数据包长度或者类型的信息，这有助于接收端正确地解析帧。</p><p>4，加入数据：数据包的实际内容会放在帧中，这可能是来自更高层的数据包，例如 IP 数据包。</p><p>5，加入校验：通常还会添加一些校验位，例如 CRC（循环冗余校验），用于帮助接收端检测并纠正传输过程中可能出现的错误。</p><ol><li>添加帧结束标志：最后，发送端会向帧添加一个结束标志，表明帧的发送已经完成。</li></ol><p><img src="https://pic3.zhimg.com/v2-906564c750f269554f2e7adea716d154_1440w.jpg" alt="img"></p><p><img src="https://pica.zhimg.com/v2-f148c317c2602381f39c6f09ae3a9ad4_1440w.jpg" alt="img"></p><h3 id="2-差错检测"><a href="#2-差错检测" class="headerlink" title="2,差错检测"></a>2,差错检测</h3><p>在链路层，差错检测和纠正通常是通过循环冗余校验（CRC）来实现的。下面是简要描述差错检测和纠正的过程：</p><p>1，发送端计算数据包的 CRC 值：在发送数据包之前，发送端会对数据包中的一些字段进行计算，生成一个 CRC 值。</p><p>2，CRC 值附加到数据包中：得到 CRC 值后，发送端将其附加到数据包的尾部，并发送给接收端。</p><p>3，接收端计算CRC值：接收端接收数据包后，会重新计算接收到的数据包的 CRC 值。</p><p>4，对比CRC值：接收端的计算结果与接收到的CRC值进行比较，如果两者不一致，则表示数据包可能已经损坏。</p><p><img src="https://pic1.zhimg.com/v2-e4fbc7702a9232f92ee6064e8817da5a_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-26a0917f2d483c7e4fc2774f239bd9de_1440w.jpg" alt="img"></p><p>注意传输差错：一类是最基本的比特差错，而另一类传输差错则更复杂些，这就是收到的帧并没有出现比特差错，但却出现了帧丢失、帧重复或帧失序。例如，发送方连续传送三个帧： [#1]-[#2]-[#3]。假定接收端收到的每一个帧都没有比特差错，但却出现下面的几种情况：</p><p>帧丢失:收到[#1]-<a href="%E4%B8%A2%E5%A4%B1%5B#2%5D">#3</a>。</p><p>帧重复:收到[#1]-[#2]-[#2]-<a href="%E6%94%B6%E5%88%B0%E4%B8%A4%E4%B8%AA%5B#2%5D">#3</a>。　　</p><p>帧失序：收到[#1]-[#3]-<a href="%E5%90%8E%E5%8F%91%E9%80%81%E7%9A%84%E5%B8%A7%E5%8F%8D%E8%80%8C%E5%85%88%E5%88%B0%E8%BE%BE%E4%BA%86%E6%8E%A5%E6%94%B6%E7%AB%AF%EF%BC%8C%E8%BF%99%E4%B8%8E%E4%B8%80%E8%88%AC%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E4%BC%A0%E8%BE%93%E6%A6%82%E5%BF%B5%E4%B8%8D%E4%B8%80%E6%A0%B7">#2</a>。　　</p><p>以上三种情况都属于“出现传输差错”，但都不是这些帧里有“比特差错”。帧丢失很容易理解。但出现帧重复和帧失序的情况则较为复杂，对这些问题我们现在不展开讨论。</p><p>我们应当明确，“无比特差错”与“无传输差错”并不是同样的概念。在数据链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。　</p><p>　我们知道，过去 OSI 的观点是：必须让数据链路层向上提供可靠传输。因此在 CRC检错的基础上，增加了帧编号、确认和重传机制。收到正确的帧就要向发送端发送确认。发送端在一定的期限内若没有收到对方的确认，就认为出现了差错，因而就进行重传，直到收到对方的确认为止。这种方法在历史上曾经起到很好的作用。但现在的通信线路的质量已经大大提高了，由通信链路质量不好引起差错的概率已经大大降低。因此，现在互联网就采取了区别对待的方法：　　</p><p>对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议(例如，运输层的 TCP 协议)来完成。　　</p><p>对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。实践证明，这样做可以提高通信效率，数据链路层协议都不是可靠传输的协议</p><h3 id="3-透明传输"><a href="#3-透明传输" class="headerlink" title="3,透明传输"></a>3,透明传输</h3><p>链路层透明传输是指在数据帧传输过程中，传输系统能够无歧义地处理各种数据，不会对数据内容进行解释或修改。这样的传输方式可以确保发送端和接收端之间的数据传输是可靠、准确的。下面是链路层透明传输的基本过程：</p><p>不进行数据解释或修改：在透明传输中，传输系统不会对传输的数据进行任何形式的解释或修改。无论数据的内容是什么，传输系统都会严格按照原始数据进行传输，确保数据的完整性和准确性。</p><p>数据格式不变：传输系统会严格遵循链路层协议规定的数据格式，不会因为数据内容的不同而进行调整。这意味着无论是文本、图像、音频还是其他类型的数据，在传输过程中都能得到正确的处理和传输。</p><p>透明传输技术：在实际应用中，透明传输通常会借助一些特定的技术来实现，比如使用特殊的编码方式来处理数据，以确保数据在传输过程中不会丢失或损坏。另外，还会采用一些差错检测和纠正的机制，以确保数据的可靠传输。</p><p>总的来说，链路层透明传输通过严格遵循原始数据格式、不进行解释或修改以及利用特定技术实现可靠传输等方式来确保传输过程中数据的准确性和完整性。</p><p>但请考虑这样一种情况：</p><p><img src="https://pica.zhimg.com/v2-9fb8e0fa232df49f2809c505f8e90f28_1440w.jpg" alt="img"></p><p>解决方法：</p><p>字节填充技术的基本原理是在需要填充的地方插入特定的填充字节，以确保传输的数据能够正确地被接收端解析，同时不影响实际数据内容的准确性。常见的字节填充技术包括</p><p>字符填充：</p><p>*<strong>在字符填充技术中，会在数据中出现特定的字符时，使用转义字符将其转义为另一个字符，从而确保数据传输的透明性。这样一来，接收端就可以根据转义字符来正确解析数据内容。*</strong></p><p><img src="https://pic4.zhimg.com/v2-5a93d63ba6718f3292ce911d9303e487_1440w.jpg" alt="img"></p><h2 id="3-网络链路分为哪几种类型？"><a href="#3-网络链路分为哪几种类型？" class="headerlink" title="3.网络链路分为哪几种类型？"></a>3.网络链路分为哪几种类型？</h2><p>3.1什么是点对点链路？</p><p>点对点链路是指在计算机网络中两个节点之间直接建立的通信链路。这种链路连接通常是一条物理线路或虚拟电路，用于直接连接两个设备，如两台计算机、路由器或交换机等。点对点链路不需要经过其他转发设备，数据可以直接在两个节点之间进行传输，因此具有较低的延迟和更高的带宽利用率。</p><h4 id="3-1-1PPP协议"><a href="#3-1-1PPP协议" class="headerlink" title="3.1.1PPP协议"></a>3.1.1PPP协议</h4><p>定义：</p><p>PPP（Point-to-Point Protocol，点对点协议）是一种数据链路层通信协议，用于在两个节点之间进行数据传输。它通常用于在数字通信线路上进行数据传输，如在拨号连接、DSL（数字用户线路）和ISDN（综合业务数字网）等网络环境中。PPP协议设计的初衷是为了提供简单、可靠的数据传输机制，并支持多种网络层协议的封装</p><p>特点（优点）：</p><p>建立连接：PPP允许两个节点之间建立连接以进行数据传输。它使用LCP链路控制协议）来协商并建立连接的参数，如数据压缩和认证方式等。</p><p>数据帧格式：PPP使用数据帧来封装传输的数据。数据帧包括标志字段、地址字段、控制字段、协议字段、数据字段和校验字段等部分，以便在通信中区分各个部分和进行差错检测。</p><p>多协议支持：PPP协议本身不限定传输的数据类型，而是通过NCP（网络控制协议）来支持多种网络层协议的封装，如IP、IPX和苹果Talk等，使得PPP可以在不同的网络环境中使用。</p><p>认证和加密：PPP支持多种认证方式，如PAP（Password Authentication Protocol，口令认证协议）和CHAP（挑战握手认证协议），以确保通信双方的身份验证和安全性。</p><p>错误检测和恢复：PPP具有良好的差错检测和恢复机制，通过校验字段和重传等方式，确保数据传输的可靠性。<strong>每一帧都有循环冗余检验；</strong></p><ol><li>通信双方可以进行 I P地址的动态协商(使用 I P网络控制协议)；</li><li>与C S L I P类似，对T C P和I P报文首部进行压缩；</li><li>链路控制协议可以 对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加 3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li></ol><p>PPP协议的组成：</p><ol><li>在串行链路上封装 I P数据报的方法。 P P P既支持数据为 8位和无奇偶检验的异步模式（如大多数计算机上都普遍存在的串行接口），还支持面向比特的同步链接。</li><li>建立、配置及测试数据链路的链路控制协议（ L C P：Link Control Protocol）。它允许通<br>信双方进行协商，以确定不同的选项。</li><li>针对不同网络层协议的网络控制协议（ N C P：Network Control Protocol）体系。当前<br>R F C定义的网络层有I P、O S I网络层、D E C n e t以及A p p l e Ta l k。例如，IP NCP允许双方商定是<br>否对报文首部进行压缩，类似于 C S L I P（缩写词N C P也可用在T C P的前面）。<br><strong>PPP协议的帧格式：</strong></li></ol><p><img src="https://pica.zhimg.com/v2-ec2a47c393e41a1e459b7d15ee988b40_1440w.jpg" alt="img"></p><p>字节填充：<br>正如一开始讨论的透明传输那样：</p><p><img src="https://pic1.zhimg.com/v2-d63c9bc4575e81885f08b84bf2ffa89c_1440w.jpg" alt="img"></p><p>零比特填充：</p><p><img src="https://pic3.zhimg.com/v2-da067faa956e57c3c4a7a86011b9b150_1440w.jpg" alt="img"></p><p><strong>PPP协议工作状态：</strong></p><p><img src="https://picx.zhimg.com/v2-f6916cb7f4cae3240c52c0d271cbed51_1440w.jpg" alt="img"></p><h4 id="3-2什么是广播链路？"><a href="#3-2什么是广播链路？" class="headerlink" title="3.2什么是广播链路？"></a><strong>3.2什么是广播链路？</strong></h4><p>广播链路能够让多个发送和接收结点都连接到相同的、单一的、共享的广播信道上 这里使用术语”广播”是因为当任何一个结点传输一个帧时，信道广播该帧，每个其他结点都收到一个副本。以太网和无线局域网是广播链路层技术的例子。<br>当有多个发送和接受节点同时发送和接受时，便出现了一个问题:如何协调多个发送和接收结点对一个共享广播信道的访问，这就是多路访问问题</p><h5 id="3-2-1，载波侦听多路访问-CSMA-CD"><a href="#3-2-1，载波侦听多路访问-CSMA-CD" class="headerlink" title="3.2.1，载波侦听多路访问 (CSMA&#x2F;CD)"></a><strong>3.2.1，载波侦听多路访问 (CSMA&#x2F;CD)</strong></h5><p>想象一下：一个偌大的教室里，所有学生都在交流，如何确保所有学生能听到老师的声音（相同，单一的广播媒体）<br>这个问题的中心是：<strong>确定谁以及在什么时候获得说话权力(也就是向信道传输)</strong> 作为人类，为了共享这种广播信道，我们已经演化得到了个精心设计的协议集了:<br>“给每个人 个讲话的机会”<br>“该你讲话时你才说话”<br>“不要一个人独占整个谈话”<br>“如果有问题请举手”<br>“当有人讲话时不要打断”<br>“当其他人讲话时不要睡觉<br>计算机网络有类似的协议，也就是所谓的<strong>多路访问协议</strong><br><strong>定义：</strong><br>CSMA&#x2F;CD协议，（带碰撞检测的载波监听多路访问）是一种用于以太网局域网的多路访问协议。在以太网中，多个节点通过共享同一物理介质进行数据通信，CSMA&#x2F;CD协议旨在解决节点之间的数据碰撞问题。<br><strong>基本工作流程：</strong><br>载波监听：节点在发送数据之前先监听信道，检测是否有其他节点正在发送数据。如果信道上没有检测到其他节点的信号，节点将继续发送数据；否则，它将等待直到信道空闲。<br>碰撞检测：如果两个节点几乎同时发送数据导致碰撞，它们会通过检测到信道上的信号变化来意识到碰撞的发生。一旦节点检测到碰撞，它们会立即停止发送，并发送一个”jam”信号以通知其他节点有碰撞发生。<br>退避算法：在发生碰撞后，节点会使用退避算法来确定下一次重试发送数据的时间。该算法会随机选择一个时间间隔，在此间隔内等待然后再次尝试发送数据，以减少碰撞的概率。</p><p><img src="https://pic1.zhimg.com/v2-0628e617196cf679f50622d4bea8f376_1440w.jpg" alt="img"></p><p><strong>预期目标：</strong><br>减少碰撞影响：通过及时检测到碰撞并采取相应的措施，如停止发送数据并发送”jam”信号，CSMA&#x2F;CD协议可以尽快地清除碰撞，从而减少碰撞对网络带宽的影响，提高数据传输的成功率。<br>提高公平性：CSMA&#x2F;CD协议基于竞争机制，所有节点都有平等的机会发送数据。这样可以确保网络资源在各个节点之间公平地共享，避免某些节点长时间占用网络资源而导致其他节点无法发送数据。<br>最大化网络吞吐量：通过合理的退避算法和碰撞检测机制，CSMA&#x2F;CD协议试图最大化网络的吞吐量，即单位时间内网络所能传输的数据量，以提高网络性能。<br>降低网络延迟：CSMA&#x2F;CD协议旨在通过减少碰撞、合理分配网络资源等方式降低网络的传输延迟，从而提高数据传输的效率。<br><strong>传播时延对载波监听的影响</strong></p><p><img src="https://pic4.zhimg.com/v2-33b5bf32b1b14b10701ca2b9d8222acd_1440w.jpg" alt="img"></p><h2 id="4-交换局域网"><a href="#4-交换局域网" class="headerlink" title="4.交换局域网"></a>4.<strong>交换局域网</strong></h2><h3 id="4-1-网络层已经有IP地址了，为什么还要有MAC地址？"><a href="#4-1-网络层已经有IP地址了，为什么还要有MAC地址？" class="headerlink" title="4.1,网络层已经有IP地址了，为什么还要有MAC地址？"></a>4.1,网络层已经有IP地址了，为什么还要有MAC地址？</h3><p>局域网是为任意网络层协议而设计的，而不只是用于 IP 和因特网 如果适配器被指派IP</p><p>地址而不是”中性的” MAC 地址的话，则适配器将不能够方便地支持其他网络层协议(例如， IPX 或者 DECnel)</p><blockquote><p>如果适配器使用网络层地址而不是 MAC 地址的话，网络层地址必须存储在适配器的 RAM 中，并且在每次适配器移动(或加电)时要重新配置。另一种选择是在适配器中不使用任何地址，让每个适配器将它收到的每帧数据(通常是lP数据报)沿协议裁向上传递 然后网络层则能够核对网络地址层是否匹配</p></blockquote><p>这种选择带来的一个问题是，主机将被局域网上发送的每个帧中断，包括被目的地址</p><p>在相同广播局域网上的其他给点的帧中断</p><p>总之，为了使网络体系结构中各层次成为极为独立的构建棋块，不同的层次需要有它们自己的寻址方案</p><p><img src="https://pic1.zhimg.com/v2-77dda232e3970145a652b1c3e35bb2b4_1440w.jpg" alt="img"></p><p><img src="https://picx.zhimg.com/v2-b3ea253947f420e1f82d916f72df0ef9_1440w.jpg" alt="img"></p><h3 id="4-2-什么是链路层交换机？"><a href="#4-2-什么是链路层交换机？" class="headerlink" title="4.2,什么是链路层交换机？"></a>4.2,什么是链路层交换机？</h3><p>链路层交换机是一种在OSI模型中工作于数据链路层的网络设备，用于在局域网中转发数据帧。它主要用于连接不同计算机、网络设备或其他交换机，以实现数据的转发和交换。</p><p><strong>主要功能包括：</strong></p><p>数据帧转发：链路层交换机能够接收到来自一个端口的数据帧，并根据目标MAC地址将其转发至合适的端口，从而实现数据的点对点传输。</p><p>MAC地址学习：当数据帧进入交换机时，交换机会学习源MAC地址和对应的输入端口，建立MAC地址表。这样，当交换机需要转发数据帧时，可以根据目标MAC地址查找相应的输出端口进行转发。</p><p><img src="https://picx.zhimg.com/v2-76b2bd4db1d2b8fa714f25f551923033_1440w.jpg" alt="img"></p><p>数据帧过滤：交换机能够根据目标MAC地址来过滤数据帧，只将特定目标地址的数据帧发送至对应的端口，从而提高网络的安全性和效率。</p><p>碰撞域隔离：与传统的集线器（hub）不同，交换机能够隔离不同端口上的碰撞域，使得数据帧只在必要的端口上传输，减少了网络中的碰撞，提高了网络的性能。</p><p>VLAN支持：许多链路层交换机还支持虚拟局域网（VLAN）的功能，可以将不同物理位置的计算机组合成逻辑上的同一个网络，从而提高网络的灵活性和安全性。</p><p><img src="https://pic4.zhimg.com/v2-3f65e6f67ccba753dd8415a90613300f_1440w.jpg" alt="img"></p><h3 id="4-3-什么是虚拟局域网？"><a href="#4-3-什么是虚拟局域网？" class="headerlink" title="4.3,什么是虚拟局域网？"></a>4.3,什么是虚拟局域网？</h3><p><strong>定义</strong>：</p><p>虚拟局域网是一种将局域网中的设备按照逻辑上的组织方式划分成多个虚拟网络的技术。通过VLAN技术，可以实现不同物理位置的设备被划分到同一个逻辑网络中，或者将同一物理位置上的设备划分到不同的逻辑网络中，从而提高网络的管理灵活性、安全性和性能。</p><p><img src="https://pic1.zhimg.com/v2-996ff466b1eda675069e39b6ed1b4d3e_1440w.jpg" alt="img"></p><p><strong>VLAN技术的主要特点包括：</strong></p><p>逻辑隔离：VLAN技术可以将同一物理局域网中的设备按照逻辑上的不同需求进行隔离，使得它们在同一物理网段上可以进行独立的广播域划分和数据流量控制。</p><p>安全性：VLAN技术可以根据不同的安全需求将设备划分到不同的VLAN中，从而实现对不同用户、部门或应用的隔离，有效地提高网络的安全性。</p><p>灵活性：通过VLAN技术，网络管理员可以根据需要随时重新划分和重新配置虚拟网络，而无需改变物理网络结构，提高了网络的管理灵活性。</p><p>性能优化：VLAN技术还可以通过减少广播域的大小，限制广播帧的传播范围，从而减少网络中的广播风暴，提高了网络的性能。</p><p><img src="https://pica.zhimg.com/v2-5f9e219cfcfe5dc88ba25352cdd11a16_1440w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2023/01/30/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2023/01/30/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>早年在知乎发的文章，现转载到博客上</p></blockquote><h2 id="网络层的作用？"><a href="#网络层的作用？" class="headerlink" title="网络层的作用？"></a>网络层的作用？</h2><p>网络层的作用从表面上看极为简单，即将分组从一台发送主机移动到一台接收主机</p><p>为此，需要两种重要的网络层功能:</p><p><strong>转发：</strong>当一个分组到达路由器的一条输入链路时，路由器必须将该分组移动到适</p><p>当的输出链路 例如，来自主机 Hl 到路由器 Rl 的一个分组，必须向在 H2 路径</p><p>上的下一台路由器转发。</p><p><strong>路由选择</strong> 当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路</p><p>由或路径，计算这些路径的算法被称为路由选择算法</p><h2 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h2><p><img src="https://pic1.zhimg.com/v2-8f832cedebafa39ac1198a6b62ca85b2_1440w.jpg" alt="img"></p><p>IP是TCP&#x2F; IP协议族中最为核心的协议。其提供不可靠、无连接的数据报传送服务。</p><p><strong>不可靠</strong>的意思是它不能保证 I P数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送 ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如T C P）。</p><p><strong>无连接</strong>的意思是 IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是 A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。</p><h3 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h3><p><img src="https://pic4.zhimg.com/v2-b3fdfa34bf1e361f458e1cdecf5bfee3_1440w.jpg" alt="img"></p><ol><li>首部长度指的是首部占 32 bit字的数目，包括任何选项。由于它是一个 4比特字段，因此首部最长为60个字节。</li><li>服务类型字段包括一个3 bit的优先权子字段（现在已被忽略），4 bit的TOS子字段和1 bit未用位但必须置0。4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用。</li><li>总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道 I P数据报中数据内容的起始位置和长度。由于该字段长 1 6比特，所以 I P数据报最长可达 6 5 5 3 5字节，当数据报被分片时，该字段的值也随着变化。</li><li>标识字段唯一地标识主机发送的每一份数据报。</li><li>首部检验和字段是根据I P首部计算的检验和码。它不对首部后面的数据进行计算IC MP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h3 id="IP地址表示-分类"><a href="#IP地址表示-分类" class="headerlink" title="IP地址表示+分类"></a>IP地址表示+分类</h3><p><img src="https://pic2.zhimg.com/v2-ee98958735d93da93e5761ee7342614f_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/v2-a640ac196dc7213ec9df92ce71685173_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/v2-bcd8da781302b3623e9649cfbf5b2ce6_1440w.jpg" alt="img"></p><h3 id="IP子网划分"><a href="#IP子网划分" class="headerlink" title="IP子网划分"></a>IP子网划分</h3><p>子网划分这项技术用来把一个单一的IP网络地址划分成多个更小的子网(subnet)。 这种技术可使一个较大的分类IP地址能够被进一步划分为几个子网。通常是把IP地址中主机标识部分划出一定的位数用作本网的各个子网，剩余的主机标识作为相应子网的主机标识部分。</p><p>（地址掩码是一个32位的二进制数，用于指示一个IP地址中哪些位用于网络标识，哪些位用于主机标识。地址掩码与IP地址一起使用，确定IP地址的网络部分和主机部分。）</p><p><img src="https://pic2.zhimg.com/v2-e44d00a81ccb160b9052737929c13b85_1440w.jpg" alt="img"></p><h3 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h3><p>在传统的地址分配方法中，如果一个组织只需要500个IP地址，但是它被分配了一个B类地址，这意味着该组织将获得超过65000个IP地址的地址块，其中绝大多数都无法使用。这会导致大量的IP地址浪费。为了解决IPv4地址空间不足的问题而提出CIDR。</p><p><strong>通过将IP地址划分为更小的子网来解决这个问题</strong>。CIDR中，一个IP地址由网络前缀和主机标识符两部分组成，其中网络前缀用于标识主机所在的网络，主机标识符用于标识该主机在该网络中的位置。CIDR中，网络前缀的长度可以是任意的，这使得网络管理员可以更灵活地分配IP地址，从而减少了IP地址的浪费。</p><p><img src="https://pic4.zhimg.com/v2-d3c6c4f7c280be324b8e4fbe0f830bc1_1440w.jpg" alt="img"></p><h2 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h2><p><strong>数据链路如以太网或令牌环网都有自己的寻址机制</strong>（常常为 48 bit地址），这是使用数据链路的任何网络层都必须遵从的。一个网络如以太网可以同时被不同的网络层使用。例如，一组使用T P&#x2F;IP协议的主机和另一组使用某种P C网络软件的主机可以共享相同的电缆。当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit的以太网地址来确定目的接口的。设备驱动程序从不检查 I P数据报中的目的I P地址。地址解析为这两种不同的地址形式提供映射：32 bit的IP地址和数据链路层使用的任何类型的地址。ARP为IP地址到对应的硬件地址之间提供动态映射。</p><h3 id="ARP的分组格式"><a href="#ARP的分组格式" class="headerlink" title="ARP的分组格式"></a>ARP的分组格式</h3><p><img src="https://pic2.zhimg.com/v2-c910e8824efb3f6ab08b1a751d3c7159_1440w.jpg" alt="img"></p><h3 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h3><p><strong>ARP请求：</strong></p><p>当主机A知道目标主机的IP地址，但不知道其对应的MAC地址时，它会在局域网内广播一个ARP请求包，请求其他主机告知该IP地址对应的MAC地址。</p><p><strong>ARP应答：</strong></p><p>目标主机收到ARP请求后，如果发现自己的IP地址与请求中的IP地址相符，就会向源主机发送一个ARP应答包，其中包含自己的MAC地址。</p><p><strong>ARP缓存：</strong></p><p>每个主机在接收到ARP应答后，会将对应的IP地址和MAC地址进行缓存，以便将来直接进行通信而不需要再次发送ARP请求。</p><p><strong>ARP欺骗：</strong></p><p>由于ARP协议的工作原理，存在一定的安全漏洞，即ARP欺骗，攻击者可以发送虚假的ARP响应，欺骗其他主机将其数据发送到攻击者的主机上。</p><h3 id="一个例子："><a href="#一个例子：" class="headerlink" title="一个例子："></a>一个例子：</h3><p><img src="https://pic4.zhimg.com/v2-94f51d069fb6851230d6aa58653a7ed7_1440w.jpg" alt="img"></p><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h3 id="路由器演变历史"><a href="#路由器演变历史" class="headerlink" title="路由器演变历史"></a>路由器演变历史</h3><p><strong>早期网络：</strong></p><p>在互联网发展的初期，网络通信主要基于主机到主机的连接方式。每个主机都需要了解整个网络的拓扑结构，并且需要知道如何直接与其他主机进行通信。</p><p><strong>分组交换网络：</strong></p><p>随着网络规模的增长，主机到主机的连接方式变得不可行且低效。为了提高网络性能，分组交换网络应运而生。这种网络将数据分割成小的数据包（分组），每个数据包独立传输，并通过网络中的节点进行转发。</p><p><strong>网络节点：</strong></p><p>为了实现分组交换，网络中的节点（也称为数据包交换机）开始出现。这些节点负责接收数据包，并根据目标地址来决定将数据包转发到哪个接口。</p><p><strong>路由表：</strong></p><p>随着网络规模的进一步增长，网络中的节点需要更复杂的路由决策。为此，引入了路由表的概念。路由表包含了网络中不同目标地址所对应的下一跳信息，用于指导数据包的转发。</p><p><strong>路由器的出现：</strong></p><p>随着网络规模的不断扩大，为了更高效地管理网络流量和实现灵活的路由决策，专用的路由器设备开始出现。路由器是一种硬件设备，具有处理数据包转发和路由协议等功能。</p><p><strong>路由协议：</strong></p><p>路由器通过使用各种路由协议（如RIP、OSPF、BGP等）来学习和交换路由信息。这些协议使得路由器能够动态地更新路由表，并根据网络状况进行最优的路由选择。</p><p><strong>随着互联网的快速发展，路由器的功能和性能也得到了不断的提升。现代路由器不仅用于连接不同的局域网和广域网，还具备防火墙、VPN、负载均衡等功能，成为网络中重要的基础设施之一。</strong></p><p><img src="https://pica.zhimg.com/v2-896bde3f226a3b26e686c98d12b258ee_1440w.jpg" alt="img"></p><h3 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h3><p><strong>接收数据包：</strong></p><p>路由器通过其接口（例如以太网、无线）接收到来自源主机的数据包。</p><p><strong>解析目标地址：</strong></p><p>路由器检查数据包的目标IP地址，并在其路由表中查找匹配项。路由表中的条目通常包括目标网络的IP地址范围和下一跳的信息。</p><p><strong>查找最佳路径：</strong></p><p>路由器根据路由表中的信息确定最佳的转发路径。这可能涉及到多个路由器之间的转发。</p><p><strong>转发数据包：</strong></p><p>路由器将数据包发送到下一跳或目标网络。它会通过适当的接口将数据包传输到相应的网络。</p><p><strong>更新路由表：</strong></p><p>路由器可以使用动态路由协议（如RIP、OSPF、BGP等）学习和更新路由表。这些协议允许路由器与其他路由器交换路由信息，以便实时地调整路由选择。</p><p><strong>网络地址转换（NAT）（可选）：</strong></p><p>在某些情况下，路由器可能还执行网络地址转换（NAT）的功能。NAT将私有IP地址转换为公共IP地址，以便在互联网上进行通信。</p><p><strong>安全功能（可选）：</strong></p><p>现代路由器通常还具备防火墙、入侵检测和虚拟专用网络（VPN）等安全功能，以保护网络免受恶意攻击和非法访问。</p><p><img src="https://pica.zhimg.com/v2-12cc1c15e971ab9859917a3997b4eb50_1440w.jpg" alt="img"></p><h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><p>虚拟专用网络（VPN）是一种通过公共网络（如互联网）建立安全的连接的技术。</p><p>VPN 的主要目的是提供一个加密和匿名的网络连接，使用户可以在不安全的公共网络上进行安全的通信。它通过在用户设备和目标服务器之间创建一个加密的隧道来保护数据的传输。这使得用户可以在公共网络上发送和接收数据，同时保持数据的机密性和完整性。</p><p><strong>使用 VPN 可以带来以下好处：</strong></p><p>数据加密：VPN 使用加密技术对数据进行加密，从而保护用户的隐私和敏感信息，防止被窃听或篡改。</p><p>匿名性：VPN 可以隐藏用户的真实 IP 地址，并代表用户向目标服务器发送请求，增强了用户的匿名性和隐私保护。</p><p><strong>绕过地理限制：</strong>通过连接到不同地区的 VPN 服务器，用户可以绕过地理限制，访问被限制在特定地区的内容和服务。</p><p>公共Wi-Fi 安全：当使用公共 Wi-Fi 网络时，VPN 可以提供额外的安全性，防止黑客和恶意用户窃取用户的个人信息。</p><h3 id="VPN工作原理"><a href="#VPN工作原理" class="headerlink" title="VPN工作原理"></a>VPN工作原理</h3><ol><li><strong>建立连接：</strong>用户打开 VPN 客户端，并选择连接到 VPN 服务器。客户端和服务器之间建立一个安全的连接。</li><li><strong>数据加密：</strong>在建立连接后，VPN 客户端和服务器之间的通信会使用加密算法对数据进行加密。这样，即使有人截获了数据包，也无法解读其内容。</li><li><strong>数据封装：</strong>当用户发送数据时，VPN 客户端会将数据包装在一个新的数据包中，添加了VPN的头部信息。这个过程称为“封装”（encapsulation）。</li><li><strong>隧道传输：</strong>经过封装后的数据被发送到 VPN 服务器，通过公共网络进行传输。由于数据已被加密和封装，所以即使在传输过程中被窃听，也无法获取其原始内容。</li><li><strong>数据解封装：</strong>一旦数据抵达 VPN 服务器，服务器会解开封装，还原原始数据。</li><li>目标访问：解封装后的数据会被发送到目标服务器，目标服务器会向其响应。</li><li>响应封装：目标服务器的响应数据会被封装，加上VPN的头部信息。</li><li><strong>返回给客户端：</strong>封装后的响应数据通过加密隧道返回到 VPN 客户端，然后在客户端进行解封装和解密。</li></ol><h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><p>网络地址转换（NAT）是一种将私有 IP 地址转换为公共 IP 地址的技术。NAT 技术主要用于在局域网和互联网之间进行通信时，使得局域网中的多个主机可以使用同一个公共 IP 地址访问互联网。</p><p>NAT 的基本原理是将内部网络的私有 IP 地址映射到公共 IP 地址，这样就可以在不改变内部网络结构的情况下实现网络连接。例如，当内部网络的主机向外部网络发送请求时，路由器会将其源 IP 地址修改为公共 IP 地址，以便从外部网络响应请求。</p><p><img src="https://pic1.zhimg.com/v2-25839a5f59c066e6fdccb158604ab810_1440w.jpg" alt="img"></p><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>路由表（Routing Table）是路由器或计算机操作系统中存储的一种数据结构，它用于决定数据包从源地址到目的地址的传输路径。路由表中包含了各种网络目的地及与之相关联的下一跳信息，以帮助设备进行数据包的转发和路由选择。路由表中的每一项都包含下面这些信息：</p><p>• 目的I P地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号（见图1 - 5），以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。</p><p>• 下一站（或下一跳）路由器（ next-hop router）的I P地址，或者有直接连接的网络 I P地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。</p><p>• 标志。其中一个标志指明目的 I P地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口（我们将在 9 . 2节中详细介绍这些标志）。</p><p>• 为数据报的传输指定一个网络接口。</p><p><img src="https://picx.zhimg.com/v2-282d2b29bb8e2b9cbf6adc4e2af92393_1440w.jpg" alt="img"></p><h2 id="IP选路"><a href="#IP选路" class="headerlink" title="IP选路"></a>IP选路</h2><h3 id="IP路由选择"><a href="#IP路由选择" class="headerlink" title="IP路由选择"></a>IP路由选择</h3><p>IP路由选择是逐跳地进行的。IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的IP路由选择只为数据报传输提供下一站路由器的 I P地址。它假定下一站路由器比发送数据报的主机更接近目的，而且下一站路由器与该主机是直接相连的。</p><p>IP路由选择主要完成以下这些功能：</p><ol><li>搜索路由表，寻找能与目的 I P地址完全匹配的表目（网络号和主机号都要匹配）。如果<br>找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标<br>志字段的值）。</li><li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论。</li><li>搜索路由表，寻找标为“默认”的表目。如果找到，则把报文发送给该表目</li></ol><p>指定的下一站路由器。</p><p>如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。（网络控制报文协议ICMP）<strong>一个例子：</strong></p><p>主机 b s d i有一个I P数据报要发送给主机 s u n。双方都在同一个以太网上。</p><p><img src="https://picx.zhimg.com/v2-89da487f5b5204ae0ce34157b046c47f_1440w.jpg" alt="img"></p><p>主机 b s d i有一个I P数据报要发送给主机 s u n。双方不在同一个以太网上。</p><p><img src="https://pica.zhimg.com/v2-1a6e4c5a65aa3aec676c3c83e1eb9914_1440w.jpg" alt="img"></p><p>对于这个例子需要指出一些关键点：</p><ol><li>该例子中的所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器<br>可以用默认路由来处理任何目的，除非它在本地局域网上。</li><li>数据报中的目的I P地址始终不发生任何变化，只有使用源路由选项时，目的I P地址才有可能被修改，但这种情况很少出现）。所有的路由选择决策都是基于这个目的I P地址。</li><li>每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是S L I P链路没有这样做。以太网地址一般通过ARP获得。</li></ol><h3 id="IP动态选路协议"><a href="#IP动态选路协议" class="headerlink" title="IP动态选路协议"></a>IP动态选路协议</h3><p>在网络很小，且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用静态路由选择是可行的。但如果上述三种情况不能全部满足，通常使用<strong>动态选路</strong>。</p><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器之间必须采用选路协议进行通信，。路由器上有一个进程称为路由守护程序，它运行选路协议,并与其相邻的一些路由器进行通信。路由守护程序根据它从相邻路由器接收到的信息，更新内核中的路由表。动态选路并不改变选路机制内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了—当路由随时间变化时，路由是由路</p><p>由守护程序动态地增加或删除。Interne是以一组自治系统的方式组织的，每个自治系统通常由单个实体管理。常常将一个公司或大学校园定义为一个自治系统。 N S F N E T的In t e r n e t骨干网形成一个自治系统，这是因为骨干网中的所有路由器都在单个的管理控制之下。<strong>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为内部网关协议IGP或域内选路协议.</strong></p><p><strong>外部网关协议EGP或域内选路协议的分隔选路协议用于不同自治系统之间的路由器。</strong></p><h3 id="内部网关协议RIP"><a href="#内部网关协议RIP" class="headerlink" title="内部网关协议RIP"></a>内部网关协议RIP</h3><p>RIP是一种基于距离向量的内部网关协议（IGP），用于在小型网络中动态交换路由信息。RIP是一种简单、易于实现的路由协议，常用于较小规模的网络环境。</p><h3 id="RIP报文格式"><a href="#RIP报文格式" class="headerlink" title="RIP报文格式"></a>RIP报文格式</h3><p><img src="https://picx.zhimg.com/v2-6c376ed9df6cd0338b30cf78ae391d57_1440w.jpg" alt="img"></p><h3 id="RIP协议的一些特点："><a href="#RIP协议的一些特点：" class="headerlink" title="RIP协议的一些特点："></a>RIP协议的一些特点：</h3><p><strong>距离向量：</strong>RIP使用距离向量算法来计算到达目的网络的最佳路径。每个路由器根据收到的邻居路由器的距离信息，更新自己的路由表。</p><p><strong>距离度量：</strong>RIP使用跳数作为距离度量，即将到达目的网络所经过的路由器数量作为衡量路径优劣的标准。默认情况下，RIP将跳数限制在15跳以内，超过这个跳数则认为到达目的地不可达。</p><p><strong>广播更新：</strong>RIP使用广播方式周期性地向网络中的其他路由器发送路由更新信息，以交换路由信息。这样，所有路由器都能了解到整个网络的拓扑结构，并相应地更新自己的路由表。</p><p><strong>慢收敛：</strong>由于RIP的更新机制是周期性的，而且RIP对网络变化的检测和适应较慢，因此RIP的收敛速度相对较慢。这意味着在网络发生变化时，RIP可能需要一段时间才能适应新的路由变化。</p><h3 id="RIP工作原理："><a href="#RIP工作原理：" class="headerlink" title="RIP工作原理："></a>RIP工作原理：</h3><p>• 初始化：在启动一个路由守护程序时，它先判断启动了哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点的。如果网络支持广播的话，这种请求是以广播形式发送的。目的 U D P端口号是5 2 0（这是其他路由器的路由守护程序端口号）。这种请求报文的命令字段为 1，但地址系列字段设置为 0，而度量字段设置为 1 6。这是一种要求另一端完整路由表的特殊请求报文。</p><p>• 接收到请求。如果这个请求是刚才提到的特殊请求，那么路由器就将完整的路由表发送给请求者。否则，就处理请求中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量置为 1 6（度量为1 6是一种称为“无穷大”的特殊值，它意味着没有到达目的的路由）。然后发回响应。</p><p>• 接收到响应。使响应生效，可能会更新路由表。可能会增加新表项，对已有的表项进行修改，或是将已有表项删除。</p><p>• 定期选路更新。每过3 0秒，所有或部分路由器会将其完整路由表发送给相邻路由器。发送路由表可以是广播形式的（如在以太网上），或是发送给点对点链路的其他终点的命令</p><p>• 触发更新。每当一条路由的度量发生变化时，就对它进行更新。不需要发送完整路由表，而只需要发送那些发生变化的表项。每条路由都有与之相关的定时器。如果运行 R I P的系统发现一条路由在 3分钟内未更新，</p><p>就将该路由的度量设置成无穷大（16），并标注为删除。这意味着已经在 6个3 0秒更新时间里没收到通告该路由的路由器的更新了。再过 6 0秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p><p><img src="https://picx.zhimg.com/v2-8d3b7cf2cd86ddb01bef5d752611500b_1440w.jpg" alt="img"></p><h3 id="内部网关协议OSPF"><a href="#内部网关协议OSPF" class="headerlink" title="内部网关协议OSPF"></a>内部网关协议OSPF</h3><p>O S P F是除R I P外的另一个内部网关协议。它克服了 R I P的所有限制。</p><p>与采用距离向量的 R I P协议不同的是， O S P F是一个链路状态协议。距离向量的意思是，</p><p>R I P发送的报文包含一个距离向量（跳数）。每个路由器都根据它所接收到邻站的这些距离向量来更新自己的路由表。</p><p>在一个链路状态协议中，路由器并不与其邻站交换距离信息。它采用的是每个路由器主</p><p>动地测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在</p><p>自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。</p><p>由于各路由器之间频繁的交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库(link-state database)，这个数据库的实质是全网的拓扑结构图，这个拓扑结构在全网就是一致的。因此，每一个路由器知道全网共有多少个路由器，以及那些路由器是相连的，其代价是多少等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表(例如迪杰斯特拉的最短路径算法)。我们注意到，RIP协议的每一个路由器虽然知道所有网络的距离以及下一跳以及下一跳路由器，但却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳怎么走)。</p><p><img src="https://pic4.zhimg.com/v2-36d7c45ca42aa6c6ddb89a539794312b_1440w.jpg" alt="img"></p><p>从实际角度来看，二者的不同点是链路状态协议总是比距离向量协议收敛更快。收敛的意思是在路由发生变化后，例如在路由器关闭或链路出故障后，可以稳定下来。</p><p><strong>OSPF的三个要点和RIP都不一样：</strong></p><ol><li>向本自治系统中的所有路由器发送信息。这里使用的方法是洪范法(flooding)，</li></ol><p><img src="https://pic4.zhimg.com/v2-8af5f59d24aac8052f63f15e77abc0f7_1440w.jpg" alt="img"></p><p>这就是路由器通过所有输出端口向相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器。这样，最终整个所有的路由器都得到了这个信息的一个副本。更具体的做法后面继续讨论，我们应该注意，RIP协议是仅仅向自己相邻的几个路由器发送信息。</p><p>2，发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息，所谓的链路状态就是说明本路由状态都和哪些路由相邻，对于RIP协议，发送的信息是：“到所有网络的距离和下一跳路由器”。</p><p>3，只有当链路状态发生变化时候，路由器才能向所有路由器采用洪范法发送此信息。而不像RIP那样，不管网络拓扑结构是否发生变化，路由器之间都要定期更换路路由表信息。</p><h3 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h3><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>OSPF、ISIS路由协议在网络中已经广泛使用，但是随着网络规模的扩大，路由条目也随增加，IGP协议已经无法管理大规模网络了。因此出现了AS的概念。（AS是指在同一组织管理下，使用统一选路策略设备的集合。）</p><p>简单来说：就是你可以把一个网络中的不同的设备划分到不同的组（AS）中，或者都划分在一个组中，那么一个组中的这些设备具备相同的路由协议。</p><p><img src="https://pic1.zhimg.com/v2-e01220b4542d0955cc8dfe299575e2ba_1440w.jpg" alt="img"></p><p>比如你可以将企业总部网络划分在一个AS中，企业的分部网络划分在一个AS中。不同的AS可以运行不同的路由协议。</p><p>那么不同AS的网络需要通信时，采用什么路由协议进行通信呢？答案就是本章的BGP路由协议。那么为什么不能够通过IGP（ISIS、BGP）进行通信呢？</p><p>这个举个简单的例子，企业网络或者数据中心网络对接运营商的Internet时。如果使用IGP路由协议（OSPF、ISIS）对接时，那么这个时候企业网络和运营商的网络是运行在一张网络中，这个是不安全的，你可以认为运营商为什么信任你的企业网络？</p><p>还有一点就是整个网络规模扩大，路由数量增多，路由收敛慢。</p><p>那么有没有一种路由协议可以实现不同网络间的路由交互呢？答案就是BGP。BGP有个好处就是不产生路由，只传递路由，并且具备丰富的路由策略。</p><p><img src="https://pica.zhimg.com/v2-081d688950d282171eb0fea7c2fd1050_1440w.jpg" alt="img"></p><h3 id="BGP传递路由优势"><a href="#BGP传递路由优势" class="headerlink" title="BGP传递路由优势"></a>BGP传递路由优势</h3><p>BGP是基于TCP的路由协议，只要能够建立TCP就能够建立BGP；</p><p>BGP只传递路由信息，不计算路由，不会暴露AS内部的网络拓扑；</p><p>BGP的路由更新是触发更新，不是周期性更新；</p><h3 id="什么是BGP路由协议"><a href="#什么是BGP路由协议" class="headerlink" title="什么是BGP路由协议"></a>什么是BGP路由协议</h3><p>BGP是一种基于距离矢量的路由协议，用于实现不同AS之间的路由可达。</p><p>BGP协议的基本特点：</p><p>（1）BGP是一种外部网关协议，其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由；</p><p>（2）BGP使用TCP作为其传输层协议（端口号179）,提高了协议的可靠性；</p><p>（3）BGP是一种距离矢量路由协议，在设计上就避免了环路的发生；</p><p>（4）BGP提供了丰富的路由策略，能够实现路由的灵活过滤和选择；</p><p>（5）BGP采用触发式增量更新，而不是周期性的更新；</p><h3 id="BGP报文头格式"><a href="#BGP报文头格式" class="headerlink" title="BGP报文头格式"></a>BGP报文头格式</h3><p>不同于常见的IGP协议，BGP使用TCP作为传输层协议，端口号179。BGP存在5种不同类型的报文，不同类型的报文具有相同的头部。</p><p><img src="https://pic4.zhimg.com/v2-c7e39eff0fdf0e6458cb632f9a3ad1b7_1440w.jpg" alt="img"></p><p><strong>BGP选路规则与负载分担</strong></p><p>当到达同一目的地存在多条路由时，BGP采取如下策略进行路由选择：</p><p>如果此路由的下一跳不可达，忽略此路由</p><p>优选协议首选值（PrefVal）最高的路由 （华为设备特有属性）</p><p>优选本地优先级（Local_Pref）最高的路由</p><p>优选本地生成的路由</p><p>优选AS路径（AS_Path）最短的路由</p><p>比较Origin属性，依次优选Origin类型为IGP、EGP、Incomplete的路由</p><p>优选MED值最低的路由</p><p>优选从EBGP邻居学来的路由</p><p>优选到BGP下一跳IGP Metric较小的路由</p><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><p>I C M P经常被认为是 I P层的一个组成部分。它传递差错报文以及其他需要注意的信息。</p><p>I C M P报文通常被I P层或更高层协议（ T C P或U D P）使用。一些 I C M P报文把差错报文返回给用户进程。</p><h3 id="ICMP背景与作用"><a href="#ICMP背景与作用" class="headerlink" title="ICMP背景与作用"></a>ICMP背景与作用</h3><p>ICMP协议是一个网络层协议。 一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。因此我们需要ICMP协议来完成这样的功能。</p><p><strong>ICMP消息可以用于以下几个方面：</strong></p><p><strong>错误报告</strong>：当在路由过程中遇到问题或数据包丢失时，路由器或主机会向发送者发送ICMP错误消息，以便通知发送者发生了错误。例如，ICMP目的不可达消息可以告知发送者目标主机不可达。</p><p><strong>查询和回应</strong>：ICMP还支持查询和回应功能，用于获取关于网络设备的状态信息。例如，ICMP回应消息用于确认数据包是否成功到达目标主机，ICMP Echo请求和回应消息则用于进行网络连通性测试（常见的Ping操作）。</p><p><strong>重定向</strong>：当路由器接收到数据包并发现更好的路径时，可以使用ICMP重定向消息通知发送者使用新的路径来发送数据。</p><p><strong>时间戳</strong>：ICMP还支持时间戳请求和回应消息，用于测量网络延迟和授时。</p><p>ICMP消息通常被底层网络设备（如路由器）生成和处理，以帮助维护网络的正常运行和故障排除。在网络故障排查和网络监测中，ICMP起到了重要的作用，可以提供关键的信息来诊断和解决网络问题。</p><p>ICMP协议的功能主要有：</p><p>确认IP包是否成功到达目标地址</p><p>通知在发送过程中IP包被丢弃的原因</p><p><img src="https://pic2.zhimg.com/v2-2e2a022b814d598c41ed8576684a20fd_1440w.jpg" alt="img"></p><p><strong>ICMP报文</strong></p><p><img src="https://pic1.zhimg.com/v2-9ccfbdc7625b117d42970c2156a89fb2_1440w.jpg" alt="img"></p><p>类型：占1字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文</p><p>代码：占1字节，标识对应ICMP报文的代码。它与类型字段一起共同标识了ICMP报文的详细类型</p><p>校验和：占2字节，这是对包括ICMP报文数据部分在内的整个ICMP数据报的校验和，以检验报文在传输过程中是否出现了差错</p><p>内容：占8字节。</p><h3 id="ICMP报文的类型"><a href="#ICMP报文的类型" class="headerlink" title="ICMP报文的类型"></a>ICMP报文的类型</h3><p>常见的ICMP报文可以分为两大类，即差错报文和查询报文。</p><p>当发送一份I C M P差错报文时，报文始终包含 I P的首部和产生I C M P差错报文的I P数据报的前8个字节。这样，接收 I C M P差错报文的模块就会把它与某个特定的协议（根据 I P数据报首部中的协议字段来判断）和用户进程（根据包含在 I P数据报前8字节中的T C P或U D P报文首部中的T C P或U D P端口号来判断）联系起来。</p><p><img src="https://pica.zhimg.com/v2-668cb57e318656d7c90cefcef8f8e726_1440w.jpg" alt="img"></p><p>下面各种情况都不会导致产生 I C M P差错报文：</p><ol><li>ICMP差错报文（但是，I C M P查询报文可能会产生I C M P差错报文）。</li><li>目的地址是广播地址（见图 3 - 9）或多播地址（D类地址，见图1 - 5）的I P数据报。</li><li>作为链路层广播的数据报。</li><li>不是I P分片的第一片（将在11 . 5节介绍分片）。</li><li>源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地</li></ol><p>址或多播地址。</p><p>这些规则是为了防止过去允许 I C M P差错报文对广播分组响应所带来的广播风暴。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6是用于网络通信的下一代IP协议。它是IPv4的继任者，旨在解决IPv4所面临的地址空间枯竭和其他一些限制性问题。</p><h3 id="基本首部"><a href="#基本首部" class="headerlink" title="基本首部"></a>基本首部</h3><p><img src="https://pic2.zhimg.com/v2-887eb41091f3ca32b729c846fca87727_1440w.jpg" alt="img"></p><h3 id="改进和特性"><a href="#改进和特性" class="headerlink" title="改进和特性"></a>改进和特性</h3><p><strong>更大的地址空间：</strong>IPv6采用128位的地址空间，相比IPv4的32位地址空间大得多，提供了约340亿亿亿亿（3.4×10^38）个可用的IP地址。这样大的地址空间可以满足未来互联网设备的需求，并解决了IPv4中出现的地址耗尽问题。</p><p><strong>简化的地址表示</strong>：IPv6地址使用8组四位十六进制数表示，以冒号分隔，例如2001:0db8:85a3:0000:0000:8a2e:0370:7334。为了进一步简化表示，连续的0可以省略并用“::”表示一次，例如2001:0db8:85a3::8a2e:0370:7334。这种简化的表示形式使IPv6地址更易读和管理。</p><p><strong>改进的扩展性和灵活性</strong>：IPv6引入了扩展头（Extension Headers）的概念，可以在IPv6数据包中添加各种扩展选项，如认证和加密扩展。这种灵活性使得IPv6在支持新的网络功能和服务方面更具有优势。</p><p><strong>改进的安全性：</strong>IPv6在协议层面提供了更强的安全性支持，包括IPsec（IP Security）的原生支持。IPsec可以提供数据的加密、身份验证和完整性保护，为网络通信提供更高的安全性。</p><p>改进的多播支持：IPv6对多播（Multicast）进行了改进，引入了一种新的多播地址类型，称为组播地址，用于在IPv6网络中进行有效的多播通信。</p><p><strong>简化的网络配置：</strong>IPv6通过自动配置的方式，使得网络设备可以自动获取全局唯一的IPv6地址，而无需手动配置或使用DHCP（Dynamic Host Configuration Protocol）。这种简化的网络配置过程降低了网络管理的复杂性。</p><h2 id="网络组管理协议IGMP"><a href="#网络组管理协议IGMP" class="headerlink" title="网络组管理协议IGMP"></a>网络组管理协议IGMP</h2><p>IGMP是一种用于在IP网络中进行组播管理的协议。</p><p>组播是一种将数据包从一个源发送到多个目的地的通信方式，可以有效地实现多播流量的分发。IGMP协议用于主机和路由器之间的交互，以便主机能够加入、离开和查询组播组，并确保只有对组播感兴趣的主机接收到相关数据。</p><h3 id="IGMP报文"><a href="#IGMP报文" class="headerlink" title="IGMP报文"></a>IGMP报文</h3><p><img src="https://pic1.zhimg.com/v2-f9d96b14ed3e22f32b9363314f66f774_1440w.jpg" alt="img"></p><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>多播的基础就是一个进程的概念（使用的术语进程是指操作系统执行的一个程序），该进</p><p>程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的—它随时因进程加入和离开多播组而变化。</p><p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加</p><p>入的多播组。这些是一个支持多播主机中任何 A P I所必需的部分。使用限定词“接口”是因为多播组中的成员是与接口相关联的。一个进程可以在多个接口上加入同一多播组。</p><p><strong>多播路由器使用I G M P报文来记录与该路由器相连网络中组成员的变化情况。使用规则如</strong></p><p><strong>下：</strong></p><ol><li>当第一个进程加入一个组时，主机就发送一个 I G M P报告。如果一个主机的多个进程加入同一组，只发送一个I G M P报告。这个报告被发送到进程加入组所在的同一接口上。</li><li>进程离开一个组时，主机不发送 I G M P报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的 I G M P查询中就不再发送报告报文。</li><li>多播路由器定时发送I G M P查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个 I G M P查询。因为路由器希望主机对它加入的每个多播组均<br>发回一个报告，因此I G M P查询报文中的组地址被设置为 0。</li><li>主机通过发送I G M P报告来响应一个I G M P查询，对每个至少还包含一个进程的组均要发回I G M P报告。</li></ol><p><strong>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还</strong></p><p><strong>包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使</strong></p><p><strong>用相应的多播链路层地址）还拥有属于那个组主机的接口上。</strong></p><p><img src="https://pic3.zhimg.com/v2-da1fb8f9b33337f01f143cb488eddd32_1440w.jpg" alt="img"></p><p>多播是一种将报文发往多个接收者的通信方式。在许多应用中，它比广播更好，因为多播降低了不参与通信的主机的负担。简单的主机成员报告协议 ( I G M P )是多播的基本模块。在一个局域网中或跨越邻近局域网的多播需要使用这里介绍的技术。广播通常局限在单个局域网中，对目前许多使用广播的应用来说，可采用多播来替代广播。</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外存管理</title>
    <link href="/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/20/%E5%A4%96%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在提供计算机持久化的知识框架体系，对于一些细节内容并没有过多介绍。</p></blockquote><h1 id="内存的不足"><a href="#内存的不足" class="headerlink" title="内存的不足"></a>内存的不足</h1><h2 id="内存管理管理方式："><a href="#内存管理管理方式：" class="headerlink" title="内存管理管理方式："></a>内存管理管理方式：</h2><p>在上一篇文章中：<a href="https://wangxiaobai08.github.io/2024/12/19/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理 - The Peak Tower</a>，提到了内存管理：<strong>所有的应用程序都需要<code>存储</code>和<code>检索</code>信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。</strong></p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>然而，存储容量受<code>虚拟地址空间</code>大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。</p><p>第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。</p><p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。</p><h1 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>通过对内存不足的分析，对于长久存储的信息我们有三个基本需求：</p><ul><li><strong>必须要有可能存储的大量的信息</strong></li><li><strong>信息必须能够在进程终止时保留</strong></li><li><strong>必须能够使多个进程同时访问有关信息</strong></li></ul><p>因此可以引入<strong>持久化存储</strong>，例如硬盘、固态硬盘（SSD）等非易失性存储设备。</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>对于新引入的设备，计算机如何将I&#x2F;O集成进系统中？其中的一般机制是什么？如何让它们变得高效？</p><h1 id="IO接口与设备"><a href="#IO接口与设备" class="headerlink" title="IO接口与设备"></a>IO接口与设备</h1><p>在开始下面的内容前，有必要先简单了解什么是IO接口与设备？</p><p><strong>IO（Input&#x2F;Output）设备</strong>是将数据输入计算机或接收计算机输出的设备。</p><p>鼠标、键盘都属于IO设备，它们所连接到的电脑的接口叫做IO接口（或称为IO控制器）。</p><p>IO接口为了能够充当设备与计算机的桥梁，它需要多个寄存器：</p><ul><li><strong>数据寄存器</strong>：保存设备的输出或计算机的输出。</li><li>**<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8&zhida_source=entity">控制寄存器</a>**：计算机需要控制设备做出操作，要做的操作存在这里。</li><li><strong>状态寄存器</strong>：设备完成操作后，需要告诉计算机当前的状态。</li></ul><p>这些寄存器对于计算机而言都是<strong>IO端口</strong>——数据端口、状态端口、控制端口。一个IO接口可以对应多个设备，每个设备可以有自己的一组数据、控制、状态寄存器，这样计算机就可以通过控制不同组的寄存器，来控制不同的设备。</p><p><img src="https://s2.loli.net/2024/12/21/VK4UMSjxOYlFhpt.png" alt="IO接口"></p><p>计算机通过一条系统总线（包含数据、地址、控制信号线）与IO接口连接，CPU、主存、IO接口都连在上面。cpu可以通过总线直接控制IO接口，也可以让主存与IO接口间传递数据。</p><p><img src="https://s2.loli.net/2024/12/21/K9PfI4X1GlNTADR.png" alt="系统总线"></p><p>CPU有两种方式获得数据：</p><ul><li><strong><a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2&zhida_source=entity">程序查询</a>方式</strong>：CPU会不断询问键盘的状态寄存器输入是否完成，如果检测到了完成，就会把数据寄存器里的数据拿到主存。</li><li><strong>程序中断方式</strong>：CPU不用询问，IO接口根据状态寄存器来选择是否需要向CPU发送一个中断信号，CPU收到信号会过来收取数据。</li></ul><p>程序查询方式会导致cpu只能一直等着键盘输入，不能做其他事；<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=2&q=%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F&zhida_source=entity">程序中断方式</a>可以允许CPU先做其他事，等输入完成后过来取到主存。</p><blockquote><p><strong>中断</strong>是计算机中比较重要的内容，在这里与主体内容关联不大，不多赘述，可自自行百度</p></blockquote><p>注意有一种特殊的IO接口——<strong>DMA接口</strong>，它可以用DMA总线与主存直接相连，只要CPU告诉DMA接口要把数据存在主存中的哪个地址，DMA接口就会根据地址把数据放进主存。</p><img src="https://s2.loli.net/2024/12/21/8VoPR9gelTqMHcu.png" alt="v2-9b1553f891f5172e314eafd35fca0677_1440w" style="zoom:50%;" /><p>对于DMA接口而言，CPU还需要告诉它主存地址，如果有多个DMA接口，CPU依旧会很忙碌。为了进一步解放CPU，<strong>通道</strong>可以接替CPU做一些基础操作。</p><img src="https://s2.loli.net/2024/12/21/PVHza71unBCiIJ8.png" alt="v2-5054d9430842c23df9b840bddb745f23_1440w" style="zoom:50%;" /><p>它就像一个低级CPU，有自己的指令系统——<a href="https://zhida.zhihu.com/search?content_id=178001891&content_type=Article&match_order=1&q=%E9%80%9A%E9%81%93%E6%8C%87%E4%BB%A4&zhida_source=entity">通道指令</a>，能够执行一些有限的操作。当它接受到CPU发出的<strong>IO指令</strong>后，可以按照要求启动IO设备，或者执行通道指令——就像是CPU的小弟。</p><p>IO指令从逻辑上分为三个字段：</p><ul><li>操作码：可以被用作和其他指令的区分，让CPU知道这是一条IO指令。</li><li>命令码：代表了设备要做的具体操作。</li><li>设备码：可以指定对某个设备进行操作，用作区分设备。</li></ul><p>不同设备的IO指令各不相同，同样是设置鼠标侧键、灯光或是灵敏度，不同的品牌都有不同的IO指令。这也是为什么在插上鼠标键盘显卡之类的部件时，如果你想更好的使用它就需要安装驱动的原因。</p><p>键盘的每一次敲击都在向计算机发出中断信号，一般情况下计算机会暂停手上的工作，先处理键盘的输入数据，之后再回到自己之前的工作。</p><h1 id="I-O集成"><a href="#I-O集成" class="headerlink" title="I&#x2F;O集成"></a>I&#x2F;O集成</h1><p>先来观察计算机体系架构：</p><img src="https://s2.loli.net/2024/12/21/eoLBjYpE2VUkHKA.png" alt="计算机架构" style="zoom:25%;" /><p>CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。图像或者其他高性能I&#x2F;O设备通过常规的I&#x2F;O总线（I&#x2F;O bus）连接到系统，在许多现代系统中会是PCI或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如SCSI、SATA或者USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p><p>接着续上<em>持久化存储</em>中<strong>计算机如何将I&#x2F;O集成进系统中？</strong>的问题，继续探讨：</p><p>这里要解决的第一个问题便是：</p><h2 id="如何与设备通信"><a href="#如何与设备通信" class="headerlink" title="如何与设备通信?"></a>如何与设备通信?</h2><p><strong>I&#x2F;O指令方式</strong>：通过指令（如 <code>in</code> 和 <code>out</code>）与设备通信，指定寄存器和设备端口，通常为特权指令，仅操作系统可使用，确保安全性。</p><p><strong>内存映射I&#x2F;O</strong>：设备寄存器映射为内存地址，操作系统通过读写这些地址与设备交互，硬件将访问操作转交给设备，而非物理内存。</p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><p>每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用?比如：</p><table><thead><tr><th>设备类型</th><th>接口类型</th><th>特殊要求</th></tr></thead><tbody><tr><td>硬盘</td><td>块设备，协议如 SATA、NVMe</td><td>批量传输数据，支持异步操作，命令格式多样</td></tr><tr><td>显示器</td><td>输出设备，通过显卡接口或协议驱动</td><td>实时更新数据，要求特定的视频信号、刷新率等支持</td></tr></tbody></table><p><strong>本质</strong>：不同设备有不同的寄存器布局、通信协议和操作流程，这些具体接口定义了设备的使用方式，需要操作系统进行抽象和标准化以实现通用性。</p><p>这个问题抽象，在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所有设备交互的细节都封装在其中。</p><p><strong>设备驱动程序</strong>（Device Driver）是操作系统的一部分，负责在操作系统与硬件设备之间建立连接，使操作系统能够控制和管理设备，而无需直接处理设备的底层硬件细节。<br><strong>核心功能</strong>：</p><ul><li><strong>抽象化设备接口</strong>：隐藏硬件的具体实现细节，对操作系统提供统一的访问接口。</li><li><strong>管理硬件资源</strong>：与设备通信，完成初始化、数据传输、资源分配等操作。</li><li><strong>兼容性与扩展性</strong>：通过加载不同的驱动程序，操作系统能够支持多种硬件设备，而无需修改自身核心。</li></ul><p>比如：</p><p>假设有一台打印机，用户希望通过电脑将文档打印出来。不同厂商、型号的打印机可能有完全不同的通信协议和功能设置。那么，操作系统如何支持这些打印机呢？这就是设备驱动程序的作用。</p><p><strong>具体过程</strong>：</p><p><strong>设备驱动的作用</strong>：<br>打印机驱动程序是一个中间层，负责将操作系统的打印请求（如 “打印这份 PDF 文档”）翻译成打印机能理解的具体命令。</p><p><strong>实现过程</strong>：</p><p>用户在电脑上点击“打印”，操作系统将打印内容通过<strong>统一的打印接口</strong>（如 Windows 的打印子系统）发送给打印机驱动程序。</p><p>驱动程序会根据打印机的具体型号和协议，生成打印机可以理解的命令，如：</p><ul><li>将文字和图片数据转换为打印机支持的格式（如 PCL、PostScript 等）。</li><li>设置具体的打印参数（分辨率、纸张类型等）。</li></ul><p>驱动程序与打印机通信，发送这些指令并控制打印过程。</p><p><strong>操作系统的通用性</strong>：</p><ul><li>操作系统本身只需要支持一个通用的打印接口。</li><li>针对不同型号的打印机，只需加载相应的驱动程序。</li></ul><img src="https://s2.loli.net/2024/12/21/C8mHAvK1BF2kaTz.png" alt="驱动程序" style="zoom:50%;" /><p>注意：<strong>设备驱动程序必须实现操作系统定义的接口</strong>，以便操作系统能够通过统一的方式与设备交互，而不关心具体设备的实现细节。常见的比如：<strong>读写操作接口</strong>：<br>驱动程序需要实现设备读写的标准接口。例如：</p><ul><li>在 Linux 中，字符设备驱动实现 <code>read()</code> 和 <code>write()</code> 方法。</li><li>在 Windows 中，驱动程序需实现 I&#x2F;O 请求包（IRP）的处理函数，响应 <code>IRP_MJ_READ</code> 和 <code>IRP_MJ_WRITE</code>。</li></ul><p><strong>这里特别关注的是存储设备，比如磁盘驱动器原理和一系列调度算法</strong>，这里不多介绍，自行百度</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>在解决了与设备通信与驱动后，在诸如存储设备（如硬盘、SSD、USB 等），我们不得不面临如何像管理内存那样<strong>组织、存储、管理和检索数据</strong>。就拿磁盘为例：</p><img src="https://s2.loli.net/2024/12/21/zKfeyVMhHrZuRUD.png" alt="磁盘" style="zoom:50%;" /><p>如何对磁盘上的文件进行组织管理？—<strong>文件系统</strong>应运而生：它为存储设备（上的数据提供了一种结构化的方式，使用户和程序能够以文件和目录的形式高效地访问和管理数据。类比内存可以把每个文件都看作一个独立的地址空间</p><table><thead><tr><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>将物理存储抽象为逻辑结构</strong></td><td>- <strong>物理存储的复杂性</strong>：硬盘以扇区（如 512 字节）为单位存储数据，直接操作扇区会很不便。 - <strong>文件系统的抽象</strong>：通过“文件”和“目录”来组织和管理数据，屏蔽底层物理细节。</td></tr><tr><td><strong>数据组织和查找</strong></td><td>- <strong>无文件系统的情况</strong>：数据可能存储在任意位置，难以高效查找。 - <strong>文件系统的作用</strong>：通过目录结构（如树形结构）和路径组织文件，便于管理和检索数据。</td></tr><tr><td><strong>数据持久性</strong></td><td>- 文件系统确保数据在存储设备断电或系统重启后仍然可用，实现数据长期保存。</td></tr><tr><td><strong>支持多用户和并发访问</strong></td><td>- 通过权限管理，确保用户只能访问自己授权的数据。 - 处理多个进程同时访问同一文件的冲突，保证数据一致性。</td></tr><tr><td><strong>提高存储效率</strong></td><td>- 通过优化存储分配（如簇、块）和读取方式（如顺序读写、索引）提升性能。 - 提供删除、压缩等功能回收或节省存储空间。</td></tr></tbody></table><blockquote><p>接下来的问题便是：如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？</p></blockquote><h2 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h2><blockquote><p>第一个方面是文件系统的数据结构（data structure）。换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？</p><p>文件系统的第二个方面是访问方法（access method）。如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</p></blockquote><h3 id="文件系统的数据结构"><a href="#文件系统的数据结构" class="headerlink" title="文件系统的数据结构"></a>文件系统的数据结构</h3><p>这里以VSFS文件系统为例：</p><p>1.将磁盘分成块（block）。简单的文件系统只使用一种块大小，这里正是这样做的。我们选择常用的4KB。因此，对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。假设我们有一个非常小的磁盘，只有64块：</p><img src="https://s2.loli.net/2024/12/21/ljZu613kvKyEf8p.png" alt="1" style="zoom:50%;" /><blockquote><p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p><ul><li>连续空间存放方式</li><li>非连续空间存放方式</li></ul><p>具体可参考：<a href="https://blog.csdn.net/qq_34827674/article/details/107992414">一口气搞懂「文件系统」，就靠这 25 张图了-CSDN博客</a></p></blockquote><p>2.文件系统必须记录每个文件的信息。该信息是元数据（metadata）的关键部分，并且记录诸如文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息的事情。为了存储这些信息，文件系统通常有一个名为inode的结构</p><img src="https://s2.loli.net/2024/12/21/zF2t6Nip9x7BdOJ.png" alt="2" style="zoom:50%;" /><blockquote><p>文件的存储，注意：多级索引，为了支持更大的文件，文件系统设计者必须在inode中引入不同的结构。一个常见的思路是有一个称为间接指针（indirect pointer）的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将inode的间接指针设置为指向它。</p></blockquote><p>3.还需要某种方法来记录inode或数据块是空闲还是已分配。因此，这种分配结构（allocation structure）是所有文件系统中必需的部分。</p><p><img src="https://s2.loli.net/2024/12/21/vSmqKkoWOUurcBz.png" alt="image-20241221143107283"></p><blockquote><p>空闲空间管理，自行百度</p></blockquote><p>4.还有一块。我们将它保留给超级块（superblock），在下图中用S表示。超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。</p><p><img src="https://s2.loli.net/2024/12/21/HnSauTVIk4Le3bM.png" alt="image-20241221143143501"></p><p>因此，在挂载文件系统时，操作系统将首先读取超级块，初始化各种参数，然后将该卷添加到文件系统树中。当卷中的文件被访问时，系统就会知道在哪里查找所需的磁盘上的结构。</p><p>4.目录项，也就是 <em>dentry</em>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>。</p><p>目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。对于给定目录中的每个文件或目录，目录的数据块中都有一个字符串和一个数字。对于每个字符串，可能还有一个长度（假定采用可变大小的名称）。</p><p>由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p><blockquote><p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p></blockquote><img src="https://s2.loli.net/2024/12/21/CKL46SdPnqyW1xJ.png" alt="4" style="zoom:50%;" /><p>这里继续给出多种不同文件系统的差异：</p><table><thead><tr><th><strong>文件系统</strong></th><th><strong>数据存储方式</strong></th><th><strong>元数据管理方式</strong></th><th><strong>碎片管理机制</strong></th><th><strong>访问效率</strong></th><th><strong>数据保护与可靠性</strong></th><th><strong>特性支持</strong></th></tr></thead><tbody><tr><td><strong>FAT32</strong></td><td>使用链表（FAT 表）记录每个文件的块链表，结构简单，扩展性差</td><td>元数据存储在目录项中，简单，文件属性有限</td><td>没有特别的碎片管理，容易碎片化</td><td>随机访问效率差，大文件查找速度慢</td><td>无日志，不支持数据保护，崩溃时易丢失数据</td><td>支持小文件存储，适合嵌入式系统、U盘等小型存储设备</td></tr><tr><td><strong>NTFS</strong></td><td>使用 B+树结构索引文件数据位置，支持稀疏文件，优化存储空间</td><td>使用 MFT（主文件表）存储文件及其属性，支持复杂属性（如 ACL 权限）</td><td>通过延迟分配减少碎片，但仍需定期碎片整理</td><td>随机读写性能较高，适合桌面和企业级应用</td><td>支持元数据日志，能恢复文件系统结构，防止崩溃数据丢失</td><td>支持文件压缩、加密（EFS）、权限控制等，适合 Windows 系统</td></tr><tr><td><strong>ext4</strong></td><td>使用多级索引表（类似树结构）管理数据块，支持高效的文件存储</td><td>使用 inode 表存储文件和属性，支持文件权限、软硬链接等</td><td>通过延迟分配和预分配减少碎片化，效率较高</td><td>支持顺序和随机读写，适合小文件和大文件的访问</td><td>提供日志功能，确保系统崩溃后不丢失文件元数据</td><td>支持硬链接、软链接、日志功能，适用于 Linux 系统</td></tr><tr><td><strong>XFS</strong></td><td>延迟分配技术，优化数据块分配以减少碎片化</td><td>使用索引节点管理元数据，支持并发访问和高性能读写</td><td>延迟分配技术避免碎片化，适合大文件存储</td><td>对大文件和并发访问优化，适合高负载、高性能需求的环境</td><td>支持元数据日志，确保高可靠性，防止数据丢失</td><td>适合处理大文件和高负载，广泛用于高性能服务器环境</td></tr><tr><td><strong>APFS</strong></td><td>基于 CoW（Copy-on-Write）技术，避免直接覆盖数据，优化 SSD 性能</td><td>支持元数据快照，适合 SSD 存储的快速读写</td><td>通过 CoW 技术避免碎片化，适合 SSD</td><td>快速随机读写，优化 SSD 性能</td><td>基于快照和加密功能，能恢复系统状态，防止数据丢失</td><td>支持 SSD 优化、快照、文件加密、文件克隆等，适合 macOS 环境</td></tr><tr><td><strong>ZFS</strong></td><td>使用块指针树结构管理数据块，支持多级镜像和校验</td><td>使用分层的数据结构存储元数据，支持元数据校验</td><td>CoW 技术避免碎片化，支持数据去重和压缩</td><td>高效的数据读取和写入，适合大数据量顺序访问和高并发环境</td><td>提供端到端数据校验，支持自修复功能，适合大规模存储和企业级应用</td><td>支持数据去重、快照、镜像、动态块分配等功能，适合云存储、企业备份等</td></tr></tbody></table><ul><li><strong>数据存储方式</strong>：描述文件系统如何组织和存储数据。文件系统使用不同的数据结构（如链表、B+树、块指针树等）来管理数据。</li><li><strong>元数据管理方式</strong>：解释文件系统如何管理文件的元数据（如文件名、权限、时间戳、文件大小等）。</li><li><strong>碎片管理机制</strong>：描述文件系统如何处理碎片化问题。碎片化会降低文件访问效率，一些文件系统通过延迟分配、预分配或 CoW 技术来减少碎片化。</li><li><strong>访问效率</strong>：比较文件系统在数据访问中的效率，尤其是随机访问和大文件的读写性能。</li><li><strong>数据保护与可靠性</strong>：描述文件系统如何保护数据不受损失，防止系统崩溃或断电导致的数据丢失。大多数现代文件系统支持日志记录和数据校验来提高可靠性。</li><li><strong>特性支持</strong>：列出了每种文件系统所支持的特性，如文件加密、压缩、权限管理、快照、去重等。</li></ul><h4 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h4><p>可以看到文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。</p><p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。</p><img src="https://s2.loli.net/2024/12/21/dqhFmucZUt9GaP3.png" alt="VFS" style="zoom:50%;" /><p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p><strong>文件系统的挂载（Mounting）</strong> 是将存储设备或分区上的文件系统连接到操作系统的文件层次结构中的一个过程。挂载的目的是使得存储设备上的数据可以被操作系统访问和管理。（指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。）</p><p>Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 inux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统（文件目录结构）。</p><blockquote><p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p></blockquote><p>如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p><blockquote><p>并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p></blockquote><h5 id="具体解释："><a href="#具体解释：" class="headerlink" title="具体解释："></a>具体解释：</h5><p>在现代操作系统中，文件系统以树状结构组织数据，这棵树的根节点称为“根目录”（<code>/</code>）。挂载就是将一个存储设备或分区的文件系统（如硬盘、SSD、U盘等）与操作系统的现有文件系统结构中的某个目录连接起来，使得该设备上的文件和目录可以像本地文件一样被访问。</p><h5 id="挂载过程："><a href="#挂载过程：" class="headerlink" title="挂载过程："></a><strong>挂载过程：</strong></h5><ol><li><strong>设备准备</strong>：首先，操作系统会识别并准备好存储设备（如硬盘、SSD、USB设备等）。</li><li><strong>挂载命令</strong>：系统管理员或用户使用挂载命令（在 Linux 中是 <code>mount</code>）指定要挂载的设备和目标目录。</li><li><strong>文件系统关联</strong>：文件系统将设备上的文件系统结构与操作系统文件树中的指定目录进行连接。这使得设备上的文件能够通过目标目录路径访问。</li></ol><p>更具体的过程可以参考：<a href="https://blog.csdn.net/weixin_47763623/article/details/143710029">深入理解Linux文件系统的挂载过程_文件挂载-CSDN博客</a></p><h5 id="挂载点的意义："><a href="#挂载点的意义：" class="headerlink" title="挂载点的意义："></a><strong>挂载点的意义：</strong></h5><p>挂载点是文件系统挂载的具体目录。在挂载完成后，存储设备的文件系统会表现得像是文件树的一部分，可以通过挂载点来访问设备上的数据。挂载点可以是任何空目录，而不仅仅是 <code>/mnt</code> 或 <code>/media</code>。</p><h3 id="文件系统的访问方法"><a href="#文件系统的访问方法" class="headerlink" title="文件系统的访问方法"></a>文件系统的访问方法</h3><h4 id="从磁盘读取文件"><a href="#从磁盘读取文件" class="headerlink" title="从磁盘读取文件"></a>从磁盘读取文件</h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起读取请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>read()</code>）发起文件读取请求。</td></tr><tr><td><strong>2. 操作系统进行文件查找</strong></td><td>操作系统解析文件路径，查找文件的元数据（如 inode 或 MFT），确定文件的存储位置。</td></tr><tr><td><strong>3. 获取物理块地址</strong></td><td>操作系统根据文件的元数据找到文件数据的物理块位置。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统将文件的数据块地址传递给磁盘设备驱动程序，驱动程序负责访问磁盘并读取数据块。</td></tr><tr><td><strong>5. 磁盘控制器读取数据</strong></td><td>磁盘控制器根据操作系统的请求，定位并读取物理磁盘上相应的扇区或块，传输数据到内存。</td></tr><tr><td><strong>6. 数据传输到内存</strong></td><td>磁盘控制器将读取的数据传输到内存缓存中，操作系统将数据保存到内存中，准备将其传递给应用程序。</td></tr><tr><td><strong>7. 文件数据返回给应用程序</strong></td><td>操作系统将数据从内存传输到用户空间，应用程序可以对文件数据进行处理。</td></tr><tr><td><strong>8. 缓存和优化</strong></td><td>操作系统和磁盘控制器可能会使用缓存机制（如页面缓存、硬盘缓存）来优化数据访问速度，减少磁盘访问次数。</td></tr></tbody></table><h4 id="写入磁盘"><a href="#写入磁盘" class="headerlink" title="写入磁盘"></a><strong>写入磁盘</strong></h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 用户&#x2F;应用程序发起写入请求</strong></td><td>用户或应用程序通过系统调用（如 <code>open()</code> 和 <code>write()</code>）发起写入请求，指定要写入的数据内容和目标文件。操作系统获取数据并准备写入磁盘。</td></tr><tr><td><strong>2. 操作系统检查文件描述符</strong></td><td>操作系统检查应用程序提供的文件描述符，确保文件已经被打开并且可以写入。如果文件是可写的，系统会继续处理；如果是只读文件，则会报错。</td></tr><tr><td><strong>3. 获取文件的物理存储位置</strong></td><td>操作系统查找文件的元数据（如 inode），确定文件的存储位置（磁盘上的数据块）。如果文件是新创建的，操作系统可能需要为文件分配新的磁盘块。</td></tr><tr><td><strong>4. 调用块设备驱动程序</strong></td><td>操作系统通过文件系统向块设备驱动程序发出写入请求，传递数据块的地址以及要写入的数据。设备驱动程序准备与磁盘或 SSD 进行交互，确保数据能正确写入。</td></tr><tr><td><strong>5. 数据写入磁盘控制器</strong></td><td>磁盘控制器收到写入请求后，将数据写入到磁盘的特定物理扇区或块中。如果是硬盘，磁头会移动到正确的位置；如果是 SSD，数据直接写入对应的闪存单元。</td></tr><tr><td><strong>6. 数据确认</strong></td><td>写入操作完成后，磁盘控制器向操作系统确认数据已经成功写入。数据也可能被缓存到内存中，以便未来的读取请求。</td></tr><tr><td><strong>7. 更新文件元数据</strong></td><td>操作系统更新文件的元数据（如 inode），以反映文件的最新状态（例如，更新文件大小、修改时间等）。如果数据被追加到文件末尾，操作系统也会更新文件的尾部地址。</td></tr><tr><td><strong>8. 应用程序收到写入结果</strong></td><td>操作系统返回写入操作的结果（如成功或失败），并可能将写入的数据缓存到内存中，以便在后续操作中提高性能。应用程序可以进行进一步处理或关闭文件。</td></tr><tr><td><strong>9. 缓存和优化</strong></td><td>操作系统可能会将写入的数据保留在内存中的缓存中，减少后续的磁盘写入次数，并在合适的时候将数据刷新到磁盘。磁盘控制器也可能使用其内部缓存进行写入操作优化。</td></tr></tbody></table><blockquote><ol><li>文件必须已经打开并且具有写权限。</li><li>操作系统通过文件描述符来标识文件，并管理文件的元数据和数据存储。</li><li>写入过程可能涉及数据缓存，以提高磁盘写入效率。</li></ol></blockquote><h4 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h4><p>和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</p><p>在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p><p>列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。</p><p><img src="https://s2.loli.net/2024/12/21/2nDUmwNpIYa4yHP.png" alt="目录"></p><p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p><img src="https://s2.loli.net/2024/12/21/3JgNmYFdju81Xfo.png" alt="硬链接"></p><p>软链接相当于重新创建一个文件，这个文件有<strong>独立的 inode</strong>，但是这个<strong>文件的内容是另外一个文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可以跨文件系统的</strong>，甚至<strong>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</strong></p><p><img src="https://s2.loli.net/2024/12/21/tNaVmgeKGuC5xdQ.png" alt="软链接"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符（<strong>File Descriptor</strong>，简称 <strong>FD</strong>）是操作系统层面上用于标识打开的文件的一个整数标识符。在操作系统中，文件描述符存在于用户空间和内核空间之间，通常是在 <strong>操作系统的内核层</strong> 中使用的。</p><h5 id="与文件描述符相关的层次和流程："><a href="#与文件描述符相关的层次和流程：" class="headerlink" title="与文件描述符相关的层次和流程："></a><strong>与文件描述符相关的层次和流程：</strong></h5><ol><li>用户空间<ul><li>在用户空间，应用程序通过标准库（如 <code>libc</code>）发起文件操作。库会通过系统调用（如 <code>open()</code>）请求操作系统打开文件。</li><li>应用程序通过文件描述符来与内核交互，使用它来进行文件读写（例如，使用 <code>read()</code>、<code>write()</code> 等函数）。</li></ul></li><li>内核空间<ul><li>操作系统内核使用文件描述符来标识进程打开的文件，并维护与文件相关的状态信息。这些信息通常存储在 <strong>文件表</strong> 中。</li><li>当进程发起文件操作时，内核根据文件描述符查找文件表中的条目，找到文件的元数据并执行实际的文件I&#x2F;O操作。</li><li>每个进程都有一个与之关联的<strong>文件描述符表</strong>，它存储了该进程打开的所有文件的文件描述符以及与这些文件相关的内核信息。</li></ul></li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://zhuanlan.zhihu.com/p/404423676">计算机组成原理笔记-IO接口与设备 - 知乎</a></p><p><a href="https://www.cnblogs.com/cxuanBlog/p/12565601.html">简直不要太硬了！一文带你彻底理解文件系统 - 程序员cxuan - 博客园</a></p><p><a href="https://www.cnblogs.com/cangqinglang/p/12170828.html">什么是挂载，Linux挂载如何实现详解 - 苍青浪 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU虚拟化与进程</title>
    <link href="/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/01/10/CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟化-美丽的假象"><a href="#虚拟化-美丽的假象" class="headerlink" title="虚拟化(美丽的假象)"></a>虚拟化(美丽的假象)</h1><p>假设一个计算机只有一个CPU，虚拟化要做的就是将这个CPU虚拟成多个虚拟CPU并分给每一个进程使用，通过<strong>时间分片调度</strong>和<strong>资源隔离</strong>技术，操作系统 会将这个物理 CPU 的使用时间切分成多个时间片，并分配给不同的进程或虚拟机使用。因此，每个应用都以为自己在独占CPU，但实际上只有一个CPU。这样操作系统就创造了美丽的假象——它虚拟化了CPU。</p><h2 id="更好的实现CPU的虚拟化"><a href="#更好的实现CPU的虚拟化" class="headerlink" title="更好的实现CPU的虚拟化"></a>更好的实现CPU的虚拟化</h2><h3 id="机制-受限直接执行"><a href="#机制-受限直接执行" class="headerlink" title="机制(受限直接执行)"></a>机制(受限直接执行)</h3><h4 id="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"><a href="#第一个是性能：如何在不增加系统开销的情况下实现虚拟化？" class="headerlink" title="第一个是性能：如何在不增加系统开销的情况下实现虚拟化？"></a>第一个是性能：如何在不增加系统开销的情况下实现虚拟化？</h4><p>只需直接在CPU上运行程序即可。因此，当OS希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。表6.1展示了这种基本的直接执行协议（没有任何限制），使用正常的调用并返回跳转到程序的main()，并在稍后回到内核。</p><p><img src="https://s2.loli.net/2024/12/22/QWOf38Za9AJXYgI.png" alt="image-20241222173814892"></p><h4 id="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"><a href="#第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？" class="headerlink" title="第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？"></a>第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？</h4><p>控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。</p><h5 id="一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"><a href="#一个进程必须能够执行I-O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？" class="headerlink" title="一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？"></a>一个进程必须能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？</h5><p>引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制。例如，在用户模式下运行时，进程不能发出I&#x2F;O请求。这样做会导致处理器引发异常，操作系统可能会终止进程。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出I&#x2F;O请求和执行所有类型的受限指令。</p><h6 id="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"><a href="#如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？" class="headerlink" title="如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？"></a>如果用户希望执行某种特权操作（如从磁盘读取），应该怎么做？</h6><p>提供用户程序执行系统调用的能力。它允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统、创建和销毁进程、与其他进程通信，以及分配更多内存。</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</p><p><strong>陷阱如何知道在OS内运行哪些代码？</strong></p><p>发起调用的过程不能指定要跳转到的地址，这样做让程序可以跳转到内核中的任意位置，这显然是一个糟糕的主意（想象一下跳到访问文件的代码，但在权限检查之后。实际上，这种能力很可能让一个狡猾的程序员令内核运行任意代码序列）。因此内核必须谨慎地控制在陷阱上执行的代码。</p><p>内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。例如，当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该运行哪些代码？操作系统通常通过某种特殊的指令，通知硬件这些陷阱处理程序的位置。一旦硬件被通知，它就会记住这些处理程序的位置，直到下一次重新启动机器，并且硬件知道在发生系统调用和其他异常事件时要做什么（即跳转到哪段代码）。</p><img src="https://s2.loli.net/2024/12/22/sUVZq4RxSLJcn5p.png" alt="image-20241222174427511" style="zoom:25%;" /><h5 id="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"><a href="#操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？" class="headerlink" title="操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？"></a>操作系统如何重新获得CPU的控制权，以便它可以在进程之间切换？</h5><p>悖论：如果一个进程在CPU上运行，这就意味着操作系统没有运行。如果操作系统没有运行，它怎么能做事情？</p><h6 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h6><p>操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。大多数进程通过进行系统调用，将CPU的控制权转移给操作系统，例如打开文件并随后读取文件，或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个显式的yield系统调用，它什么都不干，只是将控制权交给操作系统，以便系统可以运行其他进程。</p><p>如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以0为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制CPU（并可能终止违规进程）。</p><p>缺点：如果某个进程（无论是恶意的还是充满缺陷的）进入无限循环，并且从不进行系统调用，会发生什么情况？那时操作系统能做什么？</p><p>即使进程不协作，操作系统如何获得CPU的控制权？操作系统可以做什么来确保流氓进程不会占用机器？</p><h6 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h6><blockquote><p>时钟中断（timer interrupt）[M+63]。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p></blockquote><p>首先，操作系统必须通知硬件哪些代码在发生时钟中断时运行。因此，在启动时，操作系统就是这样做的。其次，在启动过程中，操作系统也必须启动时钟，这当然是一项特权操作。一旦时钟开始运行，操作系统就感到安全了，因为控制权最终会归还给它，因此操作系统可以自由运行用户程序。时钟也可以关闭（也是特权操作），</p><h6 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h6><p>当操作系统重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。</p><p>如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换（context switch）。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p><p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222175204613.png" alt="2" style="zoom:25%;" /><p>在此协议中，有两种类型的寄存器保存&#x2F;恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p><strong>该如何开发一个考虑调度策略的基本框架？什么是关键假设？哪些指标非常重要？</strong></p><blockquote><p>进程调度算法有很多也很重要这里只做概览性简单介绍，后续会单独讲解</p></blockquote><p><strong>进程调度</strong>是指操作系统为多个进程分配CPU资源的机制，它决定了在任意时刻哪个进程可以使用CPU进行执行。由于系统资源（尤其是CPU）是有限的，而进程通常多于可用的资源，因此需要通过进程调度来公平、高效地管理资源使用。</p><hr><h4 id="进程调度的核心内容"><a href="#进程调度的核心内容" class="headerlink" title="进程调度的核心内容"></a><strong>进程调度的核心内容</strong></h4><table><thead><tr><th><strong>内容</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>调度目标</strong></td><td>在多任务系统中高效利用资源，减少等待时间，保证系统响应和吞吐量。</td></tr><tr><td><strong>调度时机</strong></td><td>- <strong>进程状态变化时</strong>（如运行态到阻塞态）。- <strong>时间片到期</strong>。</td></tr><tr><td><strong>调度算法</strong></td><td>操作系统采用的算法决定了进程调度的公平性与效率。</td></tr><tr><td><strong>调度方式</strong></td><td>可分为抢占式调度和非抢占式调度。</td></tr></tbody></table><hr><h4 id="进程调度的关键步骤"><a href="#进程调度的关键步骤" class="headerlink" title="进程调度的关键步骤"></a><strong>进程调度的关键步骤</strong></h4><table><thead><tr><th><strong>步骤</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>1. 进程分类</strong></td><td>区分就绪、运行、阻塞等状态的进程。</td></tr><tr><td><strong>2. 选择进程</strong></td><td>根据调度算法从就绪队列中选取一个进程。</td></tr><tr><td><strong>3. 分配资源</strong></td><td>将CPU资源分配给选定的进程，并切换上下文。</td></tr><tr><td><strong>4. 开始运行</strong></td><td>进程获得CPU后，从上次暂停处继续执行或从头开始执行。</td></tr></tbody></table><hr><h4 id="常见的调度算法"><a href="#常见的调度算法" class="headerlink" title="常见的调度算法"></a><strong>常见的调度算法</strong></h4><table><thead><tr><th><strong>算法</strong></th><th><strong>说明</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>先来先服务（FCFS）</strong></td><td>按到达顺序调度进程，简单但可能导致较长的等待时间。</td><td>任务简单、实时性要求不高的系统。</td></tr><tr><td><strong>短作业优先（SJF）</strong></td><td>优先调度执行时间最短的进程，可能会导致长任务饥饿。</td><td>作业时间可预测的批处理系统。</td></tr><tr><td><strong>时间片轮转（RR）</strong></td><td>每个进程分配固定时间片，时间到则切换到下一个进程。</td><td>交互式系统，例如桌面操作系统。</td></tr><tr><td><strong>优先级调度</strong></td><td>根据进程优先级调度，优先级高的进程先运行。</td><td>实时系统或对任务重要性有要求的环境。</td></tr><tr><td><strong>多级反馈队列调度</strong></td><td>根据进程特性动态调整优先级，综合性较强。</td><td>通用系统，例如桌面和服务器操作系统。</td></tr></tbody></table><hr><h4 id="调度方式"><a href="#调度方式" class="headerlink" title="调度方式"></a><strong>调度方式</strong></h4><table><thead><tr><th><strong>方式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>非抢占式调度</strong></td><td>进程一旦占用CPU，直到主动放弃或阻塞，才切换到其他进程。</td></tr><tr><td><strong>抢占式调度</strong></td><td>操作系统可以强制中断正在运行的进程，将CPU分配给其他进程。</td></tr></tbody></table><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程（Process）是操作系统中程序的一个运行实例<strong>。它是程序在计算机上的一次</strong>动态执行，包括程序代码和其运行时需要的所有资源。从操作系统的角度看，进程是资源分配的最小单位，也是程序执行的基本单位。【进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。】</p><p><strong>进程的机器状态构成</strong>：程序在运行时可以读取或更新的内容。在任何时刻，机器的哪些部分对执行该程序很重要。</p><ul><li>内存：指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</li><li>寄存器：许多指令明确地读取或更新寄存器，因此显然，它们对于执行该进程很重要。</li><li>I&#x2F;O信息：程序也经常访问持久存储设备。此类I&#x2F;O信息可能包含当前打开的文件列表。</li></ul><p><strong>如何将程序转化为进程？</strong></p><table><thead><tr><th><strong>步骤</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>1. 调用系统接口</strong></td><td>使用系统调用创建进程，例如：<code>fork()</code>（Linux）或 <code>CreateProcess()</code>（Windows）。</td></tr><tr><td><strong>2. 分配资源</strong></td><td>为进程分配内存（代码段、数据段、栈段）、文件句柄、I&#x2F;O 缓冲区等。</td></tr><tr><td><strong>3. 加载程序</strong></td><td>将程序的代码和数据从磁盘加载到内存，并为其分配独立的地址空间。</td></tr><tr><td><strong>4. 初始化 PCB</strong></td><td>设置进程控制块（PCB），记录进程 ID、状态、程序计数器等信息。</td></tr><tr><td><strong>5. 设置运行环境</strong></td><td>初始化寄存器、栈指针，设置全局变量和静态变量的初始值。</td></tr><tr><td><strong>6. 加入调度队列</strong></td><td>将新创建的进程放入操作系统的就绪队列，等待调度器分配 CPU。</td></tr><tr><td><strong>7. 开始执行</strong></td><td>调度器分配 CPU 后，进程从入口地址（如 <code>main()</code>）开始执行。</td></tr></tbody></table><h2 id="进程状态及其演变"><a href="#进程状态及其演变" class="headerlink" title="进程状态及其演变"></a>进程状态及其演变</h2><p><img src="C:/Users/11252/AppData/Roaming/Typora/typora-user-images/image-20241222180155226.png" alt="3"></p><h3 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h3><p>为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——**进程控制块PCB(Process Control Block)**，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。操作系统通过PCB来跟踪和控制进程的运行状态。</p><h4 id="PCB-的作用机制"><a href="#PCB-的作用机制" class="headerlink" title="PCB 的作用机制"></a><strong>PCB 的作用机制</strong></h4><ol><li><strong>进程切换时的角色</strong><ul><li>当发生进程切换时，操作系统将当前进程的CPU状态保存到PCB中，并从新进程的PCB中恢复CPU状态。</li><li>PCB中的上下文信息决定了进程可以从上次暂停的位置继续执行。</li></ul></li><li><strong>进程调度中的作用</strong><ul><li>调度器通过PCB判断进程的状态、优先级等信息，从而选择适合的进程运行。</li></ul></li><li><strong>进程通信中的作用</strong><ul><li>PCB中记录了进程间通信所需的信息，如共享内存的指针等。</li></ul></li></ol><h4 id="PCB-的组成"><a href="#PCB-的组成" class="headerlink" title="PCB 的组成"></a><strong>PCB 的组成</strong></h4><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>1. 进程标识信息</strong></td><td>- <strong>进程ID</strong>：唯一标识进程的ID号。 - <strong>父进程ID</strong>：创建它的父进程的ID号。</td></tr><tr><td><strong>2. 进程状态信息</strong></td><td>- 当前进程的状态（如就绪、运行、阻塞）。 - 优先级、调度信息等。</td></tr><tr><td><strong>3. CPU寄存器信息</strong></td><td>- 进程切换时保存的寄存器值，如程序计数器、堆栈指针等。</td></tr><tr><td><strong>4. 内存管理信息</strong></td><td>- 指向进程地址空间的指针（如页表指针）。</td></tr><tr><td><strong>5. 文件管理信息</strong></td><td>- 进程打开的文件列表、文件描述符表等。</td></tr><tr><td><strong>6. 资源分配信息</strong></td><td>- 占用的资源信息（如I&#x2F;O设备、信号量等）。</td></tr><tr><td><strong>7. 其他信息</strong></td><td>- 进程所属用户信息、信号处理机制等。</td></tr></tbody></table><h4 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h4><p><strong>线性方式</strong>：将系统种所有PCB都组织在一张线性表中，将该表首地址存在内存的一个专用区域<br>实现简单，开销小，但是每次都需要扫描整张表，适合进程数目不多的系统</p><p><strong>链接方式</strong>：把同一状态的PCB链接成一个队列，形成就绪队列、若干个阻塞队列和空白队列等<br>对其中的就绪队列常按进程优先级的高低排列，优先级高排在队前，此外，也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I&#x2F;O 操作完成的队列和等待分配内存的队列等</p><img src="https://s2.loli.net/2024/12/22/NDSmHrP96vz3URs.png" alt="1" style="zoom: 50%;" /><p><strong>索引方式</strong>：系统根据所有进程的状态建立几张索引表，例如就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中，在每个索引表的表目中，记录具有相应状态的某个PCB在PCB址</p><img src="https://s2.loli.net/2024/12/22/g7KiEPcd14eRoOB.png" alt="2" style="zoom:50%;" /><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h3><h4 id="什么是父子进程？"><a href="#什么是父子进程？" class="headerlink" title="什么是父子进程？"></a>什么是父子进程？</h4><p>在 Unix 和 Linux中，每个进程都有一个唯一的进程标识符（PID），以及一个父进程标识符（PPID），这两个值使得子进程能够知道它们的父进程是什么。</p><ol><li><strong>PID（Process ID）</strong>：这是操作系统分配给每个进程的唯一标识符。每个进程都有一个唯一的 PID。</li><li><strong>PPID（Parent Process ID）</strong>：这是进程的父进程的 PID。PPID 指示了哪个进程创建了当前进程。</li></ol><p>当进程 A 调用 <code>fork()</code> 时，会创建一个子进程 B。对于子进程 B，它的 PPID 会被设置为进程 A 的 PID。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Process</span> A: PID = <span class="hljs-number">12345</span><br>Parent process: PID = <span class="hljs-number">12345</span>, Child PID = <span class="hljs-number">12346</span><br>Child process: PID = <span class="hljs-number">12346</span>, PPID = <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p><strong>同时父进程会获得一个非零的PID（子进程的PID），而子进程会获得0作为返回值。这使得我们可以通过检查返回值的大小来区分父子进程</strong></p><p><strong>注意这里的返回0并不是将子进程PID设为0</strong>，而是出于以下方面考虑：</p><ul><li><p><strong>区分父进程和子进程的执行流</strong></p><p>当调用 <code>fork()</code> 时，会创建一个新的子进程。<code>fork()</code> 在父进程中返回子进程的 PID，而在子进程中返回 0。这种设计让同一段代码能够在两个不同的进程中执行不同的逻辑。</p></li><li><p><strong>简化错误处理</strong></p><p>如果 <code>fork()</code> 返回一个负值（通常是 -1），这表明进程创建失败。父进程可以立即检查这个返回值并进行相应的错误处理。</p></li><li><p><strong>方便进程间通信和同步</strong></p><p>由于 <code>fork()</code> 在子进程中返回 0，父进程可以使用返回的子进程 PID 来进行进程间的通信和同步操作。例如，父进程可以等待子进程结束，或者通过信号与子进程进行通信。</p></li><li><p><strong>实现多进程并发</strong></p><p><code>fork()</code> 机制使得多进程并发编程变得简单。父进程可以连续调用 <code>fork()</code> 多次，创建多个子进程来处理不同的任务或相同任务的不同部分，从而实现并发处理。</p></li></ul><h4 id="1-进程创建阶段"><a href="#1-进程创建阶段" class="headerlink" title="1. 进程创建阶段"></a><strong>1. 进程创建阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>分配标识</strong></td><td>操作系统为每个新进程分配唯一的进程ID（PID），并在PCB表中为其预留存储位置。</td><td>父进程通过系统调用（如 <code>fork()</code>）创建子进程，子进程获得一个新的PID。</td></tr><tr><td><strong>分配资源</strong></td><td>- 内存分配：分配进程代码段、数据段和堆栈段的内存空间。- 文件表：初始化文件描述符表。</td><td>子进程继承父进程的部分资源（如文件描述符、内存空间的副本）。</td></tr><tr><td><strong>初始化PCB</strong></td><td>初始化PCB内容，包括进程状态设为“就绪”，设置优先级、调度信息等。</td><td>父进程创建子进程时，操作系统会为子进程初始化PCB并赋予初始状态。</td></tr><tr><td><strong>添加到队列</strong></td><td>将新创建的PCB插入到就绪队列中，等待调度程序选中执行。</td><td>父进程和子进程的PCB都被添加到就绪队列中，操作系统会调度执行。</td></tr></tbody></table><h4 id="2-进程执行阶段"><a href="#2-进程执行阶段" class="headerlink" title="2. 进程执行阶段"></a><strong>2. 进程执行阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>调度选择</strong></td><td>调度程序根据进程调度算法（如时间片轮转、优先级调度等），从就绪队列中选取合适进程。</td><td>父进程和子进程都在就绪队列中，操作系统根据调度算法选择其中一个进程执行。</td></tr><tr><td><strong>上下文切换</strong></td><td>- 保存当前运行进程的CPU状态（如寄存器内容、程序计数器）到PCB。- 恢复新进程的CPU状态。</td><td>在父进程和子进程之间，操作系统通过上下文切换保存和恢复进程的状态。</td></tr><tr><td><strong>执行控制</strong></td><td>CPU执行新进程的指令，同时操作系统监控该进程的运行，处理系统调用、中断等事件。</td><td>父进程和子进程在独立的进程空间中执行，操作系统管理并监控它们的运行。</td></tr></tbody></table><h4 id="3-进程阻塞阶段"><a href="#3-进程阻塞阶段" class="headerlink" title="3. 进程阻塞阶段"></a><strong>3. 进程阻塞阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>状态更新</strong></td><td>操作系统将进程的状态从“运行”改为“阻塞”，更新PCB中的状态字段。</td><td>父进程和子进程都可以进入阻塞状态，当它们等待资源或事件时，操作系统会更新其PCB。</td></tr><tr><td><strong>队列管理</strong></td><td>将进程从运行队列移至等待队列，等待资源或事件完成后重新激活。</td><td>被阻塞的父进程或子进程会被移至等待队列，直到事件触发后再次唤醒。</td></tr><tr><td><strong>资源释放</strong></td><td>在阻塞时释放占用的CPU资源，允许调度程序将CPU分配给其他就绪进程。</td><td>阻塞的进程（父进程或子进程）释放CPU资源，操作系统可调度其他进程执行。</td></tr></tbody></table><h4 id="4-进程唤醒阶段"><a href="#4-进程唤醒阶段" class="headerlink" title="4. 进程唤醒阶段"></a><strong>4. 进程唤醒阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>事件触发</strong></td><td>某事件（如I&#x2F;O完成、信号量释放）触发时，通知操作系统唤醒等待的进程。</td><td>子进程阻塞后，当事件触发时，操作系统会唤醒子进程，父进程也可以因为等待子进程结果而被唤醒。</td></tr><tr><td><strong>状态更新</strong></td><td>将进程状态从“阻塞”修改为“就绪”，并更新PCB。</td><td>被唤醒的进程（父进程或子进程）会更新其PCB状态为“就绪”。</td></tr><tr><td><strong>队列操作</strong></td><td>将该进程的PCB从等待队列移至就绪队列，等待调度程序再次选中运行。</td><td>父进程和子进程的PCB会移至就绪队列，等待操作系统再次调度。</td></tr></tbody></table><h4 id="5-进程终止阶段"><a href="#5-进程终止阶段" class="headerlink" title="5. 进程终止阶段"></a><strong>5. 进程终止阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>释放资源</strong></td><td>- 内存释放：释放分配给进程的内存区域。- 文件关闭：关闭进程打开的文件。</td><td>子进程在终止时，释放资源，父进程回收子进程的资源。</td></tr><tr><td><strong>更新PCB</strong></td><td>修改PCB状态为“终止”，从进程表中移除对应记录。</td><td>父进程可能需要处理子进程的终止，更新父进程的状态和资源。</td></tr><tr><td><strong>回收PID</strong></td><td>将进程ID (PID) 回收到操作系统的可用PID池中。</td><td>子进程终止后，其PID被回收，操作系统可分配给新创建的进程。</td></tr><tr><td><strong>通知父进程</strong></td><td>如果是子进程终止，向父进程发送通知（如信号）以处理终止后的资源回收。</td><td>操作系统通过信号（如 <code>SIGCHLD</code>）通知父进程子进程的终止，父进程可回收子进程的资源。</td></tr></tbody></table><h4 id="6-异常处理阶段"><a href="#6-异常处理阶段" class="headerlink" title="6. 异常处理阶段"></a><strong>6. 异常处理阶段</strong></h4><table><thead><tr><th>阶段</th><th>实现原理</th><th>父子进程关系</th></tr></thead><tbody><tr><td><strong>中断触发</strong></td><td>当异常发生时，硬件触发中断信号，并将控制权交给操作系统内核的异常处理程序。</td><td>如果父进程或子进程发生异常，操作系统通过中断处理并决定是否终止进程。</td></tr><tr><td><strong>状态保存</strong></td><td>操作系统保存当前进程的状态，以便后续恢复或终止。</td><td>操作系统在处理父进程或子进程的异常时，保存进程状态并采取适当措施。</td></tr><tr><td><strong>异常处理</strong></td><td>- 执行适当的处理策略： 1. 终止进程（如访问非法内存）。 2. 恢复运行（如页错误处理）。</td><td>异常可能导致父进程或子进程的终止或恢复。</td></tr><tr><td><strong>日志记录</strong></td><td>操作系统记录异常信息（如错误码、进程ID）以供系统管理员或开发者调试。</td><td>异常处理日志有助于父进程和子进程的调试和故障排除。</td></tr></tbody></table><h4 id="其他进程创建方式"><a href="#其他进程创建方式" class="headerlink" title="其他进程创建方式"></a>其他进程创建方式</h4><table><thead><tr><th><strong>创建方式</strong></th><th><strong>描述</strong></th><th><strong>典型例子</strong></th></tr></thead><tbody><tr><td><strong>父进程创建子进程</strong></td><td>最常见的进程创建方式，父进程通过系统调用（如 <code>fork()</code> 或 <code>CreateProcess()</code>）创建子进程，子进程继承父进程的部分属性。</td><td>- Unix&#x2F;Linux：<code>fork()</code>- Windows：<code>CreateProcess()</code></td></tr><tr><td><strong>操作系统初始化进程</strong></td><td>操作系统在启动时直接创建一些基础进程，例如初始化进程（如 <code>init</code> 或 <code>systemd</code>）。</td><td>- Linux：<code>init</code> 或 <code>systemd</code>- Windows：<code>System</code></td></tr><tr><td><strong>内核进程</strong></td><td>内核或系统进程在启动时由操作系统内核直接创建，不依赖传统的父进程。这些进程通常由内核的初始化逻辑启动。</td><td>- Linux：<code>kthreadd</code>（内核线程）- Windows：内核线程</td></tr><tr><td><strong>线程创建</strong></td><td>线程是进程中的轻量级任务，线程由进程创建，但并非子进程。它们共享进程的资源，如内存空间和文件描述符。</td><td>- Linux&#x2F;Windows：线程由进程（父进程）创建，通常通过 <code>pthread_create()</code> 或 <code>CreateThread()</code> 调用。</td></tr><tr><td><strong>自身创建（自我复制）</strong></td><td>某些程序（如恶意软件或病毒）可能通过自身复制来创建新的进程，而不依赖任何特定的父进程。</td><td>- 恶意软件&#x2F;病毒通过 <code>fork()</code> 或其他方法自我复制。</td></tr></tbody></table><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步是指多个进程在并发执行时，为了避免由于共享资源访问冲突而导致的不一致性或错误，采取的一些技术手段和机制。进程同步的目的是确保多个进程在执行时能够协调一致地访问共享资源，以避免竞态条件（race condition）、数据不一致等问题。</p><blockquote><p>这一部分将在后来文章的并发部分介绍</p></blockquote><h2 id="进程通信（IPC）"><a href="#进程通信（IPC）" class="headerlink" title="进程通信（IPC）"></a>进程通信（IPC）</h2><p>进程通信主要解决的是 <strong>如何在不同进程之间传递信息或共享数据</strong>。当多个进程需要交换数据、共享资源时，操作系统提供不同的进程通信机制。</p><h3 id="1-管道（Pipe）"><a href="#1-管道（Pipe）" class="headerlink" title="1. 管道（Pipe）"></a>1. <strong>管道（Pipe）</strong></h3><p>Linux的管道机制允许一个进程的输出直接作为另一个进程的输入，从而实现进程间的通信（IPC）。管道有两种：无名管道和命名管道（FIFO）。无名管道通常用于具有亲缘关系的进程之间的通信（如父子进程），而命名管道可以用于任意两个进程之间的通信。</p><h4 id="管道的工作原理"><a href="#管道的工作原理" class="headerlink" title="管道的工作原理"></a>管道的工作原理</h4><p>管道在内核中创建一个缓冲区，一个进程可以向缓冲区写入数据，另一个进程可以从缓冲区读取数据。管道是单向的，即数据只能单方向流动。</p><p><img src="https://s2.loli.net/2024/05/29/WOejUv2nhb1Rqox.png" alt="20200730212919317"></p><h4 id="管道通信与共享内存通信有何区别？"><a href="#管道通信与共享内存通信有何区别？" class="headerlink" title="管道通信与共享内存通信有何区别？"></a>管道通信与共享内存通信有何区别？</h4><p>管道通信适用于有亲缘关系的进程，适合简单的数据传输；而共享内存通信适用于无亲缘关系的进程，适合大量数据共享和对性能要求较高的场景</p><h5 id="管道通信："><a href="#管道通信：" class="headerlink" title="管道通信："></a><strong>管道通信：</strong></h5><ol><li>管道是一种半双工的通信机制，只能在具有亲缘关系的进程之间使用（例如父子进程）。</li><li>管道是基于 I&#x2F;O 流的通信方式，数据写入管道的一端，从另一端读出。</li><li>管道通信是通过操作系统提供的管道文件进行的，可以是匿名管道（只存在于进程间）或命名管道（存在于文件系统中）。</li><li>管道通信适用于需要在两个相关进程之间进行简单数据传输的场景。</li></ol><p><strong>共享内存通信：</strong></p><ol><li>共享内存是一种进程间通信的机制，可以在无亲缘关系的进程之间使用。</li><li>共享内存允许多个进程访问同一块物理内存空间，因此可以实现高效的数据共享。</li><li>共享内存通信需要使用操作系统提供的共享内存 API，通过映射共享内存区域来实现进程间数据共享。</li><li>共享内存通信适用于需要大量数据交换且对性能要求较高的场景，因为它避免了数据复制的开销。</li></ol><h5 id="使用管道的步骤"><a href="#使用管道的步骤" class="headerlink" title="使用管道的步骤"></a>使用管道的步骤</h5><ol><li><strong>创建管道</strong>：使用 <code>pipe()</code> 系统调用创建一个无名管道。</li><li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程。</li><li><strong>重定向输入&#x2F;输出</strong>：使用 <code>dup2()</code> 将管道的读或写端重定向到标准输入或标准输出。</li><li><strong>关闭不需要的管道端</strong>：父进程和子进程都要关闭各自不需要使用的管道端。</li><li><strong>执行程序</strong>：使用 <code>execlp()</code> 或其他 <code>exec</code> 函数执行新程序。</li></ol><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipe_fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;Hello from parent process!&quot;</span>;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (pipe(pipe_fd) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建子进程</span><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 子进程</span><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br><br>        <span class="hljs-comment">// 读取管道</span><br>        <span class="hljs-type">ssize_t</span> nbytes = read(pipe_fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-comment">// 打印读取到的消息</span><br>        buf[nbytes] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child received message: %s\n&quot;</span>, buf);<br><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 父进程</span><br>        close(pipe_fd[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭读端</span><br><br>        <span class="hljs-comment">// 写入管道</span><br>        <span class="hljs-keyword">if</span> (write(pipe_fd[<span class="hljs-number">1</span>], msg, <span class="hljs-built_in">strlen</span>(msg)) == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        close(pipe_fd[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭写端</span><br>        wait(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>pipe()</code> 创建一个无名管道，<code>pipe_fd</code> 是一个包含两个文件描述符的数组，<code>pipe_fd[0]</code> 是读端，<code>pipe_fd[1]</code> 是写端。</p><p>在这个示例中没有使用 <code>dup2()</code> 重定向输入&#x2F;输出，而是直接使用文件描述符进行读写。你也可以通过 <code>dup2(pipe_fd[0], STDIN_FILENO)</code> 或 <code>dup2(pipe_fd[1], STDOUT_FILENO)</code> 来重定向标准输入&#x2F;输出。</p><p><strong>注意:当父进程fork()出子进程时，子进程会继承父进程的文件描述符。因此，子进程可以直接使用这些继承而来的文件描述符来读取或写入数据，从而与父进程进行通信。而无需使用<code>dup2()</code>来重定向输入&#x2F;输出。</strong></p><p>将管道的读端重定向到标准输入或将管道的写端重定向到标准输出是实现进程间通信的一种常见方式。这种方法可以实现多个进程之间的数据传输，而无需使用临时文件进行交换。</p><p>例如，如果一个进程需要从另一个进程中读取数据，可以通过将管道的读端重定向到标准输入来实现。这样，另一个进程输出的数据就会被发送到管道中，而第一个进程可以通过标准输入读取这些数据。</p><p>这种方法的好处在于，它提供了一种简单而高效的方式让不同的进程之间进行数据交换，而不需要创建临时文件或者复杂的通信协议。这对于实现诸如管道、重定向、过滤器等功能非常有用，同时也能够方便地实现进程间的通信和协作</p><h3 id="2-消息队列（Message-Queue）"><a href="#2-消息队列（Message-Queue）" class="headerlink" title="2. 消息队列（Message Queue）"></a>2. <strong>消息队列（Message Queue）</strong></h3><p>消息队列是一种允许进程以消息的形式进行通信的机制，多个进程可以向同一个队列中写入消息或从队列中读取消息。</p><ul><li>特点<ul><li>提供异步通信。</li><li>进程可以读取消息队列中的消息，或将消息发送到队列。</li><li>消息队列通常具有先进先出（FIFO）的顺序。</li></ul></li><li><strong>使用场景</strong>：适用于多个进程间异步交换数据的场景。</li></ul><h3 id="3-共享内存（Shared-Memory）"><a href="#3-共享内存（Shared-Memory）" class="headerlink" title="3. 共享内存（Shared Memory）"></a>3. <strong>共享内存（Shared Memory）</strong></h3><p>共享内存是一种允许多个进程访问同一块内存区域的通信方式。共享内存的读写操作直接在内存中进行，因此速度非常快。</p><ul><li>特点<ul><li>高效，因为直接操作内存而不需要通过内核。</li><li>需要同步机制（如互斥锁、信号量）来防止多个进程同时访问共享内存导致的数据竞争。</li></ul></li><li><strong>使用场景</strong>：适用于需要大量数据交换或频繁通信的进程。</li></ul><h3 id="4-信号量（Semaphore）"><a href="#4-信号量（Semaphore）" class="headerlink" title="4. 信号量（Semaphore）"></a>4. <strong>信号量（Semaphore）</strong></h3><p>信号量通常用于同步进程，它也可以用于进程间通信，特别是在控制资源访问时。信号量用于控制对共享资源的访问数量，通常配合其他IPC机制使用。</p><ul><li>特点<ul><li>可以用于同步多个进程的执行顺序。</li><li>信号量的值可以表示资源的数量或者进程的状态（如是否可继续执行）。</li></ul></li><li><strong>使用场景</strong>：用于控制访问资源的同步机制，常与其他IPC方式结合使用。</li></ul><h3 id="5-信号（Signal）"><a href="#5-信号（Signal）" class="headerlink" title="5. 信号（Signal）"></a>5. <strong>信号（Signal）</strong></h3><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p><img src="https://s2.loli.net/2024/05/29/lKU72cAyIfePCkz.png" alt="ef5085c798d54fc081611d0d488dfeb1"></p><blockquote><p><strong>信号</strong>：信号是 Linux 进程间通信的一种简单机制。它是由操作系统或进程向另一个进程发送的软件中断，用于通知进程发生了某种事件。</p><p><strong>信号处理程序</strong>：每个信号都与一个信号处理程序相关联，用于在收到信号时执行特定的操作。信号处理程序可以是预定义的函数，也可以是用户自定义的函数。</p><p><strong>信号的发送和接收</strong>：信号可以由内核、其他进程或进程自身发送。接收信号的进程可以选择忽略信号、执行默认操作或安装自定义的信号处理程序。</p><p><strong>常见的信号</strong>：Linux 系统定义了许多标准信号，如 SIGALRM（定时器到期）、SIGINT（终端中断）、SIGKILL（强制终止进程）等。</p><p><strong>信号的处理方式</strong>：每个进程都有一个信号处理表，记录了每个信号的处理方式。可以通过 <code>sigaction()</code> 函数来修改信号处理方式。</p><p><strong>信号的异步性</strong>：信号是异步事件，即进程可能在任何时刻接收到信号，而不一定是在某个特定的程序点。因此，编写信号处理程序时需要注意处理信号的竞态条件和可重入性。</p></blockquote><h5 id="使用Linux信号机制具体步骤："><a href="#使用Linux信号机制具体步骤：" class="headerlink" title="使用Linux信号机制具体步骤："></a>使用Linux信号机制具体步骤：</h5><ol><li><strong>定义信号处理程序</strong>：编写一个函数来处理特定的信号。</li><li><strong>注册信号处理程序</strong>：使用 <code>signal()</code> 或 <code>sigaction()</code> 函数将信号处理程序与特定的信号关联起来。</li><li><strong>触发信号</strong>：通过特定的操作或系统调用触发信号，或使用 <code>kill()</code> 函数向自己或其他进程发送信号。</li></ol><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信号处理程序</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sig == SIGINT) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGINT (Ctrl+C). Exiting gracefully...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGALRM) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received SIGALRM. Performing scheduled task...\n&quot;</span>);<br>        <span class="hljs-comment">// 在这里执行你需要的操作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Received signal %d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号处理程序</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    sa.sa_handler = signal_handler;<br>    sa.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;sa.sa_mask);<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGINT, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGINT handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (sigaction(SIGALRM, &amp;sa, <span class="hljs-literal">NULL</span>) == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error registering SIGALRM handler&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置一个定时器，5秒后发送 SIGALRM 信号</span><br>    alarm(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 无限循环，等待信号</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Waiting for signals...\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-套接字（Socket）"><a href="#6-套接字（Socket）" class="headerlink" title="6. 套接字（Socket）"></a>6. <strong>套接字（Socket）</strong></h3><p>套接字是一种网络通信机制，允许在不同计算机或同一计算机上运行的不同进程之间进行通信。套接字支持不同协议（如 TCP&#x2F;IP、UDP等）。</p><ul><li>特点<ul><li>支持进程间通信，也支持跨机器的通信。</li><li>可以进行全双工通信，支持发送和接收。</li></ul></li><li><strong>使用场景</strong>：适用于跨网络或本地的进程间通信，广泛用于客户端-服务器架构中的通信。</li></ul><h3 id="7-内存映射文件（Memory-Mapped-Files）"><a href="#7-内存映射文件（Memory-Mapped-Files）" class="headerlink" title="7. 内存映射文件（Memory-Mapped Files）"></a>7. <strong>内存映射文件（Memory-Mapped Files）</strong></h3><p>内存映射文件是一种将磁盘上的文件映射到进程的虚拟内存空间的机制。多个进程可以映射同一个文件，进程通过读写内存区域来进行通信。</p><ul><li>特点<ul><li>允许多个进程通过共享的内存映射文件进行通信。</li><li>对文件的修改会立即反映到内存中，从而实现高效的进程间数据共享。</li></ul></li><li><strong>使用场景</strong>：适用于需要高效共享大数据量的场景。</li></ul><h3 id="8-远程过程调用（RPC）"><a href="#8-远程过程调用（RPC）" class="headerlink" title="8. 远程过程调用（RPC）"></a>8. <strong>远程过程调用（RPC）</strong></h3><p>远程过程调用允许进程调用其他计算机或同一计算机上运行的进程的过程。RPC的核心思想是将分布式系统中的调用抽象成“本地调用”，即使实际执行的代码是在远程主机上。</p><ul><li>特点<ul><li>通过代理方式，使得分布式系统中的进程可以像调用本地进程一样调用远程进程。</li><li>在调用过程中，调用者和被调用者可以通过网络通信。</li></ul></li><li><strong>使用场景</strong>：适用于分布式计算、微服务架构中的进程间通信。</li></ul><h3 id="9-管道与FIFO文件（FIFOs）"><a href="#9-管道与FIFO文件（FIFOs）" class="headerlink" title="9. 管道与FIFO文件（FIFOs）"></a>9. <strong>管道与FIFO文件（FIFOs）</strong></h3><p>FIFOs（命名管道）是一种特殊类型的文件，允许进程通过文件进行通信。不同于传统的文件，FIFOs是进程间通信的媒介，可以让一个进程向FIFO文件写数据，另一个进程从中读取。</p><ul><li>特点<ul><li>支持跨进程的通信。</li><li>使用FIFO文件时，进程之间不需要共享内存或使用复杂的同步机制。</li></ul></li><li><strong>使用场景</strong>：适用于跨进程通信的简便场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/10/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="没有内存抽象的年代"><a href="#没有内存抽象的年代" class="headerlink" title="没有内存抽象的年代"></a>没有内存抽象的年代</h1><h2 id="管理方式："><a href="#管理方式：" class="headerlink" title="管理方式："></a>管理方式：</h2><p>程序直接访问和操作的都是物理内存，内存的管理也非常简单，除去操作系统所用的内存之外，全部给用户程序使用，想怎么折腾都行，只要别超出最大的容量。比如当执行如下指令时：mov reg,1000</p><h2 id="带来的问题："><a href="#带来的问题：" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>使得操作系统中存在多进程变得完全不可能，因为如果是多进程的话，由于直接操作物理内存地址，当一个进程给内存地址1000赋值后，另一个进程也同样给内存地址赋值，那么第二个进程对内存的赋值会覆盖第一个进程所赋的值，这回造成两条进程同时崩溃。</p><h1 id="进行抽象-地址空间"><a href="#进行抽象-地址空间" class="headerlink" title="进行抽象:地址空间"></a>进行抽象:地址空间</h1><h2 id="管理方式：-1"><a href="#管理方式：-1" class="headerlink" title="管理方式："></a>管理方式：</h2><p>操作系统给每个进程划分一个区段，把进程对应的内存依旧留在物理内存中，需要的时候就切换到特定的区域。该区域就是操作系统需要对物理内存做一层抽象，也就是「地址空间」，一个进程的地址空间包含了该进程所有相关内存，比如 code &#x2F; stack &#x2F; heap。</p><img src="https://s2.loli.net/2024/12/19/g4KvQb2HiBRXhDZ.png" alt="image-20241219212225816" style="zoom:50%;" /><p><strong>值得注意的是：当程序运行时，heap 和 stack 共用中间 free 的区域</strong></p><p>这里描述的是操作系统提供给运行程序的抽象（abstract）。程序不在物理地址0～16KB的内存中，而是加载在任意的物理地址。当操作系统这样做时，我们说操作系统在虚拟化内存（virtualizing memory），因为运行的程序认为它被加载到特定地址（例如0）的内存中，并且具有非常大的地址空间（例如32位或64位）。现实很不一样。这给该进程应用一种假象：自己独占整个操作系统内存。</p><p>真实的物理内存可能是这样的：</p><img src="https://s2.loli.net/2024/12/19/oAe9GuFCrVI8vw1.png" alt="image-20241219213017762" style="zoom:50%;" /><blockquote><p>虚拟内存三个目标：透明，效率，隔离保护</p></blockquote><p>其中从操作系统从虚拟内存映射到物理内存上时，使用基址寄存器base 和 界限寄存器bounds 可以简单的动态重定位：每个内存地址送到内存之前，都会自动加上基址寄存器的内容。，base 指明从哪里开始，bounds 指定哪里是边界。 因此真实物理地址和虚拟地址之间的关系是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">physical address = <span class="hljs-keyword">virtual</span> address + base<br></code></pre></td></tr></table></figure><p>有时，CPU 上用来做内存地址翻译的也会被叫做「内存管理单元 MMU」</p><h2 id="带来的问题：-1"><a href="#带来的问题：-1" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>抽象虽然解决了多进程覆盖的问题，但可以看到：栈和堆之间，有一大块“空闲”空间。如果我们将整个地址空间放入物理内存，那么栈和堆之间的空间并没有被进程使用，却依然占用了实际的物理内存。因此，简单的通过基址寄存器和界限寄存器实现的虚拟内存很浪费。另外，如果剩余物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。这种基址加界限的方式看来并不像我们期望的那样灵活。</p><h1 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&#x2F;界限"></a>分段：泛化的基址&#x2F;界限</h1><h2 id="管理方式：-2"><a href="#管理方式：-2" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在MMU中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段（segment）一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存。</p><img src="https://s2.loli.net/2024/12/19/yRn1ZmDSaQzK5iP.png" alt="image-20241219214240193" style="zoom: 33%;" /><p>在这其中操作系统使用MMU中的硬件结构来支持分段，使用一组多对基址和界限寄存器。表每个界限寄存器记录了一个段的大小进行管理。</p><p><img src="https://s2.loli.net/2024/12/19/Q7NT9DJR8iEVbua.png" alt="image-20241219214616230"></p><p>段式管理的地址变换如下：</p><p><img src="https://s2.loli.net/2024/12/19/s9A1nWe4zUBTdtg.png" alt="image-20241219214644880"></p><p>栈的管理可以使其反向增长即硬件还需要知道段的增长方向（用一位区分，比如1代表自小而大增长，0反之）。</p><p><img src="https://s2.loli.net/2024/12/19/yVCudXBlvZWOjAb.png" alt="image-20241219215036017"></p><p>随着分段机制的不断改进，为了支持共享，需要一些额外的硬件支持，这就是保护位（protection bit）。基本为每个段增加了几个位，标识程序是否能够读写该段，或执行其中的代码。通过将代码段标记为只读，同样的代码可以被多个进程共享，而不用担心破坏隔离。虽然每个进程都认为自己独占这块内存，但操作系统秘密地共享了内存，进程不能修改这些内存，所以假象得以保持。</p><p><img src="https://s2.loli.net/2024/12/19/QqbwIY4Rc7Bn6xW.png" alt="image-20241219215126644"></p><p>有了保护位，前面描述的硬件算法也必须改变。除了检查虚拟地址是否越界，硬件还需要检查特定访问是否允许。如果用户进程试图写入只读段，或从非执行段执行指令，硬件会触发异常，让操作系统来处理出错进程。</p><h2 id="带来的问题：-2"><a href="#带来的问题：-2" class="headerlink" title="带来的问题："></a>带来的问题：</h2><p>分段虽然大量节省了栈和堆之间没有使用的区域的内存，但也带来了新的问题：</p><p>1.操作系统在上下文切换时应该做什么？即：各个段寄存器中的内容必须保存和恢复。显然，每个进程都有自己独立的虚拟地址空间，操作系统必须在进程运行前，确保这些寄存器被正确地赋值。</p><p>2.管理物理内存的空闲空间。新的地址空间被创建时，操作系统需要在物理内存中为它的段找到空间。之前，我们假设所有的地址空间大小相同，物理内存可以被认为是一些槽块，进程可以放进去。现在，每个进程都有一些段，每个段的大小也可能不同。</p><p>3.分段使物理内存很快充满了许多空闲空间的小洞，因而很难分配给新的段，或扩大已有的段。这种问题被称为<strong>外部碎片</strong></p><img src="https://s2.loli.net/2024/12/19/95MYxJav2tR3lPC.png" alt="image-20241219215544783" style="zoom:25%;" /><p>这里的空闲内存的管理有许多方法，请自行百度</p><h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><h2 id="管理方式：-3"><a href="#管理方式：-3" class="headerlink" title="管理方式："></a>管理方式：</h2><p>在分段中，随着时间推移将空间切成不同长度的分片以后，空间本身会碎片化（fragmented），分配内存会变得比较困难。这就引出了页式存储：<strong>将空间分割成固定长度的分片</strong>在虚拟内存中，我们称这种思想为分页。分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。相应地，我们把物理内存看成是定长槽块的阵列，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。</p><img src="https://s2.loli.net/2024/12/19/gpzJwLlqhfS6RMF.png" alt="image-20241219220325363" style="zoom:25%;" /><blockquote><p>技术难点：如何通过页来实现虚拟内存，从而避免分段的问题？基本技术是什么？如何让这些技术运行良好，并尽可能减少空间和时间开销？</p></blockquote><p>通过完善的分页方法，操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。例如，我们不会假定堆和栈的增长方向，以及它们如何使用。另一个优点是分页提供的空闲空间管理的简单性。例如，如果操作系统希望将64字节的小地址空间放到8 页的物理地址空间中，它只要找到4个空闲页。也许操作系统保存了一个所有空闲页的空闲列表（free list），只需要从这个列表中拿出4个空闲页。</p><img src="https://s2.loli.net/2024/12/19/FmvwQhTAifotZzu.png" alt="image-20241219220601987" style="zoom:25%;" /><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p><img src="https://s2.loli.net/2024/12/19/xF1zUfctZ65V9YB.png" alt="image-20241219220707385" style="zoom:25%;" /><h3 id="页表带来的问题"><a href="#页表带来的问题" class="headerlink" title="页表带来的问题"></a>页表带来的问题</h3><p>页表带来了一个问题：页表可以变得非常大，因此消耗的内存太多</p><p>由于页表如此之大，我们没有在MMU中利用任何特殊的片上硬件，来存储当前正在运行的进程的页表，而是将每个进程的页表存储在内存中。</p><img src="https://s2.loli.net/2024/12/19/rOUL5Vd8zGEJ3TF.png" alt="image-20241219221140011" style="zoom:25%;" /><p>解决方法有很多比如：</p><ul><li>混合方法：分页和分段</li><li>多级页表</li><li>反向页表</li><li>将页表交换到磁盘</li></ul><p>详细可自行百度</p><h3 id="页式管理地址变换"><a href="#页式管理地址变换" class="headerlink" title="页式管理地址变换"></a>页式管理地址变换</h3><p>在页式系统中，指令所给出的地址分为两部分：逻辑页号和页内地址。</p><p>原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</p><p>逻辑页号，页内偏移地址－&gt;查进程页表，得物理页号－&gt;物理地址：</p><img src="https://s2.loli.net/2024/12/19/QVSgG42OWY9UANu.jpg" alt="v2-6fd0dc83a485be4df41e8f26a22d5217_1440w" style="zoom: 50%;" /><h3 id="分页带来的另一个问题："><a href="#分页带来的另一个问题：" class="headerlink" title="分页带来的另一个问题："></a>分页带来的另一个问题：</h3><p>使用分页作为核心机制来实现虚拟内存，可能会带来较高的性能开销。因为要使用分页，就要将内存地址空间切分成大量固定大小的单元（页），并且需要记录这些单元的地址映射信息。因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。因此我们面临如下问题：如何加速地址转换如何才能加速虚拟地址转换，尽量避免额外的内存访问？</p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>添加硬件(具有并行查找能力的高速缓冲存储器——快表)所谓的地址转换旁路缓冲存储器（translation-lookaside buffer，TLB[CG68,C95]），它就是频繁发生的虚拟到物理地址转换的硬件缓存（cache）,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应，主存中的页表也常称为慢表，配有快表的地址变换机对每次内存访问。硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表（其中有全部的转换映射）。</p><p><img src="https://s2.loli.net/2024/12/19/vISmptgqeYFz2Ao.png" alt="727485-20210705142341111-31060538"></p><p>在具有快表的分页机制中，地址的变换过程：</p><ul><li>CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li><li>如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ul><p>注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。</p><h1 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h1><h2 id="如何超越物理内存？【硬盘交互机制】"><a href="#如何超越物理内存？【硬盘交互机制】" class="headerlink" title="如何超越物理内存？【硬盘交互机制】"></a>如何超越物理内存？【硬盘交互机制】</h2><p>交换空间</p><h2 id="如何决定踢出哪个页？"><a href="#如何决定踢出哪个页？" class="headerlink" title="如何决定踢出哪个页？"></a>如何决定踢出哪个页？</h2><p>替换策略</p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
