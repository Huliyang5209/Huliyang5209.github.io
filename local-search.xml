<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>unicorn原理浅析</title>
    <link href="/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/unicorn%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="unicorn是什么？"><a href="#unicorn是什么？" class="headerlink" title="unicorn是什么？"></a>unicorn是什么？</h1><p><strong>Unicorn</strong> 是一个基于 QEMU 的轻量级 CPU 仿真框架，用于模拟多种架构（如 ARM、x86、MIPS 等）的指令执行和状态变化。其本质是通过 <strong>动态二进制翻译</strong> (Dynamic Binary Translation) 将目标架构的指令翻译为宿主架构可执行代码，并在宿主机运行。</p><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ul><li><strong>多架构支持</strong>：支持 ARM、x86、MIPS 等主流架构及模式（如 ARM&#x2F;Thumb）。</li><li><strong>指令仿真</strong>：精准模拟 CPU 指令行为（如跳转、寄存器操作、内存访问等）。</li><li><strong>内存与寄存器仿真</strong>：用户可自定义虚拟内存布局及操作寄存器。</li><li><strong>钩子机制</strong>：支持拦截指令、内存访问等，便于监控和调试。</li></ul><h3 id="本质特点"><a href="#本质特点" class="headerlink" title="本质特点"></a><strong>本质特点</strong></h3><ul><li><strong>动态翻译</strong>：基于 QEMU 的 TCG 技术，直接在宿主机运行目标指令，高效快捷。</li><li><strong>模块化</strong>：仅关注 CPU 指令仿真，易用、灵活，适合安全研究、逆向工程和嵌入式开发。</li></ul><h1 id="ARM64的体系架构"><a href="#ARM64的体系架构" class="headerlink" title="ARM64的体系架构"></a>ARM64的体系架构</h1><p>见上篇文章：ARM64架构</p><h1 id="unicorn怎么运行起来的？"><a href="#unicorn怎么运行起来的？" class="headerlink" title="unicorn怎么运行起来的？"></a>unicorn怎么运行起来的？</h1><p>CPU的运行，本质上就是：从内存中读取指令，并运行指令（包括输出结果，到对应内存地址或寄存器）</p><p>Unicorn要模拟的是CPU的运行。所以也就（只）是，把代码放到对应的地址上，Unicorn开始运行，去对应地址：<strong>读取指令</strong>，（解析并）<strong>执行指令</strong>，而解析和运行该指令的结果，往往是，本身就是，写入计算后的结果到对应的寄存器或内存而已。</p><p>而在指令执行期间的所需要的其他内容，比如后续会涉及到的函数参数、Stack栈、Heap堆等等，则都是为了：确保Unicorn模拟CPU的结果，和真实的代码执行的结果，要（完全）一致，才有价值，才能真正得到的希望的输出的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">指令<span class="hljs-operator">=</span>instruction <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 代码<span class="hljs-operator">=</span>code <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 操作码<span class="hljs-operator">=</span>opcode <span class="hljs-operator">=</span><span class="hljs-operator">=</span> 二进制(数据) <span class="hljs-operator">=</span><span class="hljs-operator">=</span> binary (data)<br></code></pre></td></tr></table></figure><h2 id="怎么模拟出内存等结构的？"><a href="#怎么模拟出内存等结构的？" class="headerlink" title="怎么模拟出内存等结构的？"></a>怎么模拟出内存等结构的？</h2><h3 id="程序的内存布局"><a href="#程序的内存布局" class="headerlink" title="程序的内存布局"></a>程序的内存布局</h3><p><img src="https://s2.loli.net/2024/12/17/kpMjRTFBOX3Qv2V.png" alt="image-20241217103506135"></p><p>一个常见的内存布局如下：</p><table><thead><tr><th><strong>内存区域</strong></th><th><strong>起始地址</strong></th><th><strong>大小</strong></th><th><strong>权限</strong></th></tr></thead><tbody><tr><td>代码段</td><td><code>0x40000</code></td><td>2 MB</td><td>可读可执行（RX）</td></tr><tr><td>数据段</td><td><code>0x42000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆区</td><td><code>0x60000</code></td><td>2 MB</td><td>可读可写（RW）</td></tr><tr><td>堆栈段</td><td><code>0x7FFF0000</code></td><td>1 MB（向下增长）</td><td>可读可写（RW）</td></tr></tbody></table><p><strong>代码段</strong>：</p><ul><li>通常映射在较低的地址区域，如 <code>0x40000</code>，用来存储程序的指令。</li><li>设置为可读可执行权限（<code>UC_PROT_READ | UC_PROT_EXEC</code>）。</li></ul><p><strong>数据段</strong>：</p><ul><li>紧邻代码段，用来存储全局变量、静态变量等。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>堆区</strong>：</p><ul><li>用于动态分配内存，可以根据程序运行时的需求调整大小。</li><li>通过自定义的内存管理器或直接扩展区域实现。</li></ul><p><strong>堆栈段</strong>：</p><ul><li>通常放在高地址区域（如 <code>0x7FFF0000</code>），并从高地址向低地址增长。</li><li>设置为可读可写权限（<code>UC_PROT_READ | UC_PROT_WRITE</code>）。</li></ul><p><strong>Unicorn 的内存设置是它自己模拟的，而不是由操作系统直接管理的</strong>。Unicorn 作为一个用户态的 CPU 仿真框架，模拟了目标架构的 CPU 和内存系统。Unicorn 将内存的虚拟地址（如 <code>0x40000</code> 或 <code>0x7FFF0000</code>）完全作为目标架构的地址模拟，与主机的虚拟地址无关。主机操作系统只负责分配 Unicorn 运行本身需要的资源（如 CPU 时间和主机内存），但不会干涉 Unicorn 模拟的内存布局。</p><p>值得注意的是：</p><p>Unicorn 本身并不会主动区分“特殊用途”地址和“普通地址”，但它的执行逻辑可能依赖用户分配的地址。但如果你在 <code>0x0 - 0xFFFF</code> 范围内映射代码或数据，可能会导致以下问题：</p><ol><li><strong>Unicorn 的初始化数据</strong>：某些架构可能会默认初始化特定的寄存器或内存区域到低地址，用户手动操作的地址可能与这些区域冲突。</li><li><strong>调试和兼容性问题</strong>：许多调试工具或调试器（如 GDB）默认会将低地址区域视为不可用的保留空间。如果代码被放置在低地址区域，调试时可能导致断点设置失败或程序崩溃。</li></ol><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>写入内容（代码，数据）到内存中之前，要注意先确认<code>字节序</code>&#x3D;<code>endian</code>是<code>大端</code>还是<code>小端</code></p><p>ARM中，默认是<code>小端</code>&#x3D;<code>UC_MODE_LITTLE_ENDIAN</code></p><p>除非特殊需要，才会设置为<code>大端</code>&#x3D;<code>UC_MODE_BIG_ENDIAN</code></p><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><table><thead><tr><th><strong>部分</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>(1) 动态二进制翻译（Dynamic Binary Translation）</strong></td><td></td></tr><tr><td><strong>翻译机制</strong></td><td>- 通过 QEMU 的 TCG（Tiny Code Generator）实现动态翻译。- 将目标架构的指令翻译为宿主架构的中间表示（IR, Intermediate Representation）。- 翻译后的代码缓存在 <strong>Translation Block Cache (TLB)</strong> 中。</td></tr><tr><td><strong>执行流程</strong></td><td>1. 解析目标架构指令。2. 使用 TCG 将指令翻译为宿主架构的中间代码（IR）。3. 中间代码再翻译为宿主机的原生机器指令，并直接运行。</td></tr><tr><td><strong>性能特点</strong></td><td>- 比解释型模拟（如 Bochs）快得多。- 动态翻译存在一定开销，但重复执行时利用 TLB 提升效率。</td></tr><tr><td><strong>(2) 指令的分发与仿真</strong></td><td></td></tr><tr><td><strong>指令获取</strong></td><td>- 从当前 <strong>PC（Program Counter）</strong> 所指向的地址读取目标内存中的指令。- 内存管理由 Unicorn 的虚拟内存模型负责，需通过 <strong><code>uc_mem_map</code></strong> 等接口预先映射内存。</td></tr><tr><td><strong>指令解析与翻译</strong></td><td>- 根据架构解码指令，提取操作码和操作数。示例：- <strong>ARM</strong>：解析指令类型（如分支 <code>BL</code>、数据处理 <code>ADD</code>、内存访问 <code>LDR</code>）。- <strong>x86</strong>：解析指令（如 <code>MOV</code>、<code>CALL</code>、<code>JMP</code>）。</td></tr><tr><td><strong>指令执行</strong></td><td>- 将解析的指令翻译为宿主机代码并执行。- 例如模拟内存访问、条件跳转、异常处理等。</td></tr><tr><td><strong>状态更新</strong></td><td>- 根据指令执行结果更新模拟状态（寄存器、内存等）。</td></tr><tr><td><strong>(3) 内存与寄存器仿真</strong></td><td></td></tr><tr><td><strong>内存仿真</strong></td><td>- Unicorn 使用虚拟内存模型模拟目标架构内存。- 用户通过 <strong><code>uc_mem_map</code></strong> 定义虚拟内存布局。- 所有内存访问都经 Unicorn 的内存管理层检查。</td></tr><tr><td><strong>寄存器仿真</strong></td><td>- 不同架构有各自的寄存器模型：    - <strong>x86</strong>：<code>EIP</code>、<code>ESP</code> 等。    - <strong>ARM</strong>：<code>R0-R15</code>、<code>PC</code>、<code>LR</code> 等。- 用户通过 <strong><code>uc_reg_read</code></strong> 和 <strong><code>uc_reg_write</code></strong> 接口操作寄存器。</td></tr><tr><td><strong>(4) 钩子机制（Hooking Mechanism）</strong></td><td></td></tr><tr><td><strong>代码钩子</strong></td><td>- 拦截特定指令或地址范围的执行。</td></tr><tr><td><strong>内存钩子</strong></td><td>- 拦截内存读写访问，用于监控或修改操作。</td></tr><tr><td><strong>异常钩子</strong></td><td>- 捕获未定义指令、未映射内存访问等异常。</td></tr><tr><td><strong>(5) 架构和模式切换</strong></td><td></td></tr><tr><td><strong>支持的架构</strong></td><td><strong>x86、x86_64、ARM、ARM64、MIPS、SPARC、PowerPC</strong></td></tr><tr><td><strong>模式切换</strong></td><td>- <strong>x86</strong>：支持 32 位和 64 位模式切换。- <strong>ARM</strong>：支持 ARM 模式和 Thumb 模式切换（通过 <code>BLX</code> 等指令）。- 用户初始化时通过 <code>Uc(UC_ARCH_ARM, UC_MODE_THUMB)</code> 指定模式，模拟中可根据指令动态切换。</td></tr></tbody></table><h1 id="unicorn使用的基本思想？"><a href="#unicorn使用的基本思想？" class="headerlink" title="unicorn使用的基本思想？"></a>unicorn使用的基本思想？</h1><h2 id="运行前初始化"><a href="#运行前初始化" class="headerlink" title="运行前初始化"></a>运行前初始化</h2><p>主要是对内存布局，比如：堆，栈等一些设置，注意对需要模拟的函数参数<strong>提前写入寄存器</strong>，其他一些特殊情况中，要给特定内存地址写入特定地址，供后续代码模拟时调用。</p><h2 id="运行中Hook"><a href="#运行中Hook" class="headerlink" title="运行中Hook"></a>运行中Hook</h2><p>开始运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">mu.emu_start(ADDRESS, ADDRESS + <span class="hljs-built_in">len</span>(ARM_CODE))<br></code></pre></td></tr></table></figure><ul><li>ADDRESS：最开始映射的代码的最初位置</li><li>ADDRESS + len(ARM_CODE)：映射的代码起始位置，加上对应代码长度后的，结束位置</li></ul><blockquote><p>为了用Unicorn模拟代码运行，调试出我们希望搞懂的函数的逻辑，往往期间需要很多额外的调试内容</p></blockquote><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>Unicorn模拟期间，常需要去搞懂底层正在发生的细节，查看对应的寄存器、内存的值等等，此时，就可以用到Unicorn所提供的机制：hook。</p><p>其中比较常用的一些hook是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">- hook代码<br>- hook特定指令<br>- hook内存<br>- hook异常<br>- hook其他<br></code></pre></td></tr></table></figure><p>关于Unicorn支持的hook的全部种类是：</p><p>指令执行类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_INTR`<br>- `UC_HOOK_INSN`<br>- `UC_HOOK_CODE`<br>- `UC_HOOK_BLOCK`<br></code></pre></td></tr></table></figure><p>内存访问类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_PROT`<br>- `UC_HOOK_MEM_WRITE_PROT`<br>- `UC_HOOK_MEM_FETCH_PROT`<br>- `UC_HOOK_MEM_READ`<br>- `UC_HOOK_MEM_WRITE`<br>- `UC_HOOK_MEM_FETCH`<br>- `UC_HOOK_MEM_READ_AFTER`<br></code></pre></td></tr></table></figure><p>异常处理类</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_MEM_READ_UNMAPPED`<br>- `UC_HOOK_MEM_WRITE_UNMAPPED`<br>- `UC_HOOK_MEM_FETCH_UNMAPPED`<br>- `UC_HOOK_INSN_INVALID`<br></code></pre></td></tr></table></figure><p>其他</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">- `UC_HOOK_EDGE_GENERATED`<br>- `UC_HOOK_TCG_OPCODE`<br></code></pre></td></tr></table></figure><p>Hook的设置，在运行中逐指令进行对比，当符合设置的内容时，触发钩子函数进行处理</p><h3 id="反编译代码"><a href="#反编译代码" class="headerlink" title="反编译代码"></a>反编译代码</h3><p>引入外部的反汇编器disassembler，比如<code>Capstone</code>，自己去把二进制翻译为对应指令</p><h2 id="运行后获取结果"><a href="#运行后获取结果" class="headerlink" title="运行后获取结果"></a>运行后获取结果</h2><h3 id="停止运行"><a href="#停止运行" class="headerlink" title="停止运行"></a>停止运行</h3><p>对于Unicorn来说，就是模拟CPU运行，模拟去读取指令和运行指令而已。</p><p>所以，换句话说，如果你的给code代码的地址空间写入了代码后，如果没有额外的跳转等复杂逻辑，则：</p><ul><li><strong>Unicorn会一直运行下去</strong></li></ul><p>如果没有合适的触发时机，去让其停下来，那就变成了死循环，永远不结束了。</p><p>而我们的目标是：模拟代码，尤其是函数的逻辑，希望代码运行完毕，输出结果的。</p><p>所以，此处往往选择一个合适的时机去触发其让Unicorn停下来。</p><p>这个时机，一般都是：<code>ret</code>指令，即，当发现正在运行的指令是<code>ret</code>指令，则就会调用<code>emu_stop</code>去停下来。</p><p><strong>在<code>hook_code</code>中，借助<code>Capstone</code>反编译出当前指令，其中<code>mnemonic</code>就是指令名称，当发现是<code>ret</code>指令时</strong></p><p>注：对于arm64e来说，还有更多的PAC相关ret指令：<code>retaa</code>、<code>retab</code>等，所以此处用<code>re</code>正则去判断指令名称是否匹配，而不是直接判断和<code>ret</code>是否相等。</p><p>就去调用<code>emu_stop()</code>去停止Unicorn的继续运行。</p><p><strong>这里也是借助Hook进行的</strong></p><h3 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h3><p>通过读取寄存器中的值来获取结果</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://book.crifan.org/books/cpu_emulator_unicorn/website/how_use/background/core_logic/cpu_logic.html">CPU的核心逻辑 · CPU模拟利器：Unicorn</a></p>]]></content>
    
    
    <categories>
      
      <category>符号/模拟执行</category>
      
      <category>unicorn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>angr原理浅析</title>
    <link href="/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <url>/2024/12/19/angr%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h1><h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><p><strong>约束条件（Constraints）</strong> 是对问题求解空间的限制或规定，它规定了哪些解是允许的，哪些解是不允许的。在数学、计算机科学、逻辑学等领域，约束条件通常用于描述某个问题的限制条件，目的是让我们能够从所有可能的解中筛选出符合特定规则或要求的解。</p><p>在数学中，约束条件通常是一些方程或不等式，定义了一个问题的解集。例如，约束条件 <code>x + y ≤ 10</code> 就表示在求解时，变量 <code>x</code> 和 <code>y</code> 的和不能超过 10。</p><p>在计算机科学，约束条件常常是对程序状态的描述，表示程序在某一时刻满足的条件或限制。例如，假设有一个条件 <code>if (x &lt; 10)</code>，那么在程序的执行过程中，<code>x &lt; 10</code> 就是一个约束条件。</p><h2 id="什么是Z3"><a href="#什么是Z3" class="headerlink" title="什么是Z3"></a>什么是Z3</h2><p><a href="https://github.com/Z3Prover/z3">Z3 solver</a> 是由微软开发的 <strong>可满足性模理论求解器</strong>（<strong>Satisfiability Modulo Theory solver</strong>， 即 <code>SMT solver</code>），用于检查逻辑表达式的可满足性，并可以找到一组约束中的其中一个可行解（无法找出所有的可行解）。</p><p>不深入研究的话，这里可以简单理解为：<strong>解方程</strong>，当然他还有很多应用场景比如：</p><ul><li><strong>布尔逻辑</strong>：可以处理布尔表达式，求解SAT（布尔可满足性）问题。</li><li><strong>线性算术</strong>：能够处理整数和实数的线性约束。</li><li><strong>非线性算术</strong>：支持非线性算术运算的求解。</li><li><strong>数组、集合、图结构</strong>：支持复杂的数据结构。</li><li><strong>符号执行</strong>：结合符号执行技术，Z3能对程序的执行路径进行分析和求解。</li><li><strong>程序验证</strong>：通过将程序的行为转化为约束，Z3可以帮助验证程序是否满足特定的安全性或功能性要求。</li><li><strong>自动化定理证明</strong>：Z3可以用来证明数学定理或逻辑公式的有效性。</li></ul><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> Solver, Real, sat<br><br><span class="hljs-comment"># 创建符号变量 x</span><br>x = Real(<span class="hljs-string">&#x27;x&#x27;</span>)<br><br><span class="hljs-comment"># 创建方程：x^2 - 3x + 2 = 0</span><br>equation = x**<span class="hljs-number">2</span> - <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 创建一个求解器</span><br>solver = Solver()<br><br><span class="hljs-comment"># 将方程添加到求解器</span><br>solver.add(equation)<br><br><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">if</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;方程无解&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/5rTdVqvCSa6zQtP.png" alt="image-20241219153257642" style="zoom:50%;" /></p><p>而不是：x &#x3D; 1和x &#x3D; 2</p><p>这是因为Z3 在求解方程时，默认情况下只返回第一个找到的解。这是因为 Z3 是一个 <strong>满足性求解器</strong>（Satisfiability Solver），它的目标是检查约束是否可满足，并返回其中一个满足约束的解，而不是所有可能的解。</p><p>通过进一步添加约束条件可以得到所有解（即排除已经找到的解）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查是否可解</span><br><span class="hljs-keyword">while</span> solver.check() == sat:<br>    model = solver.model()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;解为 x = <span class="hljs-subst">&#123;model[x]&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 排除当前解，继续寻找下一个解</span><br>    solver.add(x != model[x])<br></code></pre></td></tr></table></figure><p>结果是：<img src="https://s2.loli.net/2024/12/19/mJYOACvKk2acpsj.png" alt="image-20241219153642676" style="zoom:50%;" /></p><h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="https://s2.loli.net/2024/12/19/u3ez9CtglaXyJNk.png" alt="220430bodvqhbod4pty8zv"></p><p>符号执行是一种程序分析技术，它通过将程序中的某些变量替换为符号变量（而不是具体值），来模拟程序的执行。符号变量代表任意值，并通过符号计算来追踪程序的执行路径和计算结果。与传统的测试方法不同，它并不是通过具体的输入值来执行程序，而是通过符号表示的输入值来执行程序，并尝试探索程序中所有可能的执行路径。</p><h3 id="符号执行流程"><a href="#符号执行流程" class="headerlink" title="符号执行流程"></a>符号执行流程</h3><p><strong>符号变量</strong>： 在符号执行中，输入变量（例如函数参数、内存内容等）被替换为符号变量（symbolic variables），这些符号变量表示可以取任意值。与传统的实际值（如整数、字符串）不同，符号变量没有固定的值，而是代表一个值的集合或范围。</p><p><strong>路径探索</strong>： 符号执行通过模拟程序的控制流来探索不同的路径。每当程序遇到条件判断（例如 <code>if</code> 语句）时，它会根据符号变量的约束来分裂路径。符号执行引擎会为每条路径维护一组条件约束，表示该路径的执行条件。</p><p><strong>约束收集与求解</strong>： 在执行过程中，每当遇到条件判断时（例如 <code>if</code> 语句），符号执行引擎会根据条件生成约束（例如 <code>x &lt; 10</code> 或 <code>x &gt;= 10</code>）。这些约束随着路径的推进被累积。最后，使用约束求解器（如 Z3）来检查是否存在解，即判断某条路径是否可行。如果求解器找到了满足这些约束的具体输入值，那么符号执行就能沿着这条路径继续模拟执行。</p><h2 id="什么是angr"><a href="#什么是angr" class="headerlink" title="什么是angr?"></a>什么是angr?</h2><p><strong>angr</strong> 是一个基于 Python 的 <strong>二进制分析框架</strong>，专门用于分析二进制程序。它提供了一个强大的工具集，用于执行分析任务，如符号执行（Symbolic Execution）、路径探索（Path Exploration）、漏洞挖掘、逆向工程、静态分析等。</p><h2 id="angr的工作原理？"><a href="#angr的工作原理？" class="headerlink" title="angr的工作原理？"></a>angr的工作原理？</h2><ol><li><strong>加载二进制</strong>：<ul><li>使用 angr 加载目标二进制文件（例如 ELF、PE 格式的可执行文件）。</li></ul></li><li><strong>符号执行与路径探索</strong>：<ul><li>angr 会在二进制程序的某些地方插入符号（symbolic variables），并从程序入口点（例如 <code>main</code> 函数）开始执行。每执行一步，angr 会模拟程序的行为并生成新的约束条件。</li></ul></li><li><strong>生成约束</strong>：<ul><li>在符号执行过程中，程序的条件分支会根据符号变量的取值生成约束（例如：<code>x &lt; 10</code>）。这些约束会被加入到当前路径的状态中。</li></ul></li><li><strong>路径分裂</strong>：<ul><li>当遇到条件分支时，angr 会将程序的执行路径分裂成多个子路径。例如，<code>if (x &lt; 10)</code> 会导致两个路径，一个路径满足 <code>x &lt; 10</code>，另一个路径满足 <code>x &gt;= 10</code>。</li></ul></li><li><strong>求解与回溯</strong>：<ul><li>每条路径都会产生约束，angr 会通过求解器（如 Z3）来判断某条路径是否可行。如果路径不可行，angr 会将其丢弃。如果路径可行，它将继续沿着该路径执行，直到达到目标或出现漏洞。</li></ul></li></ol><p>可以看出同unicorn只能走一个分支相比，angr在运行的过程中，从给定的一个state(程序状态，程序的寄存器值，内存的不同都可以作为程序状态的不同)开始执行，每个state维护着一个约束条件的集合(比如i&lt;10,i!&#x3D;0)，通过收集约束，进行遍历，最终angr理论上可以遍历到程序的所有可能控制流，当angr运行到目标状态时，就可以调用求解器(z3等)对一路上收集到的约束进行求解，最终得到某个符号能够到达当前状态的值。</p><p><img src="https://s2.loli.net/2024/12/19/pwKVfMPCjUbX95v.jpg" alt="215918bnzmvv6wzoqingwv"></p><p>值得注意的是：同传统的静态符号执行(unicorn引擎)相比，<strong>angr使用的是混合执行技术，合并了静态符号执行，和动态具体执行两种技术</strong></p><p>动态符号执行（concolic execution）维持了两个状态。一种是实际变量的状态，另一种是符号化的状态。实际状态将随机生成值映射到变量中，而符号化状态将变量进行符号化。concolic首先将实际状态运行，并收集实际运行时该路径的变量符号化的约束式，i求解。并将约束式取反，获取另一条路径的约束式并求解。过程不断重复，知道路径被探索完，或者达到用户设置的限制。</p><p>具体的例子可以看到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 路径1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 路径2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      <span class="hljs-comment">// 路径3</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="动态执行过程"><a href="#动态执行过程" class="headerlink" title="动态执行过程"></a>动态执行过程</h3><ol><li><strong>实际状态</strong>：随机初始化输入，例如 <code>x = 15</code>。</li><li><strong>符号化状态</strong>：将 <code>x</code> 表示为符号变量 <code>X</code>。</li></ol><hr><h4 id="步骤1：运行实际状态并收集约束"><a href="#步骤1：运行实际状态并收集约束" class="headerlink" title="步骤1：运行实际状态并收集约束"></a><strong>步骤1：运行实际状态并收集约束</strong></h4><ol><li><p><strong>实际运行</strong>：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">15</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">15</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>1</code>，对应<strong>路径1</strong>。</p></li><li><p><strong>符号化执行</strong>：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt; <span class="hljs-number">10</span>  (路径<span class="hljs-number">1</span>)<br>X &lt; <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>将这些条件存入符号约束集。</p></li></ol><hr><h4 id="步骤2：生成新路径（约束取反）"><a href="#步骤2：生成新路径（约束取反）" class="headerlink" title="步骤2：生成新路径（约束取反）"></a><strong>步骤2：生成新路径（约束取反）</strong></h4><ol><li><p>从约束集中取反条件：</p><p>原路径约束为 <code>X &gt; 10 &amp;&amp; X &lt; 20</code>。</p><p>取反约束为 </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>即：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span> || X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择其中一条路径：<code>X &lt;= 10</code>**。</p><p>求解约束 <code>X &lt;= 10</code>，求解器可能返回 <code>X = 5</code>。</p></li></ol><hr><h4 id="步骤3：探索新路径"><a href="#步骤3：探索新路径" class="headerlink" title="步骤3：探索新路径"></a><strong>步骤3：探索新路径</strong></h4><ol><li><p>使用新值 <code>x = 5</code> 实际运行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">x = <span class="hljs-number">5</span><br><span class="hljs-comment">#执行路径为：</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>) &#123;           // 条件不成立<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>3</code>，对应<strong>路径3</strong>。</p></li><li><p>收集符号化约束：</p><p>符号化条件为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &lt;= <span class="hljs-number">10</span>  (路径<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="步骤4：继续探索未覆盖的路径"><a href="#步骤4：继续探索未覆盖的路径" class="headerlink" title="步骤4：继续探索未覆盖的路径"></a><strong>步骤4：继续探索未覆盖的路径</strong></h4><ol><li><p>再次从约束集中取反条件：</p><p>已探索的路径约束为：</p><p>​     路径1：<code>X &gt; 10 &amp;&amp; X &lt; 20</code></p><p>​     路径3：<code>X &lt;= 10</code></p><p>合并取反条件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">!(X &gt; <span class="hljs-number">10</span> &amp;&amp; X &lt; <span class="hljs-number">20</span>) &amp;&amp; !(X &lt;= <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><p>简化后为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">X &gt;= <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><p>**选择路径：<code>X &gt;= 20</code>**。</p><p>求解约束 <code>X &gt;= 20</code>，求解器可能返回 <code>X = 25</code>。</p></li><li><p>使用新值 <code>x = 25</code> 实际运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>执行路径为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &gt; <span class="hljs-number">10</span>) &#123;          // 条件成立<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">25</span> &lt; <span class="hljs-number">20</span>) &#123;      // 条件不成立<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：程序返回 <code>2</code>，对应<strong>路径2</strong>。</p></li></ol><hr><h4 id="终止条件"><a href="#终止条件" class="headerlink" title="终止条件"></a><strong>终止条件</strong></h4><p>动态符号执行会重复上述过程：</p><ol><li>实际运行一个具体值。</li><li>收集符号化约束。</li><li>取反约束生成新路径。</li><li>继续探索未覆盖的路径。</li></ol><p>直到：</p><ul><li><strong>所有路径都被探索</strong>：程序的逻辑分支全部覆盖。</li><li><strong>达到用户设定的限制</strong>：例如最大路径数量、最大求解时间等。</li></ul><h2 id="angr的不足"><a href="#angr的不足" class="headerlink" title="angr的不足"></a>angr的不足</h2><h3 id="未约束导致路径爆炸"><a href="#未约束导致路径爆炸" class="headerlink" title="未约束导致路径爆炸"></a>未约束导致路径爆炸</h3><p>在符号执行中，如果函数的输入变量或状态没有被有效约束（即没有设定足够的条件），Angr 等工具会把这些变量当作符号值进行推理和执行。而未约束的变量可能会导致两方面的问题：</p><ol><li><strong>不确定的输入</strong>： 如果输入没有约束（例如，函数的参数没有指定具体的值或者范围），那么每次执行到某个条件判断时，就会有多个可能的选择。例如，假设你有一个函数，其中某个参数 <code>x</code> 的值没有明确的限制，那么在 <code>if</code> 语句中对 <code>x</code> 的判断就可能导致多个分支，每个分支都有不同的路径。</li><li><strong>无限循环</strong>： 当未约束的变量影响到循环条件时，符号执行就无法准确预测循环何时结束，因为它并不知道循环的终止条件何时成立。例如，某个循环的退出条件可能是 <code>x == 0</code>，但 <code>x</code> 是一个未约束的符号变量，Angr 并不知道 <code>x</code> 什么时候会变为 0。因此，符号执行引擎就可能会一直在这个循环中进行模拟，导致路径在循环内无限增长。</li></ol><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">void foo(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果我们给定一个具体的值，例如 <code>x = 10</code>，程序会在 10 次迭代后退出。</li><li>但是如果 <code>x</code> 是一个未约束的符号变量（例如，Angr 看到 <code>x</code> 是一个符号值），它就不能确定 <code>x</code> 会在什么时候达到 0，或者是否有可能永远不为 0。</li></ul><p>在符号执行中，Angr 会尝试探索所有可能的路径。在这种情况下，由于 <code>x</code> 没有约束，符号执行引擎无法推断出 <code>x</code> 何时会变为 0，因此它可能会认为该循环将永远执行下去，导致<strong>路径爆炸</strong>。</p><h4 id="路径爆炸与无限循环的关系"><a href="#路径爆炸与无限循环的关系" class="headerlink" title="路径爆炸与无限循环的关系"></a><strong>路径爆炸与无限循环的关系</strong></h4><p>路径爆炸指的是，随着未约束变量的增加，符号执行的路径数量呈指数级增长，导致无法有效地探索所有路径。无限循环是路径爆炸的一种特殊情况，通常发生在没有足够约束的情况下，符号执行无法判断循环是否终止，从而导致执行路径无法终止。</p><p>例如，当未约束的循环变量 <code>x</code> 不断变化，且影响循环的终止条件时，Angr 可能会不断生成新的路径，每个路径代表不同的 <code>x</code> 值和不同的循环迭代次数，最终导致路径数量迅速膨胀，系统无法有效处理这些路径，从而导致“卡死”。</p><p>实例说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">int</span> func(<span class="hljs-built_in">int</span> x) &#123;<br>    <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;<br>        x = x - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 没有任何约束，Angr 会将其视为符号变量，可能会生成多条路径来探索 <code>x</code> 可能的值。每条路径都会尝试模拟 <code>x</code> 在每次循环中的变化，直到达到退出条件 <code>x &lt;= 0</code>。</p><p>在符号执行的过程中，Angr 会对每次 <code>x = x - 1</code> 做出决策，并生成新的路径。</p><p>如果没有足够的约束（例如，限制 <code>x</code> 的值或设置循环的最大迭代次数），Angr 可能会生成大量的路径来模拟不同的 <code>x</code> 值和循环次数，导致路径数目激增，甚至无法终止。</p><h3 id="误报"><a href="#误报" class="headerlink" title="误报"></a>误报</h3><p>事实上angr是基于符号执行来遍历程序的所有路径，它是否能遍历所有路径其实取决于其约束求解引擎是否强大，这里采用的是z3<br>当它能明确发现这个条件是无法满足的时候就不会走向这个路径，我们可以称之为虚假控制流。<br>但是如果程序本身的逻辑中存在一个条件是非常难以满足的，或者说超出了约束求解引擎的能力，那么则有可能到达不了这个路径，就会被误标记为虚假的控制流，实际中是很少出现的。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">[动若脱兔:深入浅出angr--初步理解符号执行以及angr架构 - 0xJDchen - 博客园](https://www.cnblogs.com/0xJDchen/p/9291335.html)<br><br>[利用angr去除混淆的优势，不足与实践 - 吾爱破解 - 52pojie.cn](https://www.52pojie.cn/thread-1484714-1-1.html)<br><br>[angr_ctf——从0学习angr（一）：angr简介与核心概念 - Uiharu - 博客园](https://www.cnblogs.com/level5uiharu/p/16925991.html)<br><br>[angr - CTF Wiki](https://ctf-wiki.org/reverse/tools/simulate-execution/angr/)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>符号/模拟执行</category>
      
      <category>angr</category>
      
    </categories>
    
    
    <tags>
      
      <tag>符号执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
